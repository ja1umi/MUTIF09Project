0001                         *UART	EQU	$8018
0002 b000                    UART	EQU	$B000
0003 b001                    RECEV	EQU	UART+1
0004 b001                    TRANS	EQU	UART+1
0005 b000                    USTAT	EQU	UART
0006 b000                    UCTRL	EQU	UART
0007                         
0008 0008                    BS	EQU	8	BACKSPACE
0009 000d                    CR	EQU	$D	ENTER KEY
0010 001b                    ESC	EQU	$1B	ESCAPE CODE
0011 0020                    SPACE	EQU	$20	SPACE (BLANK)
0012 003a                    STKBUF	EQU	58	STACK BUFFER ROOM
0013 00fa                    LBUFMX	EQU	250	MAX NUMBER OF CHARS IN A BASIC LINE
0014 00fa                    MAXLIN	EQU	$FA	MAXIMUM MS BYTE OF LINE NUMBER
0015                         * PSEUDO OPS
0016 0021                    SKP1	EQU	$21	OP CODE OF BRN - SKIP ONE BYTE
0017 008c                    SKP2	EQU	$8C	OP CODE OF CMPX # - SKIP TWO BYTES
0018 0086                    SKP1LD	EQU	$86	OP CODE OF LDA # - SKIP THE NEXT BYTE
0019                         *			AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
0020                         *			IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
0021                         *RTS_LOW	EQU	$15
0022 0095                    RTS_LOW	EQU	$95
0023 0000                    	ORG	0
0024 0000                    ENDFLG	RMB	1	STOP/END FLAG: POSITIVE=STOP, NEG=END
0025 0001                    CHARAC	RMB	1	TERMINATOR FLAG 1
0026 0002                    ENDCHR	RMB	1	TERMINATOR FLAG 2
0027 0003                    TMPLOC	RMB	1	SCRATCH VARIABLE
0028 0004                    IFCTR	RMB	1	IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
0029 0005                    DIMFLG	RMB	1	*DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
0030 0006                    VALTYP	RMB	1	*DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
0031 0007                    GARBFL	RMB	1	*TV STRING SPACE HOUSEKEEPING FLAG
0032 0008                    ARYDIS	RMB	1	DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
0033 0009                    INPFLG	RMB	1	*TV INPUT FLAG: READ=0, INPUT<>0
0034 000a                    RELFLG	RMB	1	*TV RELATIONAL OPERATOR FLAG
0035 000b                    TEMPPT	RMB	2	*PV TEMPORARY STRING STACK POINTER
0036 000d                    LASTPT	RMB	2	*PV ADDR OF LAST USED STRING STACK ADDRESS
0037 000f                    TEMPTR	RMB	2	TEMPORARY POINTER
0038 0011                    TMPTR1	RMB	2	TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
0039 0013                    FPA2	RMB	4	FLOATING POINT ACCUMULATOR #2 MANTISSA
0040 0017                    BOTSTK	RMB	2	BOTTOM OF STACK AT LAST CHECK
0041 0019                    TXTTAB	RMB	2	*PV BEGINNING OF BASIC PROGRAM
0042 001b                    VARTAB	RMB	2	*PV START OF VARIABLES
0043 001d                    ARYTAB	RMB	2	*PV START OF ARRAYS
0044 001f                    ARYEND	RMB	2	*PV END OF ARRAYS (+1)
0045 0021                    FRETOP	RMB	2	*PV START OF STRING STORAGE (TOP OF FREE RAM)
0046 0023                    STRTAB	RMB	2	*PV START OF STRING VARIABLES
0047 0025                    FRESPC	RMB	2	UTILITY STRING POINTER
0048 0027                    MEMSIZ	RMB	2	*PV TOP OF STRING SPACE
0049 0029                    OLDTXT	RMB	2	SAVED LINE NUMBER DURING A "STOP"
0050 002b                    BINVAL	RMB	2	BINARY VALUE OF A CONVERTED LINE NUMBER
0051 002d                    OLDPTR	RMB	2	SAVED INPUT PTR DURING A "STOP"
0052 002f                    TINPTR	RMB	2	TEMPORARY INPUT POINTER STORAGE
0053 0031                    DATTXT	RMB	2	*PV 'DATA' STATEMENT LINE NUMBER POINTER
0054 0033                    DATPTR	RMB	2	*PV 'DATA' STATEMENT ADDRESS POINTER
0055 0035                    DATTMP	RMB	2	DATA POINTER FOR 'INPUT' & 'READ'
0056 0037                    VARNAM	RMB	2	*TV TEMP STORAGE FOR A VARIABLE NAME
0057 0039                    VARPTR	RMB	2	*TV POINTER TO A VARIABLE DESCRIPTOR
0058 003b                    VARDES	RMB	2	TEMP POINTER TO A VARIABLE DESCRIPTOR
0059 003d                    RELPTR	RMB	2	POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
0060 003f                    TRELFL	RMB	1	TEMPORARY RELATIONAL OPERATOR FLAG BYTE
0061                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
0062                         * USED AS SCRATCH PAD VARIABLES.
0063                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0064 0040                    V40	RMB	1
0065 0041                    V41	RMB	1
0066 0042                    V42	RMB	1
0067 0043                    V43	RMB	1
0068 0044                    V44	RMB	1
0069                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0070 0045                    V45	RMB	1
0071 0046                    V46	RMB	1
0072 0047                    V47	RMB	1
0073 0048                    V48	RMB	2
0074                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A�$4E)
0075 004a                    V4A	RMB	1
0076 004b                    V4B	RMB	2
0077 004d                    V4D	RMB	2
0078                         ** FLOATING POINT ACCUMULATOR #0
0079 004f                    FP0EXP	RMB	1	*PV FLOATING POINT ACCUMULATOR #0 EXPONENT
0080 0050                    FPA0	RMB	4	*PV FLOATING POINT ACCUMULATOR #0 MANTISSA
0081 0054                    FP0SGN	RMB	1	*PV FLOATING POINT ACCUMULATOR #0 SIGN
0082 0055                    COEFCT	RMB	1	POLYNOMIAL COEFFICIENT COUNTER
0083 0056                    STRDES	RMB	5	TEMPORARY STRING DESCRIPTOR
0084 005b                    FPCARY	RMB	1	FLOATING POINT CARRY BYTE
0085                         ** FLOATING POINT ACCUMULATOR #1
0086 005c                    FP1EXP	RMB	1	*PV FLOATING POINT ACCUMULATOR #1 EXPONENT
0087 005d                    FPA1	RMB	4	*PV FLOATING POINT ACCUMULATOR #1 MANTISSA
0088 0061                    FP1SGN	RMB	1	*PV FLOATING POINT ACCUMULATOR #1 SIGN
0089 0062                    RESSGN	RMB	1	SIGN OF RESULT OF FLOATING POINT OPERATION
0090 0063                    FPSBYT	RMB	1	FLOATING POINT SUB BYTE (FIFTH BYTE)
0091 0064                    COEFPT	RMB	2	POLYNOMIAL COEFFICIENT POINTER
0092 0066                    LSTTXT	RMB	2	CURRENT LINE POINTER DURING LIST
0093 0068                    CURLIN	RMB	2	*PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
0094 006a                    DEVCFW	RMB	1	*TV TAB FIELD WIDTH
0095 006b                    DEVLCF	RMB	1	*TV TAB ZONE
0096 006c                    DEVPOS	RMB	1	*TV PRINT POSITION
0097 006d                    DEVWID	RMB	1	*TV PRINT WIDTH
0098 006e                    RSTFLG	RMB	1	*PV WARM START FLAG: $55=WARM, OTHER=COLD
0099 006f                    RSTVEC	RMB	2	*PV WARM START VECTOR - JUMP ADDRESS FOR WARM START
0100 0071                    TOPRAM	RMB	2	*PV TOP OF RAM
0101 0073                    IKEYIM	RMB	1	*TV INKEY$ RAM IMAGE
0102 0074                    ZERO	RMB	2	*PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
0103                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0104 0076                    LPTCFW	RMB	1	16
0105 0077                    LPTLCF	RMB	1	112
0106 0078                    LPTWID	RMB	1	132
0107 0079                    LPTPOS	RMB	1	0
0108 007a                    EXECJP	RMB	2	LB4AA
0109                         
0110                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
0111                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
0112                         * INTERPRETED IS STORED AT CHARAD.
0113 007c 0c 84              GETNCH	INC	<CHARAD+1	*PV INCREMENT LS BYTE OF INPUT POINTER
0114 007e 26 02              	BNE	GETCCH	*PV BRANCH IF NOT ZERO (NO CARRY)
0115 0080 0c 83              	INC	<CHARAD	*PV INCREMENT MS BYTE OF INPUT POINTER
0116 0082 b6                 GETCCH	FCB	$B6	*PV OP CODE OF LDA EXTENDED
0117 0083                    CHARAD	RMB	2	*PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
0118                         *	*	CHARACTER WHICH THE BASIC INTERPRETER IS
0119                         *	*	PROCESSING
0120 0085 7e e1 c4           	JMP	BROMHK	JUMP BACK INTO THE BASIC RUM
0121                         
0122 0088                    VAB	RMB	1	= LOW ORDER FOUR BYTES OF THE PRODUCT
0123 0089                    VAC	RMB	1	= OF A FLOATING POINT MULTIPLICATION
0124 008a                    VAD	RMB	1	= THESE BYTES ARE USE AS RANDOM DATA
0125 008b                    VAE	RMB	1	= BY THE RND STATEMENT
0126                         
0127                         * EXTENDED BASIC VARIABLES
0128 008c                    TRCFLG	RMB	1	*PV TRACE FLAG 0=OFF ELSE=ON
0129 008d                    USRADR	RMB	2	*PV ADDRESS OF THE START OF USR VECTORS
0130                         
0131                         * EXTENDED BASIC SCRATCH PAD VARIABLES
0132 008f                    VCF	RMB	2
0133 0091                    VD1	RMB	2
0134 0093                    VD3	RMB	2
0135 0095                    VD5	RMB	2
0136 0097                    VD7	RMB	1
0137 0098                    VD8	RMB	1
0138 0099                    VD9	RMB	1
0139 009a                    VDA	RMB	1
0140 009b                    SW3VEC	RMB	3
0141 009e                    SW2VEC	RMB	3
0142 00a1                    SWIVEC	RMB	3
0143 00a4                    NMIVEC	RMB	3
0144 00a7                    IRQVEC	RMB	3
0145 00aa                    FRQVEC	RMB	3
0146 00ad                    USRJMP	RMB	3	JUMP ADDRESS FOR BASIC'S USR FUNCTION
0147 00b0                    RVSEED	RMB	1	* FLOATING POINT RANDOM NUMBER SEED EXPONENT
0148 00b1                    	RMB	4	* MANTISSA: INITIALLY SET TO $804FC75259
0149                         
0150                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
0151 00b5                    USR0	RMB	2	USR 0 VECTOR
0152 00b7                    	RMB	2	USR 1
0153 00b9                    	RMB	2	USR 2
0154 00bb                    	RMB	2	USR 3
0155 00bd                    	RMB	2	USR 4
0156 00bf                    	RMB	2	USR 5
0157 00c1                    	RMB	2	USR 6
0158 00c3                    	RMB	2	USR 7
0159 00c5                    	RMB	2	USR 8
0160 00c7                    	RMB	2	USR 9
0161                         
0162 00c9                    STRSTK	RMB	8*5	STRING DESCRIPTOR STACK
0163 00f1                    LINHDR	RMB	2	LINE INPUT BUFFER HEADER
0164 00f3                    LINBUF	RMB	LBUFMX+1	BASIC LINE INPUT BUFFER
0165 01ee                    STRBUF	RMB	41	STRING BUFFER
0166                         
0167 0217                    PROGST	RMB	1	START OF PROGRAM SPACE
0168                         *	INTERRUPT VECTORS
0169 fff2                    	ORG	$FFF2
0170 fff2                    SWI3	RMB	2
0171 fff4                    SWI2	RMB	2
0172 fff6                    FIRQ	RMB	2
0173 fff8                    IRQ	RMB	2
0174 fffa                    SWI	RMB	2
0175 fffc                    NMI	RMB	2
0176 fffe                    RESETV	RMB	2
0177                         
0178                         
0179                         
0180 e000                    	ORG	$E000
0181                         
0182                         * CONSOLE IN
0183 e000 8d 03              LA171	BSR	KEYIN	GET A CHARACTER FROM CONSOLE IN
0184 e002 27 fc              	BEQ	LA171	LOOP IF NO KEY DOWN
0185 e004 39                 	RTS
0186                         
0187                         *
0188                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
0189                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
0190                         *
0191                         *
0192                         LA1C1
0193 e005 b6 b0 00           KEYIN	LDA	USTAT
0194 e008 85 01              	BITA	#1
0195 e00a 27 06              	BEQ	NOCHAR
0196 e00c b6 b0 01           	LDA	RECEV
0197 e00f 84 7f              	ANDA	#$7F
0198 e011 39                 	RTS
0199 e012 4f                 NOCHAR	CLRA
0200 e013 39                 	RTS
0201                         
0202                         * CONSOLE OUT
0203 e014 8d 24              PUTCHR	BSR	WAITACIA
0204 e016 34 02              	PSHS	A
0205 e018 81 0d              	CMPA	#CR	IS IT CARRIAGE RETURN?
0206 e01a 27 0b              	BEQ	NEWLINE	YES
0207 e01c b7 b0 01           	STA	TRANS
0208 e01f 0c 79              	INC	LPTPOS	INCREMENT CHARACTER COUNTER
0209 e021 96 79              	LDA	LPTPOS	CHECK FOR END OF LINE PRINTER LINE
0210 e023 91 78              	CMPA	LPTWID	AT END OF LINE PRINTER LINE?
0211 e025 25 10              	BLO	PUTEND	NO
0212 e027 0f 79              NEWLINE	CLR	LPTPOS	RESET CHARACTER COUNTER
0213 e029 8d 0f              	BSR	WAITACIA
0214 e02b 86 0d              	LDA	#13
0215 e02d b7 b0 01           	STA	TRANS
0216 e030 8d 08              	BSR	WAITACIA
0217 e032 86 0a              	LDA	#10		DO LINEFEED AFTER CR
0218 e034 b7 b0 01           	STA	TRANS
0219 e037 35 02              PUTEND	PULS	A
0220 e039 39                 	RTS
0221                         
0222 e03a 34 02              WAITACIA	PSHS	A
0223 e03c b6 b0 00           WRWAIT	LDA	USTAT
0224 e03f 85 02              	BITA	#2
0225 e041 27 f9              	BEQ	WRWAIT
0226 e043 35 02              	PULS	A
0227 e045 39                 	RTS
0228                         
0229                         *
0230                         RESVEC
0231 e046 10 ce 01 ee        LA00E	LDS	#LINBUF+LBUFMX+1 SET STACK TO TOP OF LINE INPUT BUFFER
0232 e04a 96 6e              	LDA	RSTFLG	GET WARM START FLAG
0233 e04c 81 55              	CMPA	#$55	IS IT A WARM START?
0234 e04e 26 0a              	BNE	BACDST	NO - D0 A COLD START
0235 e050 9e 6f              	LDX	RSTVEC	WARM START VECTOR
0236 e052 a6 84              	LDA	,X	GET FIRST BYTE OF WARM START ADDR
0237 e054 81 12              	CMPA	#$12	IS IT NOP?
0238 e056 26 02              	BNE	BACDST	NO - DO A COLD START
0239 e058 6e 84              	JMP	,X	YES, G0 THERE
0240                         
0241                         * COLD START ENTRY
0242                         
0243 e05a 8e 02 18           BACDST	LDX	#PROGST+1	POINT X TO CLEAR 1ST 1K OF RAM
0244 e05d 6f 83              LA077	CLR	,--X	MOVE POINTER DOWN TWO-CLEAR BYTE
0245 e05f 30 01              	LEAX	1,X	ADVANCE POINTER ONE
0246 e061 26 fa              	BNE	LA077	KEEP GOING IF NOT AT BOTTOM OF PAGE 0
0247 e063 8e 02 17           	LDX	#PROGST	SET TO START OF PROGRAM SPACE
0248 e066 6f 80              	CLR	,X+	CLEAR 1ST BYTE OF BASIC PROGRAM
0249 e068 9f 19              	STX	TXTTAB	BEGINNING OF BASIC PROGRAM
0250 e06a a6 02              LA084	LDA	2,X	LOOK FOR END OF MEMORY
0251 e06c 43                 	COMA		* COMPLEMENT IT AND PUT IT BACK
0252 e06d a7 02              	STA	2,X	* INTO SYSTEM MEMORY
0253 e06f a1 02              	CMPA	2,X	IS IT RAM?
0254 e071 26 06              	BNE	LA093	BRANCH IF NOT (ROM, BAD RAM OR NO RAM)
0255 e073 30 01              	LEAX	1,X	MOVE POINTER UP ONE
0256 e075 63 01              	COM	1,X	RE-COMPLEMENT TO RESTORE BYTE
0257 e077 20 f1              	BRA	LA084	KEEP LOOKING FOR END OF RAM
0258 e079 9f 71              LA093	STX	TOPRAM	SAVE ABSOLUTE TOP OF RAM
0259 e07b 9f 27              	STX	MEMSIZ	SAVE TOP OF STRING SPACE
0260 e07d 9f 23              	STX	STRTAB	SAVE START OF STRING VARIABLES
0261 e07f 30 89 ff 38        	LEAX	-200,X	CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
0262 e083 9f 21              	STX	FRETOP	SAVE START OF STRING SPACE
0263 e085 1f 14              	TFR	X,S	PUT STACK THERE
0264 e087 8e e0 d3           	LDX	#LA10D	POINT X TO ROM SOURCE DATA
0265 e08a ce 00 76           	LDU	#LPTCFW	POINT U TO RAM DESTINATION
0266 e08d c6 12              	LDB	#18	MOVE 18 BYTES
0267 e08f bd e1 b3           	JSR	LA59A	MOVE 18 BYTES FROM ROM TO RAM
0268 e092 ce 00 a7           	LDU	#IRQVEC	POINT U TO NEXT RAM DESTINATION
0269 e095 c6 04              	LDB	#4	MOVE 4 MORE BYTES
0270 e097 bd e1 b3           	JSR	LA59A	MOVE 4 BYTES FROM ROM TO RAM
0271 e09a 86 39              	LDA	#$39
0272 e09c 97 f0              	STA	LINHDR-1	PUT RTS IN LINHDR-1
0273 e09e bd e4 bf           	JSR	LAD19	G0 DO A 'NEW'
0274                         * EXTENDED BASIC INITIALISATION
0275 e0a1 8e 00 b5           	LDX	#USR0	INITIALIZE ADDRESS OF START OF
0276 e0a4 9f 8d              	STX	USRADR	USR JUMP TABLE
0277                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
0278 e0a6 ce eb d3           	LDU	#LB44A	ADDRESS OF 'FC ERROR' ROUTINE
0279 e0a9 c6 0a              	LDB	#10	10 USR CALLS IN EX BASIC
0280 e0ab ef 81              L8031	STU	,X++	STORE 'FC' ERROR AT USR ADDRESSES
0281 e0ad 5a                 	DECB		FINISHED ALL 10?
0282 e0ae 26 fb              	BNE	L8031	NO
0283                         
0284                         * INITIALISE ACIA
0285 e0b0 86 03              	LDA #3			MASTER RESET
0286 e0b2 b7 b0 00           	STA UCTRL
0287 e0b5 86 95              	LDA	#RTS_LOW	DIV16 CLOCK -> 1843200 / 16 = 115200
0288 e0b7 b7 b0 00           	STA	UCTRL
0289 e0ba 8e e1 08           	LDX	#LA147-1	POINT X TO COLOR BASIC COPYRIGHT MESSAGE
0290 e0bd bd f0 e7           	JSR	LB99C	PRINT 'COLOR BASIC'
0291 e0c0 8e e0 cb           	LDX	#BAWMST	WARM START ADDRESS
0292 e0c3 9f 6f              	STX	RSTVEC	SAVE IT
0293 e0c5 86 55              	LDA	#$55	WARM START FLAG
0294 e0c7 97 6e              	STA	RSTFLG	SAVE IT
0295 e0c9 20 04              	BRA	LA0F3	GO TO BASIC'S MAIN LOOP
0296 e0cb 12                 BAWMST	NOP	NOP REQ'D FOR WARM START
0297 e0cc bd e4 d9           	JSR	LAD33	DO PART OF A NEW
0298 e0cf 7e e4 27           LA0F3	JMP	LAC73	GO TO MAIN LOOP OF BASIC
0299                         *
0300                         * FIRQ SERVICE ROUTINE
0301                         BFRQSV
0302 e0d2 3b                 	RTI
0303                         *
0304                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
0305 e0d3 10                 LA10D	FCB	16	TAB FIELD WIDTH
0306 e0d4 40                 	FCB	64	LAST TAB ZONE
0307 e0d5 ff                 	FCB	255	PRINTER WIDTH
0308 e0d6 00                 	FCB	0	LINE PRINTER POSITION
0309 e0d7 eb d3              	FDB	LB44A	ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
0310                         * LINE INPUT ROUTINE
0311 e0d9 0c 84              	INC	CHARAD+1
0312 e0db 26 02              	BNE	LA123
0313 e0dd 0c 83              	INC	CHARAD
0314 e0df b6 00 00           LA123	LDA	>0000
0315 e0e2 7e e1 c4           	JMP	BROMHK
0316                         *
0317                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
0318 e0e5 7e e1 c3           	JMP	BIRQSV	IRQ SERVICE
0319 e0e8 7e e0 d2           	JMP	BFRQSV	FIRQ SERVICE
0320 e0eb 7e eb d3           	JMP	LB44A	USR ADDRESS FOR 8K BASIC (INITIALIZED TO �FC� ERROR)
0321 e0ee 80                 	FCB	$80	*RANDOM SEED
0322 e0ef 4f c7              	FDB	$4FC7	*RANDON SEED OF MANTISSA
0323 e0f1 52 59              	FDB	$5259	*.811635157
0324                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
0325 e0f3 32                 COMVEC	FCB	50	50 BASIC COMMANDS
0326 e0f4 e2 22              	FDB	LAA66	POINTS TO RESERVED WORDS
0327 e0f6 e3 2f              	FDB	LAB67	POINTS TO JUMP TABLE FOR COMMANDS
0328 e0f8 1d                 	FCB	29	29 BASIC SECONDARY COMMANDS
0329 e0f9 e2 c2              	FDB	LAB1A	POINTS TO SECONDARY FUNCTION RESERVED WORDS
0330 e0fb e1 d3              	FDB	LAA29	POINTS TO SECONDARY FUNCTION JUMP TABLE
0331 e0fd 00 00              	FDB	0	NO MORE TABLES (RES WORDS=0)
0332 e0ff 00 00              	FDB	0	NO MORE TABLES
0333 e101 00 00              	FDB	0	NO MORE TABLES
0334 e103 00 00              	FDB	0	NO MORE TABLES
0335 e105 00 00              	FDB	0	NO MORE TABLES
0336 e107 00 00              	FDB	0	NO MORE TABLES (SECONDARY FNS =0)
0337                         
0338                         * COPYRIGHT MESSAGES
0339 e109 36 38 30 39 20 45  LA147	FCC	"6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
0340 e11c 0d                 	FCB	CR
0341 e11d 28 43 29 20 31 39  	FCC	"(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
0342 e132 0d 0d              LA156	FCB	CR,CR
0343 e134 00                 LA165	FCB	$00
0344                         
0345                         
0346 e135 34 16              LA35F	PSHS	X,B,A	SAVE REGISTERS
0347 e137 9e 76              	LDX	LPTCFW	TAB FIELD WIDTH AND TAB ZONE
0348 e139 dc 78              	LDD	LPTWID	PRINTER WIDTH AND POSITION
0349 e13b 9f 6a              LA37C	STX	DEVCFW	SAVE TAB FIELD WIDTH AND ZONE
0350 e13d d7 6c              	STB	DEVPOS	SAVE PRINT POSITION
0351 e13f 97 6d              	STA	DEVWID	SAVE PRINT WIDTH
0352 e141 35 96              	PULS	A,B,X,PC	RESTORE REGISTERS
0353                         
0354                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
0355                         * EXIT WITH BREAK KEY: CARRY = 1
0356                         * EXIT WITH ENTER KEY: CARRY = 0
0357                         LA38D
0358 e143 0f 73              LA390	CLR	IKEYIM	RESET BREAK CHECK KEY TEMP KEY STORAGE
0359 e145 8e 00 f4           	LDX	#LINBUF+1	INPUT LINE BUFFER
0360 e148 c6 01              	LDB	#1	ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
0361                         *	BACKSPACE AS FIRST CHARACTER
0362 e14a bd e0 00           LA39A	JSR	LA171	GO GET A CHARACTER FROM CONSOLE IN
0363 e14d 81 08              	CMPA	#BS	BACKSPACE
0364 e14f 26 07              	BNE	LA3B4	NO
0365 e151 5a                 	DECB		YES - DECREMENT CHAR COUNTER
0366 e152 27 ef              	BEQ	LA390	BRANCH IF BACK AT START OF LINE AGAIN
0367 e154 30 1f              	LEAX	-1,X	DECREMENT BUFFER POINTER
0368 e156 20 34              	BRA	LA3E8	ECHO CHAR TO SCREEN
0369 e158 81 15              LA3B4	CMPA	#$15	SHIFT RIGHT ARROW?
0370 e15a 26 0a              	BNE	LA3C2	NO
0371                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
0372 e15c 5a                 LA3B8	DECB		DEC CHAR CTR
0373 e15d 27 e4              	BEQ	LA390	GO BACK TO START IF CHAR CTR = 0
0374 e15f 86 08              	LDA	#BS	BACKSPACE?
0375 e161 bd e0 14           	JSR	PUTCHR	SEND TO CONSOLE OUT (SCREEN)
0376 e164 20 f6              	BRA	LA3B8	KEEP GOING
0377 e166 81 03              LA3C2	CMPA	#3	BREAK KEY?
0378 e168 1a 01              	ORCC	#1	SET CARRY FLAG
0379 e16a 27 05              	BEQ	LA3CD	BRANCH IF BREAK KEY DOWN
0380 e16c 81 0d              LA3C8	CMPA	#CR	ENTER KEY?
0381 e16e 26 0d              	BNE	LA3D9	NO
0382 e170 4f                 LA3CC	CLRA		CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
0383 e171 34 01              LA3CD	PSHS	CC	SAVE CARRY FLAG
0384 e173 bd f0 a7           	JSR	LB958	SEND CR TO SCREEN
0385 e176 6f 84              	CLR	,X	MAKE LAST BYTE IN INPUT BUFFER = 0
0386 e178 8e 00 f3           	LDX	#LINBUF	RESET INPUT BUFFER POINTER
0387 e17b 35 81              	PULS	CC,PC	RESTORE CARRY FLAG
0388                         
0389                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
0390 e17d 81 20              LA3D9	CMPA	#$20	IS IT CONTROL CHAR?
0391 e17f 25 c9              	BLO	LA39A	BRANCH IF CONTROL CHARACTER
0392 e181 81 7b              	CMPA	#'z+1	*
0393 e183 24 c5              	BCC	LA39A	* IGNORE IF > LOWER CASE Z
0394 e185 c1 fa              	CMPB	#LBUFMX	HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
0395 e187 24 c1              	BCC	LA39A	YES, IGNORE ANY MORE
0396 e189 a7 80              	STA	,X+	PUT IT IN INPUT BUFFER
0397 e18b 5c                 	INCB		INCREMENT CHARACTER COUNTER
0398 e18c bd e0 14           LA3E8	JSR	PUTCHR	ECHO IT TO SCREEN
0399 e18f 20 b9              	BRA	LA39A	GO SET SOME MORE
0400                         
0401                         
0402                         * EXEC
0403 e191 27 05              EXEC	BEQ	LA545	BRANCH IF NO ARGUMENT
0404 e193 bd ee c6           	JSR	LB73D	EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
0405 e196 9f 7a              	STX	EXECJP	STORE X TO EXEC JUMP ADDRESS
0406 e198 6e 9f 00 7a        LA545	JMP	[EXECJP]	GO DO IT
0407                         
0408                         * BREAK CHECK
0409 e19c 7e e5 a8           LA549	JMP	LADEB	GO DO BREAK KEY CHECK
0410                         
0411                         * INKEY$
0412 e19f 96 73              INKEY	LDA	IKEYIM	WAS A KEY DOWN IN THE BREAK CHECK?
0413 e1a1 26 03              	BNE	LA56B	YES
0414 e1a3 bd e0 05           	JSR	KEYIN	GO GET A KEY
0415 e1a6 0f 73              LA56B	CLR	IKEYIM	CLEAR INKEY RAM IMAGE
0416 e1a8 97 53              	STA	FPA0+3	STORE THE KEY IN FPA0
0417 e1aa 10 26 0c 6a        	LBNE	LB68F	CONVERT FPA0+3 TO A STRING
0418 e1ae 97 56              	STA	STRDES	SET LENGTH OF STRING = 0 IF NO KEY DOWN
0419 e1b0 7e ee 24           	JMP	LB69B	PUT A NULL STRING ONTO THE STRING STACK
0420                         
0421                         * MOVE ACCB BYTES FROM (X) TO (U)
0422 e1b3 a6 80              LA59A	LDA	,X+	GET BYTE FROM X
0423 e1b5 a7 c0              	STA	,U+	STORE IT AT U
0424 e1b7 5a                 	DECB		MOVED ALL BYTES?
0425 e1b8 26 f9              	BNE	LA59A	NO
0426 e1ba 39                 LA5A1	RTS
0427                         
0428 e1bb 39                 LA5C4	RTS
0429                         
0430                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
0431                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
0432                         ** FOLLOWING THE END OF THE NAME
0433 e1bc 9d 82              LA5C7	JSR	GETCCH	GET CURRENT INPUT CHAR FROM BASIC LINE
0434 e1be 27 fb              LA5C9	BEQ	LA5C4	RETURN IF END OF LINE
0435 e1c0 7e ea 05           	JMP	LB277	SYNTAX ERROR IF ANY MORE CHARACTERS
0436                         * IRQ SERVICE
0437                         BIRQSV
0438 e1c3 3b                 LA9C5	RTI	RETURN FROM INTERRUPT
0439                         
0440                         * SET CARRY IF NUMERIC - RETURN WITH
0441                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
0442                         * OF BASIC LINE OR SUB LINE
0443 e1c4 81 3a              BROMHK	CMPA	#'9+1	IS THIS CHARACTER >=(ASCII 9)+1?
0444 e1c6 24 0a              	BHS	LAA28	BRANCH IF > 9; Z SET IF = COLON
0445 e1c8 81 20              	CMPA	#SPACE	SPACE?
0446 e1ca 26 02              	BNE	LAA24	NO - SET CARRY IF NUMERIC
0447 e1cc 0e 7c              	JMP	GETNCH	IF SPACE, GET NECT CHAR (IGNORE SPACES)
0448 e1ce 80 30              LAA24	SUBA	#'0	* SET CARRY IF
0449 e1d0 80 d0              	SUBA	#-'0	* CHARACTER > ASCII 0
0450 e1d2 39                 LAA28	RTS
0451                         
0452                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
0453                         * TOKENS ARE PRECEEDED BY $FF
0454                         * FIRST SET ALWAYS HAS ONE PARAMETER
0455                         FUNC_TAB
0456 e1d3 f3 c5              LAA29	FDB	SGN	SGN
0457 e1d5 f4 39              	FDB	INT	INT
0458 e1d7 f3 de              	FDB	ABS	ABS
0459 e1d9 00 ad              	FDB	USRJMP	USR
0460 0083                    TOK_USR	EQU	*-FUNC_TAB/2+$7F
0461 ff83                    TOK_FF_USR EQU	*-FUNC_TAB/2+$FF7F
0462 e1db f6 6a              	FDB	RND	RND
0463 e1dd f6 bf              	FDB	SIN	SIN
0464 e1df ee d9              	FDB	PEEK	PEEK
0465 e1e1 ee 0a              	FDB	LEN	LEN
0466 e1e3 ec 86              	FDB	STR	STR$
0467 e1e5 ee 9f              	FDB	VAL	VAL
0468 e1e7 ee 29              	FDB	ASC	ASC
0469 e1e9 ee 15              	FDB	CHR	CHR$
0470 e1eb f7 6f              	FDB	ATN	ATN
0471 e1ed f7 37              	FDB	COS	COS
0472 e1ef f7 40              	FDB	TAN	TAN
0473 e1f1 f8 b1              	FDB	EXP	EXP
0474 e1f3 f8 e3              	FDB	FIX	FIX
0475 e1f5 f8 05              	FDB	LOG	LOG
0476 e1f7 fa 6b              	FDB	POS	POS
0477 e1f9 f8 3f              	FDB	SQR	SQR
0478 e1fb ff 3d              	FDB	HEXDOL	HEX$
0479                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0480 e1fd ee 34              	FDB	LEFT	LEFT$
0481 0095                    TOK_LEFT	EQU	*-FUNC_TAB/2+$7F
0482 e1ff ee 51              	FDB	RIGHT	RIGHT$
0483 e201 ee 58              	FDB	MID	MID$
0484 0097                    TOK_MID	EQU	*-FUNC_TAB/2+$7F
0485                         * REMAINING FUNCTIONS
0486 e203 e1 9f              	FDB	INKEY	INKEY$
0487 0098                    TOK_INKEY EQU	*-FUNC_TAB/2+$7F
0488 e205 ec 77              	FDB	MEM	MEM
0489 e207 fa 73              	FDB	VARPT	VARPTR
0490 e209 fb 33              	FDB	INSTR	INSTR
0491 e20b fb 03              	FDB	STRING	STRING$
0492 001d                    NUM_SEC_FNS EQU	*-FUNC_TAB/2
0493                         
0494                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
0495                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
0496                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
0497                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
0498                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
0499                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
0500                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
0501                         *
0502 e20d 79                 LAA51	FCB	$79
0503 e20e f1 10              	FDB	LB9C5	+
0504 e210 79                 	FCB	$79
0505 e211 f1 07              	FDB	LB9BC	-
0506 e213 7b                 	FCB	$7B
0507 e214 f2 17              	FDB	LBACC	*
0508 e216 7b                 	FCB	$7B
0509 e217 f2 dc              	FDB	LBB91	/
0510 e219 7f                 	FCB	$7F
0511 e21a f8 48              	FDB	L8489	EXPONENTIATION
0512 e21c 50                 	FCB	$50
0513 e21d ea 5e              	FDB	LB2D5	AND
0514 e21f 46                 	FCB	$46
0515 e220 ea 5d              	FDB	LB2D4	OR
0516                         
0517                         * THIS IS THE RESERVED WORD TABLE
0518                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
0519 e222 46 4f              LAA66	FCC	"FO"	80
0520 e224 d2                 	FCB	$80+'R'
0521 e225 47                 	FCC	"G"	81
0522 e226 cf                 	FCB	$80+'O'
0523 0081                    TOK_GO	EQU	$81
0524 e227 52 45              	FCC	"RE"	82
0525 e229 cd                 	FCB	$80+'M'
0526 e22a a7                 	FCB	''+$80	83
0527 e22b 45 4c 53           	FCC	"ELS"	84
0528 e22e c5                 	FCB	$80+'E'
0529 e22f 49                 	FCC	"I"	85
0530 e230 c6                 	FCB	$80+'F'
0531 e231 44 41 54           	FCC	"DAT"	86
0532 e234 c1                 	FCB	$80+'A'
0533 e235 50 52 49 4e        	FCC	"PRIN"	87
0534 e239 d4                 	FCB	$80+'T'
0535 e23a 4f                 	FCC	"O"	88
0536 e23b ce                 	FCB	$80+'N'
0537 e23c 49 4e 50 55        	FCC	"INPU"	89
0538 e240 d4                 	FCB	$80+'T'
0539 e241 45 4e              	FCC	"EN"	8A
0540 e243 c4                 	FCB	$80+'D'
0541 e244 4e 45 58           	FCC	"NEX"	8B
0542 e247 d4                 	FCB	$80+'T'
0543 e248 44 49              	FCC	"DI"	8C
0544 e24a cd                 	FCB	$80+'M'
0545 e24b 52 45 41           	FCC	"REA"	8D
0546 e24e c4                 	FCB	$80+'D'
0547 e24f 52 55              	FCC	"RU"	8E
0548 e251 ce                 	FCB	$80+'N'
0549 e252 52 45 53 54 4f 52  	FCC	"RESTOR"	8F
0550 e258 c5                 	FCB	$80+'E'
0551 e259 52 45 54 55 52     	FCC	"RETUR"	90
0552 e25e ce                 	FCB	$80+'N'
0553 e25f 53 54 4f           	FCC	"STO"	91
0554 e262 d0                 	FCB	$80+'P'
0555 e263 50 4f 4b           	FCC	"POK"	92
0556 e266 c5                 	FCB	$80+'E'
0557 e267 43 4f 4e           	FCC	"CON"	93
0558 e26a d4                 	FCB	$80+'T'
0559 e26b 4c 49 53           	FCC	"LIS"	94
0560 e26e d4                 	FCB	$80+'T'
0561 e26f 43 4c 45 41        	FCC	"CLEA"	95
0562 e273 d2                 	FCB	$80+'R'
0563 e274 4e 45              	FCC	"NE"	96
0564 e276 d7                 	FCB	$80+'W'
0565 e277 45 58 45           	FCC	"EXE"	97
0566 e27a c3                 	FCB	$80+'C'
0567 e27b 54 52 4f           	FCC	"TRO"	98
0568 e27e ce                 	FCB	$80+'N'
0569 e27f 54 52 4f 46        	FCC	"TROF"	99
0570 e283 c6                 	FCB	$80+'F'
0571 e284 44 45              	FCC	"DE"	9A
0572 e286 cc                 	FCB	$80+'L'
0573 e287 44 45              	FCC	"DE"	9B
0574 e289 c6                 	FCB	$80+'F'
0575 e28a 4c 49 4e           	FCC	"LIN"	9C
0576 e28d c5                 	FCB	$80+'E'
0577 e28e 52 45 4e 55        	FCC	"RENU"	9D
0578 e292 cd                 	FCB	$80+'M'
0579 e293 45 44 49           	FCC	"EDI"	9E
0580 e296 d4                 	FCB	$80+'T'
0581                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
0582 e297 54 41 42           	FCC	"TAB"	9F
0583 e29a a8                 	FCB	$80+'('
0584 009f                    TOK_TAB	EQU	$9F
0585 e29b 54                 	FCC	"T"	A0
0586 e29c cf                 	FCB	$80+'O'
0587 00a0                    TOK_TO	EQU	$A0
0588 e29d 53 55              	FCC	"SU"	A1
0589 e29f c2                 	FCB	$80+'B'
0590 00a1                    TOK_SUB	EQU	$A1
0591 e2a0 54 48 45           	FCC	"THE"	A2
0592 e2a3 ce                 	FCB	$80+'N'
0593 00a2                    TOK_THEN	EQU	$A2
0594 e2a4 4e 4f              	FCC	"NO"	A3
0595 e2a6 d4                 	FCB	$80+'T'
0596 00a3                    TOK_NOT	EQU	$A3
0597 e2a7 53 54 45           	FCC	"STE"	A4
0598 e2aa d0                 	FCB	$80+'P'
0599 00a4                    TOK_STEP	EQU	$A4
0600 e2ab 4f 46              	FCC	"OF"	A5
0601 e2ad c6                 	FCB	$80+'F'
0602 e2ae ab                 	FCB	'++$80	A6
0603 00a6                    TOK_PLUS	EQU	$A6
0604 e2af ad                 	FCB	'-+$80	A7
0605 00a7                    TOK_MINUS EQU	$A7
0606 e2b0 aa                 	FCB	'*+$80	A8
0607 e2b1 af                 	FCB	'/+$80	A9
0608 e2b2 de                 	FCB	'^+$80	AA
0609 e2b3 41 4e              	FCC	"AN"	AB
0610 e2b5 c4                 	FCB	$80+'D'
0611 e2b6 4f                 	FCC	"O"	AC
0612 e2b7 d2                 	FCB	$80+'R'
0613 e2b8 be                 	FCB	'>+$80	AD
0614 00ad                    TOK_GREATER EQU	$AD
0615 e2b9 bd                 	FCB	'=+$80	AE
0616 00ae                    TOK_EQUALS EQU	$AE
0617 e2ba bc                 	FCB	'<+$80	AF
0618 e2bb 46                 	FCC	"F"	B0
0619 e2bc ce                 	FCB	$80+'N'
0620 00b0                    TOK_FN	EQU	$B0
0621 e2bd 55 53 49 4e        	FCC	"USIN"	B1
0622 e2c1 c7                 	FCB	$80+'G'
0623                         *
0624                         
0625                         * FIRST SET ALWAYS HAS ONE PARAMETER
0626 e2c2 53 47              LAB1A	FCC	"SG"	80
0627 e2c4 ce                 	FCB	$80+'N'
0628 e2c5 49 4e              	FCC	"IN"	81
0629 e2c7 d4                 	FCB	$80+'T'
0630 e2c8 41 42              	FCC	"AB"	82
0631 e2ca d3                 	FCB	$80+'S'
0632 e2cb 55 53              	FCC	"US"	83
0633 e2cd d2                 	FCB	$80+'R'
0634 e2ce 52 4e              	FCC	"RN"	84
0635 e2d0 c4                 	FCB	$80+'D'
0636 e2d1 53 49              	FCC	"SI"	85
0637 e2d3 ce                 	FCB	$80+'N'
0638 e2d4 50 45 45           	FCC	"PEE"	86
0639 e2d7 cb                 	FCB	$80+'K'
0640 e2d8 4c 45              	FCC	"LE"	87
0641 e2da ce                 	FCB	$80+'N'
0642 e2db 53 54 52           	FCC	"STR"	88
0643 e2de a4                 	FCB	$80+'$'
0644 e2df 56 41              	FCC	"VA"	89
0645 e2e1 cc                 	FCB	$80+'L'
0646 e2e2 41 53              	FCC	"AS"	8A
0647 e2e4 c3                 	FCB	$80+'C'
0648 e2e5 43 48 52           	FCC	"CHR"	8B
0649 e2e8 a4                 	FCB	$80+'$'
0650 e2e9 41 54              	FCC	"AT"	8C
0651 e2eb ce                 	FCB	$80+'N'
0652 e2ec 43 4f              	FCC	"CO"	8D
0653 e2ee d3                 	FCB	$80+'S'
0654 e2ef 54 41              	FCC	"TA"	8E
0655 e2f1 ce                 	FCB	$80+'N'
0656 e2f2 45 58              	FCC	"EX"	8F
0657 e2f4 d0                 	FCB	$80+'P'
0658 e2f5 46 49              	FCC	"FI"	90
0659 e2f7 d8                 	FCB	$80+'X'
0660 e2f8 4c 4f              	FCC	"LO"	91
0661 e2fa c7                 	FCB	$80+'G'
0662 e2fb 50 4f              	FCC	"PO"	92
0663 e2fd d3                 	FCB	$80+'S'
0664 e2fe 53 51              	FCC	"SQ"	93
0665 e300 d2                 	FCB	$80+'R'
0666 e301 48 45 58           	FCC	"HEX"	94
0667 e304 a4                 	FCB	$80+'$'
0668                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0669 e305 4c 45 46 54        	FCC	"LEFT"	95
0670 e309 a4                 	FCB	$80+'$'
0671 e30a 52 49 47 48 54     	FCC	"RIGHT"	96
0672 e30f a4                 	FCB	$80+'$'
0673 e310 4d 49 44           	FCC	"MID"	97
0674 e313 a4                 	FCB	$80+'$'
0675                         * REMAINING FUNCTIONS
0676 e314 49 4e 4b 45 59     	FCC	"INKEY"	98
0677 e319 a4                 	FCB	$80+'$'
0678 e31a 4d 45              	FCC	"ME"	99
0679 e31c cd                 	FCB	$80+'M'
0680 e31d 56 41 52 50 54     	FCC	"VARPT"	9A
0681 e322 d2                 	FCB	$80+'R'
0682 e323 49 4e 53 54        	FCC	"INST"	9B
0683 e327 d2                 	FCB	$80+'R'
0684 e328 53 54 52 49 4e 47  	FCC	"STRING"	9C
0685 e32e a4                 	FCB	$80+'$'
0686                         
0687                         *
0688                         * DISPATCH TABLE FOR COMMANDS TOKEN #
0689                         CMD_TAB
0690 e32f e4 ed              LAB67	FDB	FOR	80
0691 e331 e6 38              	FDB	GO	81
0692 e333 e6 95              	FDB	REM	82
0693 0082                    TOK_REM	EQU	*-CMD_TAB/2+$7F
0694 e335 e6 95              	FDB	REM	83 (')
0695 0083                    TOK_SNGL_Q EQU	*-CMD_TAB/2+$7F
0696 e337 e6 95              	FDB	REM	84 (ELSE)
0697 0084                    TOK_ELSE	EQU	*-CMD_TAB/2+$7F
0698 e339 e6 c6              	FDB	IF	85
0699 0085                    TOK_IF	EQU	*-CMD_TAB/2+$7F
0700 e33b e6 92              	FDB	DATA	86
0701 0086                    TOK_DATA	EQU	*-CMD_TAB/2+$7F
0702 e33d f0 6f              	FDB	PRINT	87
0703 0087                    TOK_PRINT EQU	*-CMD_TAB/2+$7F
0704 e33f e6 f4              	FDB	ON	88
0705 e341 e7 a1              	FDB	INPUT	89
0706 0089                    TOK_INPUT EQU	*-CMD_TAB/2+$7F
0707 e343 e5 bf              	FDB	END	8A
0708 e345 e8 86              	FDB	NEXT	8B
0709 e347 ea d7              	FDB	DIM	8C
0710 e349 e7 db              	FDB	READ	8D
0711 e34b e6 2d              	FDB	RUN	8E
0712 e34d e5 a1              	FDB	RESTOR	8F
0713 e34f e6 72              	FDB	RETURN	90
0714 e351 e5 c3              	FDB	STOP	91
0715 e353 ee e0              	FDB	POKE	92
0716 e355 e5 e8              	FDB	CONT	93
0717 e357 ee e7              	FDB	LIST	94
0718 e359 e5 f9              	FDB	CLEAR	95
0719 e35b e4 bd              	FDB	NEW	96
0720 e35d e1 91              	FDB	EXEC	97
0721 e35f fa 66              	FDB	TRON	98
0722 e361 fa 67              	FDB	TROFF	99
0723 e363 fc e2              	FDB	DEL	9A
0724 e365 fc 26              	FDB	DEF	9B
0725 e367 ff 81              	FDB	LINE	9C
0726 e369 fd 6c              	FDB	RENUM	9D
0727 e36b f8 f2              	FDB	EDIT	9E
0728 009e                    TOK_HIGH_EXEC EQU	*-CMD_TAB/2+$7F
0729                         
0730                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
0731 e36d 4e 46              LABAF	FCC	"NF"	0 NEXT WITHOUT FOR
0732 e36f 53 4e              	FCC	"SN"	1 SYNTAX ERROR
0733 e371 52 47              	FCC	"RG"	2 RETURN WITHOUT GOSUB
0734 e373 4f 44              	FCC	"OD"	3 OUT OF DATA
0735 e375 46 43              	FCC	"FC"	4 ILLEGAL FUNCTION CALL
0736 e377 4f 56              	FCC	"OV"	5 OVERFLOW
0737 e379 4f 4d              	FCC	"OM"	6 OUT OF MEMORY
0738 e37b 55 4c              	FCC	"UL"	7 UNDEFINED LINE NUMBER
0739 e37d 42 53              	FCC	"BS"	8 BAD SUBSCRIPT
0740 e37f 44 44              	FCC	"DD"	9 REDIMENSIONED ARRAY
0741 e381 2f 30              	FCC	"/0"	10 DIVISION BY ZERO
0742 e383 49 44              	FCC	"ID"	11 ILLEGAL DIRECT STATEMENT
0743 e385 54 4d              	FCC	"TM"	12 TYPE MISMATCH
0744 e387 4f 53              	FCC	"OS"	13 OUT OF STRING SPACE
0745 e389 4c 53              	FCC	"LS"	14 STRING TOO LONG
0746 e38b 53 54              	FCC	"ST"	15 STRING FORMULA TOO COMPLEX
0747 e38d 43 4e              	FCC	"CN"	16 CAN'T CONTINUE
0748 e38f 46 44              	FCC	"FD"	17 BAD FILE DATA
0749 e391 41 4f              	FCC	"AO"	18 FILE ALREADY OPEN
0750 e393 44 4e              	FCC	"DN"	19 DEVICE NUMBER ERROR
0751 e395 49 4f              	FCC	"IO"	20 I/O ERROR
0752 e397 46 4d              	FCC	"FM"	21 BAD FILE MODE
0753 e399 4e 4f              	FCC	"NO"	22 FILE NOT OPEN
0754 e39b 49 45              	FCC	"IE"	23 INPUT PAST END OF FILE
0755 e39d 44 53              	FCC	"DS"	24 DIRECT STATEMENT IN FILE
0756                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
0757 e39f 55 46              L890B	FCC	"UF"	25 UNDEFINED FUNCTION (FN) CALL
0758 e3a1 4e 45              L890D	FCC	"NE"	26 FILE NOT FOUND
0759                         
0760 e3a3 20 45 52 52 4f 52  LABE1	FCC	" ERROR"
0761 e3a9 00                 	FCB	$00
0762 e3aa 20 49 4e 20        LABE8	FCC	" IN "
0763 e3ae 00                 	FCB	$00
0764 e3af 0d                 LABED	FCB	CR
0765 e3b0 4f 4b              LABEE	FCC	"OK"
0766 e3b2 0d 00              	FCB	CR,$00
0767 e3b4 0d                 LABF2	FCB	CR
0768 e3b5 42 52 45 41 4b     	FCC	"BREAK"
0769 e3ba 00                 	FCB	$00
0770                         
0771                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
0772                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
0773                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
0774                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
0775                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
0776                         * IS CONSIDERED 'GOSUB/RETURN'
0777 e3bb 30 64              LABF9	LEAX	4,S	POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
0778                         *	FIRST TWO RETURN ADDRESSES ON THE STACK
0779 e3bd c6 12              LABFB	LDB	#18	18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
0780 e3bf 9f 0f              	STX	TEMPTR	SAVE POINTER
0781 e3c1 a6 84              	LDA	,X	GET 1ST BYTE
0782 e3c3 80 80              	SUBA	#$80	* CHECK FOR TYPE OF STACK JUMP FOUND
0783 e3c5 26 15              	BNE	LAC1A	* BRANCH IF NOT 'FOR/NEXT'
0784 e3c7 ae 01              	LDX	1,X	= GET INDEX VARIABLE DESCRIPTOR
0785 e3c9 9f 11              	STX	TMPTR1	= POINTER AND SAVE IT IN TMPTR1
0786 e3cb 9e 3b              	LDX	VARDES	GET INDEX VARIABLE BEING SEARCHED FOR
0787 e3cd 27 09              	BEQ	LAC16	BRANCH IF DEFAULT INDEX VARIABLE - USE THE
0788                         *			FIRST 'FOR/NEXT' DATA FOUND ON STACK
0789                         *			IF NO INDEX VARIABLE AFTER 'NEXT'
0790 e3cf 9c 11              	CMPX	TMPTR1	DOES THE STACK INDEX MATCH THE ONE
0791                         *			BEING SEARCHED FOR?
0792 e3d1 27 09              	BEQ	LAC1A	YES
0793 e3d3 9e 0f              	LDX	TEMPTR	* RESTORE INITIAL POINTER, ADD
0794 e3d5 3a                 	ABX		* 18 TO IT AND LOOK FOR
0795 e3d6 20 e5              	BRA	LABFB	* NEXT BLOCK OF DATA
0796 e3d8 9e 11              LAC16	LDX	TMPTR1	= GET 1ST INDEX VARIABLE FOUND AND
0797 e3da 9f 3b              	STX	VARDES	= SAVE AS 'NEXT' INDEX
0798 e3dc 9e 0f              LAC1A	LDX	TEMPTR	POINT X TO START OF 'FOR/NEXT' DATA
0799 e3de 4d                 	TSTA		SET ZERO FLAG IF 'FOR/NEXT' DATA
0800 e3df 39                 	RTS
0801                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
0802                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
0803 e3e0 8d 17              LAC1E	BSR	LAC37	ACCD = NEW BOTTOM OF FREE RAM - IS THERE
0804                         *			ROOM FOR THE STACK?
0805                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
0806                         * SAVE FINAL VALUE OF U IN V45
0807 e3e2 de 41              LAC20	LDU	V41	POINT U TO DESTINATION ADDRESS (V41)
0808 e3e4 33 41              	LEAU	1,U	ADD ONE TO U - COMPENSATE FOR FIRST PSHU
0809 e3e6 9e 43              	LDX	V43	POINT X TO SOURCE ADDRESS (V43)
0810 e3e8 30 01              	LEAX	1,X	ADD ONE - COMPENSATE FOR FIRST LDA ,X
0811 e3ea a6 82              LAC28	LDA	,-X	GRAB A BYTE FROM SOURCE
0812 e3ec 36 02              	PSHU	A	MOVE IT TO DESTINATION
0813 e3ee 9c 47              	CMPX	V47	DONE?
0814 e3f0 26 f8              	BNE	LAC28	NO - KEEP MOVING BYTES
0815 e3f2 df 45              	STU	V45	SAVE FINAL DESTINATION ADDRESS
0816 e3f4 39                 LAC32	RTS
0817                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
0818                         * BYTES IN FREE RAM - OM ERROR IF NOT
0819 e3f5 4f                 LAC33	CLRA		* ACCD CONTAINS NUMBER OF EXTRA
0820 e3f6 58                 	ASLB		* BYTES TO PUT ON STACK
0821 e3f7 d3 1f              	ADDD	ARYEND	END OF PROGRAM AND VARIABLES
0822 e3f9 c3 00 3a           LAC37	ADDD	#STKBUF	ADD STACK BUFFER - ROOM FOR STACK?
0823 e3fc 25 08              	BCS	LAC44	BRANCH IF GREATER THAN $FFFF
0824 e3fe 10 df 17           	STS	BOTSTK	CURRENT NEW BOTTOM OF STACK STACK POINTER
0825 e401 10 93 17           	CMPD	BOTSTK	ARE WE GOING TO BE BELOW STACK?
0826 e404 25 ee              	BCS	LAC32	YES - NO ERROR
0827 e406 c6 0c              LAC44	LDB	#6*2	OUT OF MEMORY ERROR
0828                         
0829                         * ERROR SERVICING ROUTINE
0830 e408 bd e4 d9           LAC46	JSR	LAD33	RESET STACK, STRING STACK, CONTINUE POINTER
0831 e40b bd f0 ab           	JSR	LB95C	SEND A CR TO SCREEN
0832 e40e bd f0 fa           	JSR	LB9AF	SEND A �?� TO SCREEN
0833 e411 8e e3 6d           	LDX	#LABAF	POINT TO ERROR TABLE
0834 e414 3a                 LAC60	ABX		ADD MESSAGE NUMBER OFFSET
0835 e415 8d 31              	BSR	LACA0	* GET TWO CHARACTERS FROM X AND
0836 e417 8d 2f              	BSR	LACA0	* SEND TO CONSOLE OUT (SCREEN)
0837 e419 8e e3 a2           	LDX	#LABE1-1	POINT TO "ERROR" MESSAGE
0838 e41c bd f0 e7           LAC68	JSR	LB99C	PRINT MESSAGE POINTED TO BY X
0839 e41f 96 68              	LDA	CURLIN	GET CURRENT LINE NUMBER (CURL IN)
0840 e421 4c                 	INCA		TEST FOR DIRECT MODE
0841 e422 27 03              	BEQ	LAC73	BRANCH IF DIRECT MODE
0842 e424 bd f5 10           	JSR	LBDC5	PRINT 'IN ****'
0843                         
0844                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
0845 e427 bd f0 ab           LAC73	JSR	LB95C	MOVE CURSOR TO START OF LINE
0846 e42a 8e e3 af           	LDX	#LABED	POINT X TO 'OK' CR MESSAGE
0847 e42d bd f0 e7           	JSR	LB99C	PRINT 'OK' CR
0848 e430 bd e1 43           LAC7C	JSR	LA390	GO GET AN INPUT LINE
0849 e433 ce ff ff           	LDU	#$FFFF	THE LINE NUMBER FOR DIRECT MODE IS $FFFF
0850 e436 df 68              	STU	CURLIN	SAVE IT IN CURLIN
0851 e438 25 f6              	BCS	LAC7C	BRANCH IF LINE INPUT TERMINATED BY BREAK
0852 e43a 9f 83              	STX	CHARAD	SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
0853                         *	ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
0854                         *	LINE JUST ENTERED WILL BE INTERPRETED
0855 e43c 9d 7c              	JSR	GETNCH	GET NEXT CHARACTER FROM BASIC
0856 e43e 27 f0              	BEQ	LAC7C	NO LINE INPUT - GET ANOTHER LINE
0857 e440 25 0b              	BCS	LACA5	BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
0858                         *	THE STATEMENT ENTERED, SO THIS STATEMENT
0859                         *	WILL BE MERGED INTO THE BASIC PROGRAM
0860 e442 bd ef 9c           	JSR	LB821	GO CRUNCH LINE
0861 e445 7e e5 76           	JMP	LADC0	GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
0862                         *
0863 e448 a6 80              LACA0	LDA	,X+	GET A CHARACTER
0864 e44a 7e f0 fc           	JMP	LB9B1	SEND TO CONSOLE OUT
0865                         * TAKE A LINE FROM THE LINE INPUT BUFFER
0866                         * AND INSERT IT INTO THE BASIC PROGRAM
0867 e44d bd e7 19           LACA5	JSR	LAF67	CONVERT LINE NUMBER TO BINARY
0868 e450 9e 2b              LACA8	LDX	BINVAL	GET CONVERTED LINE NUMBER
0869 e452 9f f1              	STX	LINHDR	STORE IT IN LINE INPUT HEADER
0870 e454 bd ef 9c           	JSR	LB821	GO CRUNCH THE LINE
0871 e457 d7 03              	STB	TMPLOC	SAVE LINE LENGTH
0872 e459 8d 4c              	BSR	LAD01	FIND OUT WHERE TO INSERT LINE
0873 e45b 25 12              	BCS	LACC8	BRANCH IF LINE NUMBER DOES NOT ALREADY EXIST
0874 e45d dc 47              	LDD	V47	GET ABSOLUTE ADDRESS OF LINE NUMBER
0875 e45f a3 84              	SUBD	,X	SUBTRACT ADDRESS OF NEXT LINE NUMBER
0876 e461 d3 1b              	ADDD	VARTAB	* ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
0877 e463 dd 1b              	STD	VARTAB	* THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
0878 e465 ee 84              	LDU	,X	POINT U TO ADDRESS OF NEXT LINE NUMBER
0879                         * DELETE OLD LINE FROM BASIC PROGRAM
0880 e467 37 02              LACC0	PULU A	GET A BYTE FROM WHAT�S LEFT OF PROGRAM
0881 e469 a7 80              	STA	,X+	MOVE IT DOWN
0882 e46b 9c 1b              	CMPX	VARTAB	COMPARE TO END OF BASIC PROGRAM
0883 e46d 26 f8              	BNE	LACC0	BRANCH IF NOT AT END
0884 e46f 96 f3              LACC8	LDA	LINBUF	* CHECK TO SEE IF THERE IS A LINE IN
0885 e471 27 1c              	BEQ	LACE9	* THE BUFFER AND BRANCH IF NONE
0886 e473 dc 1b              	LDD	VARTAB	= SAVE CURRENT END OF
0887 e475 dd 43              	STD	V43	= PROGRAM IN V43
0888 e477 db 03              	ADDB	TMPLOC	* ADD LENGTH OF CRUNCHED LINE,
0889 e479 89 00              	ADCA	#0	* PROPOGATE CARRY AND SAVE NEW END
0890 e47b dd 41              	STD	V41	* OF PROGRAM IN V41
0891 e47d bd e3 e0           	JSR	LAC1E	= MAKE SURE THERE�S ENOUGH RAM FOR THIS
0892                         *	=	LINE & MAKE A HOLE IN BASIC FOR NEW LINE
0893 e480 ce 00 ef           	LDU	#LINHDR-2	POINT U TO LINE TO BE INSERTED
0894 e483 37 02              LACDD	PULU	A	GET A BYTE FROM NEW LINE
0895 e485 a7 80              	STA	,X+	INSERT IT IN PROGRAM
0896 e487 9c 45              	CMPX	V45	* COMPARE TO ADDRESS OF END OF INSERTED
0897 e489 26 f8              	BNE	LACDD	* LINE AND BRANCH IF NOT DONE
0898 e48b 9e 41              	LDX	V41	= GET AND SAVE
0899 e48d 9f 1b              	STX	VARTAB	= END OF PROGRAM
0900 e48f 8d 36              LACE9	BSR	LAD21	RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
0901 e491 8d 02              	BSR	LACEF	ADJUST START OF NEXT LINE ADDRESSES
0902 e493 20 9b              	BRA	LAC7C	REENTER BASIC�S INPUT LOOP
0903                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
0904 e495 9e 19              LACEF	LDX	TXTTAB	POINT X TO START OF PROGRAM
0905 e497 ec 84              LACF1	LDD	,X	GET ADDRESS OF NEXT LINE
0906 e499 27 21              	BEQ	LAD16	RETURN IF END OF PROGRAM
0907 e49b 33 04              	LEAU	4,X	POINT U TO START OF BASIC TEXT IN LINE
0908 e49d a6 c0              LACF7	LDA	,U+	* SKIP THROUGH THE LINE UNTIL A
0909 e49f 26 fc              	BNE	LACF7	* ZERO (END OF LINE) IS FOUND
0910 e4a1 ef 84              	STU	,X	SAVE THE NEW START OF NEXT LINE ADDRESS
0911 e4a3 ae 84              	LDX	,X	POINT X TO START OF NEXT LINE
0912 e4a5 20 f0              	BRA	LACF1	KEEP GOING
0913                         *
0914                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
0915                         * RETURN WITH CARRY SET IF NO MATCH FOUND
0916 e4a7 dc 2b              LAD01	LDD	BINVAL	GET THE LINE NUMBER TO FIND
0917 e4a9 9e 19              	LDX	TXTTAB	BEGINNING OF PROGRAM
0918 e4ab ee 84              LAD05	LDU	,X	GET ADDRESS OF NEXT LINE NUMBER
0919 e4ad 27 09              	BEQ	LAD12	BRANCH IF END OF PROG
0920 e4af 10 a3 02           	CMPD	2,X	IS IT A MATCH?
0921 e4b2 23 06              	BLS	LAD14	CARRY SET IF LOWER; CARRY CLEAR IF MATCH
0922 e4b4 ae 84              	LDX	,X	X = ADDRESS OF NEXT LINE
0923 e4b6 20 f3              	BRA	LAD05	KEEP LOOPING FOR LINE NUMBER
0924 e4b8 1a 01              LAD12	ORCC	#1	SET CARRY FLAG
0925 e4ba 9f 47              LAD14	STX	V47	SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
0926                         *		 WHERE IT SHOULD HAVE BEEN
0927 e4bc 39                 LAD16	RTS
0928                         
0929                         * NEW
0930 e4bd 26 fb              NEW	BNE	LAD14	BRANCH IF ARGUMENT GIVEN
0931 e4bf 9e 19              LAD19	LDX	TXTTAB	GET START OF BASIC
0932 e4c1 6f 80              	CLR	,X+	* PUT 2 ZERO BYTES THERE - ERASE
0933 e4c3 6f 80              	CLR	,X+	* THE BASIC PROGRAM
0934 e4c5 9f 1b              	STX	VARTAB	AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
0935 e4c7 9e 19              LAD21	LDX	TXTTAB	GET START OF BASIC
0936 e4c9 bd e6 6d           	JSR	LAEBB	PUT INPUT POINTER ONE BEFORE START OF BASIC
0937                         * ERASE ALL VARIABLES
0938 e4cc 9e 27              LAD26	LDX	MEMSIZ	* RESET START OF STRING VARIABLES
0939 e4ce 9f 23              	STX	STRTAB	* TO TOP OF STRING SPACE
0940 e4d0 bd e5 a1           	JSR	RESTOR	RESET �DATA� POINTER TO START OF BASIC
0941 e4d3 9e 1b              	LDX	VARTAB	* GET START OF VARIABLES AND USE IT
0942 e4d5 9f 1d              	STX	ARYTAB	* TO RESET START OF ARRAYS
0943 e4d7 9f 1f              	STX	ARYEND	RESET END OF ARRAYS
0944 e4d9 8e 00 c9           LAD33	LDX	#STRSTK	* RESET STRING STACK POINTER TO
0945 e4dc 9f 0b              	STX	TEMPPT	* BOTTOM OF STRING STACK
0946 e4de ae e4              	LDX	,S	GET RETURN ADDRESS OFF STACK
0947 e4e0 10 de 21           	LDS	FRETOP	RESTORE STACK POINTER
0948 e4e3 6f e2              	CLR	,-S	PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
0949                         *			FOR/NEXT DATA FROM THE STACK
0950 e4e5 0f 2d              	CLR	OLDPTR	RESET 'CONT' ADDRESS SO YOU
0951 e4e7 0f 2e              	CLR	OLDPTR+1	'CAN NOT CONTINUE'
0952 e4e9 0f 08              	CLR	ARYDIS	CLEAR THE ARRAY DISABLE FLAG
0953 e4eb 6e 84              	JMP	,X	RETURN TO CALLING ROUTINE - THIS IS NECESSARY
0954                         *		 SINCE THE STACK WAS RESET
0955                         *
0956                         * FOR
0957                         *
0958                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
0959                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
0960                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
0961                         * 1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
0962                         * 8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
0963                         * 9-13=FP VALUE OF 'TO' PARAMETER;
0964                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
0965                         * OF THE LINE CONTAINING THE 'FOR' STATEMENT
0966 e4ed 86 80              FOR	LDA	#$80	* SAVE THE DISABLE ARRAY FLAG IN VO8
0967 e4ef 97 08              	STA	ARYDIS	* DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
0968 e4f1 bd e7 3b           	JSR	LET	SET INDEX VARIABLE TO INITIAL VALUE
0969 e4f4 bd e3 bb           	JSR	LABF9	SEARCH THE STACK FOR �FOR/NEXT� DATA
0970 e4f7 32 62              	LEAS	2,S	PURGE RETURN ADDRESS OFF OF THE STACK
0971 e4f9 26 04              	BNE	LAD59	BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
0972 e4fb 9e 0f              	LDX	TEMPTR	GET (ADDRESS + 18) OF MATCHED �FOR/NEXT� DATA
0973 e4fd 32 85              	LEAS	B,X	MOVE THE STACK POINTER TO THE BEGINNING OF THE
0974                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
0975                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
0976                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
0977                         * THIS POINT ON THE STACK
0978 e4ff c6 09              LAD59	LDB	#$09	* CHECK FOR ROOM FOR 18 BYTES
0979 e501 bd e3 f5           	JSR	LAC33	* IN FREE RAM
0980 e504 bd e6 9a           	JSR	LAEE8	GET ADDR OF END OF SUBLINE IN X
0981 e507 dc 68              	LDD	CURLIN	GET CURRENT LINE NUMBER
0982 e509 34 16              	PSHS	X,B,A	SAVE LINE ADDR AND LINE NUMBER ON STACK
0983 e50b c6 a0              	LDB	#TOK_TO	TOKEN FOR 'TO'
0984 e50d bd e9 fd           	JSR	LB26F	SYNTAX CHECK FOR 'TO'
0985 e510 bd e8 d1           	JSR	LB143	'TM' ERROR IF INDEX VARIABLE SET TO STRING
0986 e513 bd e8 cf           	JSR	LB141	EVALUATE EXPRESSION
0987                         *
0988 e516 d6 54              	LDB	FP0SGN	GET FPA0 MANTISSA SIGN
0989 e518 ca 7f              	ORB	#$7F	FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
0990 e51a d4 50              	ANDB	FPA0	PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
0991 e51c d7 50              	STB	FPA0	SAVE THE PACKED HIGH ORDER MANTISSA
0992 e51e 10 8e e5 25        	LDY	#LAD7F	LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
0993 e522 7e e9 78           	JMP	LB1EA	ADDRESS - PUSH FPA0 ONTO THE STACK
0994 e525 8e f2 10           LAD7F	LDX	#LBAC5	POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
0995 e528 bd f3 5f           	JSR	LBC14	MOVE (X) TO FPA0
0996 e52b 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
0997 e52d 81 a4              	CMPA	#TOK_STEP	STEP TOKEN
0998 e52f 26 05              	BNE	LAD90	BRANCH IF NO 'STEP' VALUE
0999 e531 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
1000 e533 bd e8 cf           	JSR	LB141	EVALUATE NUMERIC EXPRESSION
1001 e536 bd f3 b8           LAD90	JSR	LBC6D	CHECK STATUS OF FPA0
1002 e539 bd e9 74           	JSR	LB1E6	SAVE STATUS AND FPA0 ON THE STACK
1003 e53c dc 3b              	LDD	VARDES	* GET DESCRIPTOR POINTER FOR THE 'STEP'
1004 e53e 34 06              	PSHS	B,A	* VARIABLE AND SAVE IT ON THE STACK
1005 e540 86 80              	LDA	#$80	= GET THE 'FOR' FLAG AND
1006 e542 34 02              	PSHS	A	= SAVE IT ON THE STACK
1007                         *
1008                         * MAIN COMMAND INTERPRETATION LOOP
1009 e544 1c af              LAD9E	ANDCC	#$AF	ENABLE IRQ,FIRQ
1010 e546 8d 60              	BSR	LADEB	CHECK FOR KEYBOARD BREAK
1011 e548 9e 83              	LDX	CHARAD	GET BASIC'S INPUT POINTER
1012 e54a 9f 2f              	STX	TINPTR	SAVE IT
1013 e54c a6 80              	LDA	,X+	GET CURRENT INPUT CHAR & MOVE POINTER
1014 e54e 27 07              	BEQ	LADB4	BRANCH IF END OF LINE
1015 e550 81 3a              	CMPA	#':	CHECK FOR LINE SEPARATOR
1016 e552 27 22              	BEQ	LADC0	BRANCH IF COLON
1017 e554 7e ea 05           LADB1	JMP	LB277	'SYNTAX ERROR' IF NOT LINE SEPARATOR
1018 e557 a6 81              LADB4	LDA	,X++	GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
1019 e559 97 00              	STA	ENDFLG	SAVE IN STOP/END FLAG - CAUSE A STOP IF
1020                         *		 NEXT LINE ADDRESS IS < $8000; CAUSE
1021                         *		 AN END IF ADDRESS > $8000
1022 e55b 27 72              	BEQ	LAE15	BRANCH TO 'STOP' - END OF PROGRAM
1023 e55d ec 80              	LDD	,X+	GET CURRENT LINE NUMBER
1024 e55f dd 68              	STD	CURLIN	SAVE IN CURLIN
1025 e561 9f 83              	STX	CHARAD	SAVE ADDRESS OF FIRST BYTE OF LINE
1026                         * EXTENDED BASIC TRACE
1027 e563 96 8c              	LDA	TRCFLG	TEST THE TRACE FLAG
1028 e565 27 0f              	BEQ	LADC0	BRANCH IF TRACE OFF
1029 e567 86 5b              	LDA	#$5B	<LEFT HAND MARKER FOR TRON LINE NUMBER
1030 e569 bd e0 14           	JSR	PUTCHR	OUTPUT A CHARACTER
1031 e56c 96 68              	LDA	CURLIN	GET MS BYTE OF LINE NUMBER
1032 e56e bd f5 17           	JSR	LBDCC	CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
1033 e571 86 5d              	LDA	#$5D	> RIGHT HAND MARKER FOR TRON LINE NUMBER
1034 e573 bd e0 14           	JSR	PUTCHR	OUTPUT A CHARACTER
1035                         * END OF EXTENDED BASIC TRACE
1036 e576 9d 7c              LADC0	JSR	GETNCH	GET A CHARACTER FROM BASIC
1037 e578 8d 02              	BSR	LADC6	GO PROCESS COMMAND
1038 e57a 20 c8              	BRA	LAD9E	GO BACK TO MAIN LOOP
1039 e57c 27 29              LADC6	BEQ	LADEA	RETURN IF END OF LINE (RTS - was BEQ LAE40)
1040 e57e 4d                 	TSTA		CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
1041 e57f 10 2a 01 b8        	LBPL	LET	BRANCH IF NOT A TOKEN - GO DO A �LET� WHICH
1042                         *		 IS THE �DEFAULT� TOKEN FOR MICROSOFT BASIC
1043 e583 81 ff              	CMPA	#$FF	SECONDARY TOKEN
1044 e585 27 0f              	BEQ	SECTOK
1045 e587 81 9e              	CMPA	#TOK_HIGH_EXEC	SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
1046 e589 22 c9              	BHI	LADB1	'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
1047 e58b be e0 f6           	LDX	COMVEC+3	GET ADDRESS OF BASIC'S COMMAND TABLE
1048 e58e 48                 LADD4	ASLA		X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
1049 e58f 1f 89              	TFR	A,B	SAVE COMMAND OFFSET IN ACCB
1050 e591 3a                 	ABX		NON X POINTS TO COMMAND JUMP ADDR
1051 e592 9d 7c              	JSR	GETNCH	GET AN INPUT CHAR
1052                         *
1053                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
1054 e594 6e 94              	JMP	[,X]	GO DO A COMMAND
1055                         SECTOK
1056                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
1057                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
1058 e596 9d 7c              	JSR	GETNCH	GET AN INPUT CHAR
1059 e598 81 97              	CMPA	#TOK_MID	TOKEN FOR "MID$"
1060 e59a 10 27 14 ed        	LBEQ	L86D6	PROCESS MID$ REPLACEMENT
1061 e59e 7e ea 05           	JMP	LB277	SYNTAX ERROR
1062                         
1063                         *
1064                         * RESTORE
1065 e5a1 9e 19              RESTOR	LDX	TXTTAB	BEGINNING OF PROGRAM ADDRESS
1066 e5a3 30 1f              	LEAX	-1,X	MOVE TO ONE BYTE BEFORE PROGRAM
1067 e5a5 9f 33              LADE8	STX	DATPTR	SAVE NEW DATA POINTER
1068 e5a7 39                 LADEA	RTS
1069                         *
1070                         * BREAK CHECK
1071 e5a8 bd e0 05           LADEB	JSR	LA1C1	GET A KEYSTROKE ENTRY
1072 e5ab 27 0a              	BEQ	LADFA	RETURN IF NO INPUT
1073 e5ad 81 03              LADF0	CMPA	#3	CONTROL C? (BREAK)
1074 e5af 27 12              	BEQ	STOP	YES
1075 e5b1 81 13              	CMPA	#$13	CONTROL S? (PAUSE)
1076 e5b3 27 03              	BEQ	LADFB	YES
1077 e5b5 97 73              	STA	IKEYIM	SAVE KEYSTROKE IN INKEY IMAGE
1078 e5b7 39                 LADFA	RTS
1079 e5b8 bd e0 05           LADFB	JSR	KEYIN	GET A KEY
1080 e5bb 27 fb              	BEQ	LADFB	BRANCH IF NO KEY DOWN
1081 e5bd 20 ee              	BRA	LADF0	CONTINUE - DO A BREAK CHECK
1082                         *
1083                         * END
1084 e5bf 9d 82              END	JSR	GETCCH	GET CURRENT INPUT CHAR
1085 e5c1 20 02              	BRA	LAE0B
1086                         *
1087                         * STOP
1088 e5c3 1a 01              STOP	ORCC	#$01	SET CARRY FLAG
1089 e5c5 26 31              LAE0B	BNE	LAE40	BRANCH IF ARGUMENT EXISTS
1090 e5c7 9e 83              	LDX	CHARAD	* SAVE CURRENT POSITION OF
1091 e5c9 9f 2f              	STX	TINPTR	* BASIC'S INPUT POINTER
1092 e5cb 06 00              LAE11	ROR	ENDFLG	ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
1093 e5cd 32 62              	LEAS	2,S	PURGE RETURN ADDRESS OFF STACK
1094 e5cf 9e 68              LAE15	LDX	CURLIN	GET CURRENT LINE NUMBER
1095 e5d1 8c ff ff           	CMPX	#$FFFF	DIRECT MODE?
1096 e5d4 27 06              	BEQ	LAE22	YES
1097 e5d6 9f 29              	STX	OLDTXT	SAVE CURRENT LINE NUMBER
1098 e5d8 9e 2f              	LDX	TINPTR	* GET AND SAVE CURRENT POSITION
1099 e5da 9f 2d              	STX	OLDPTR	* OF BASIC'S INPUT POINTER
1100                         LAE22
1101 e5dc 8e e3 b3           	LDX	#LABF2-1	POINT TO CR, 'BREAK' MESSAGE
1102 e5df 0d 00              	TST	ENDFLG	CHECK STOP/END FLAG
1103 e5e1 10 2a fe 42        	LBPL	LAC73	BRANCH TO MAIN LOOP OF BASIC IF END
1104 e5e5 7e e4 1c           	JMP	LAC68	PRINT 'BREAK AT ####' AND GO TO
1105                         *		 BASIC'S MAIN LOOP IF 'STOP'
1106                         
1107                         * CONT
1108 e5e8 26 0e              CONT	BNE	LAE40	RETURN IF ARGUMENT GIVEN
1109 e5ea c6 20              	LDB	#2*16	'CAN NOT CONTINUE' ERROR
1110 e5ec 9e 2d              	LDX	OLDPTR	GET CONTINUE ADDRESS (INPUT POINTER)
1111 e5ee 10 27 fe 16        	LBEQ	LAC46	'CN' ERROR IF CONTINUE ADDRESS = 0
1112 e5f2 9f 83              	STX	CHARAD	RESET BASIC�S INPUT POINTER
1113 e5f4 9e 29              	LDX	OLDTXT	GET LINE NUMBER
1114 e5f6 9f 68              	STX	CURLIN	RESET CURRENT LINE NUMBER
1115 e5f8 39                 LAE40	RTS
1116                         *
1117                         * CLEAR
1118 e5f9 27 2c              CLEAR	BEQ	LAE6F	BRANCH IF NO ARGUMENT
1119 e5fb bd eb 6f           	JSR	LB3E6	EVALUATE ARGUMENT
1120 e5fe 34 06              	PSHS	B,A	SAVE AMOUNT OF STRING SPACE ON STACK
1121 e600 9e 27              	LDX	MEMSIZ	GET CURRENT TOP OF CLEARED SPACE
1122 e602 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1123 e604 27 0c              	BEQ	LAE5A	BRANCH IF NO NEW TOP OF CLEARED SPACE
1124 e606 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
1125 e609 bd ee c6           	JSR	LB73D	EVALUATE EXPRESSlON; RETURN VALUE IN X
1126 e60c 30 1f              	LEAX	-1,X	X = TOP OF CLEARED SPACE
1127 e60e 9c 71              	CMPX	TOPRAM	COMPARE TO TOP OF RAM
1128 e610 22 18              	BHI	LAE72	'OM' ERROR IF > TOP OF RAM
1129 e612 1f 10              LAE5A	TFR	X,D	ACCD = TOP OF CLEARED SPACE
1130 e614 a3 e1              	SUBD	,S++	SUBTRACT OUT AMOUNT OF CLEARED SPACE
1131 e616 25 12              	BCS	LAE72	'OM' ERROR IF FREE MEM < 0
1132 e618 1f 03              	TFR	D,U	U = BOTTOM OF CLEARED SPACE
1133 e61a 83 00 3a           	SUBD	#STKBUF	SUBTRACT OUT STACK BUFFER
1134 e61d 25 0b              	BCS	LAE72	'OM' ERROR IF FREE MEM < 0
1135 e61f 93 1b              	SUBD	VARTAB	SUBTRACT OUT START OF VARIABLES
1136 e621 25 07              	BCS	LAE72	'OM' ERROR IF FREE MEM < 0
1137 e623 df 21              	STU	FRETOP	SAVE NEW BOTTOM OF CLEARED SPACE
1138 e625 9f 27              	STX	MEMSIZ	SAVE NEW TOP OF CLEARED SPACE
1139 e627 7e e4 cc           LAE6F	JMP	LAD26	ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
1140 e62a 7e e4 06           LAE72	JMP	LAC44	'OM' ERROR
1141                         *
1142                         * RUN
1143 e62d 9d 82              RUN	JSR	GETCCH	* GET CURRENT INPUT CHARACTER
1144 e62f 10 27 fe 94        	LBEQ	LAD21	* IF NO LINE NUMBER
1145 e633 bd e4 cc           	JSR	LAD26	ERASE ALL VARIABLES
1146 e636 20 19              	BRA	LAE9F	'GOTO' THE RUN ADDRESS
1147                         *
1148                         * GO
1149 e638 1f 89              GO	TFR	A,B	SAVE INPUT CHARACTER IN ACCB
1150 e63a 9d 7c              LAE88	JSR	GETNCH	GET A CHARACTER FROM BASIC
1151 e63c c1 a0              	CMPB	#TOK_TO	'TO' TOKEN
1152 e63e 27 16              	BEQ	LAEA4	BRANCH IF GOTO
1153 e640 c1 a1              	CMPB	#TOK_SUB	'SUB' TOKEN
1154 e642 26 45              	BNE	LAED7	'SYNTAX ERROR' IF NEITHER
1155 e644 c6 03              	LDB	#3	=ROOM FOR 6
1156 e646 bd e3 f5           	JSR	LAC33	=BYTES ON STACK?
1157 e649 de 83              	LDU	CHARAD	* SAVE CURRENT BASIC INPUT POINTER, LINE
1158 e64b 9e 68              	LDX	CURLIN	* NUMBER AND SUB TOKEN ON STACK
1159 e64d 86 a1              	LDA	#TOK_SUB	*
1160 e64f 34 52              	PSHS	U,X,A	*
1161 e651 8d 03              LAE9F	BSR	LAEA4	GO DO A 'GOTO'
1162 e653 7e e5 44           	JMP	LAD9E	JUMP BACK TO BASIC'S MAIN LOOP
1163                         * GOTO
1164 e656 9d 82              LAEA4	JSR	GETCCH	GET CURRENT INPUT CHAR
1165 e658 bd e7 19           	JSR	LAF67	GET LINE NUMBER TO BINARY IN BINVAL
1166 e65b 8d 40              	BSR	LAEEB	ADVANCE BASIC�S POINTER TO END OF LINE
1167 e65d 30 01              	LEAX	$01,X	POINT TO START OF NEXT LINE
1168 e65f dc 2b              	LDD	BINVAL	GET THE LINE NUMBER TO RUN
1169 e661 10 93 68           	CMPD	CURLIN	COMPARE TO CURRENT LINE NUMBER
1170 e664 22 02              	BHI	LAEB6	IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
1171                         *	DON'T START LOOKING FROM
1172                         *	START OF PROGRAM
1173 e666 9e 19              	LDX	TXTTAB	BEGINNING OF PROGRAM
1174 e668 bd e4 ab           LAEB6	JSR	LAD05	GO FIND A LINE NUMBER
1175 e66b 25 17              	BCS	LAED2	'UNDEFINED LINE NUMBER'
1176 e66d 30 1f              LAEBB	LEAX	-1,X	MOVE BACK TO JUST BEFORE START OF LINE
1177 e66f 9f 83              	STX	CHARAD	RESET BASIC�S INPUT POINTER
1178 e671 39                 LAEBF	RTS
1179                         *
1180                         * RETURN
1181 e672 26 fd              RETURN	BNE	LAEBF	EXIT ROUTINE IF ARGUMENT GIVEN
1182 e674 86 ff              	LDA	#$FF	* PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
1183 e676 97 3b              	STA	VARDES	* VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
1184                         *	STACK TO BE IGNORED
1185 e678 bd e3 bb           	JSR	LABF9	CHECK FOR RETURN DATA ON THE STACK
1186 e67b 1f 14              	TFR	X,S	RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
1187                         *	FROM THE STACK
1188 e67d 81 21              	CMPA	#TOK_SUB-$80	SUB TOKEN - $80
1189 e67f 27 0b              	BEQ	LAEDA	BRANCH IF 'RETURN' FROM SUBROUTINE
1190 e681 c6 04              	LDB	#2*2	ERROR #2 'RETURN WITHOUT GOSUB'
1191 e683 8c                 	FCB	SKP2	SKIP TWO BYTES
1192 e684 c6 0e              LAED2	LDB	#7*2	ERROR #7 'UNDEFINED LINE NUMBER'
1193 e686 7e e4 08           	JMP	LAC46	JUMP TO ERROR HANDLER
1194 e689 7e ea 05           LAED7	JMP	LB277	'SYNTAX ERROR'
1195 e68c 35 52              LAEDA	PULS	A,X,U	* RESTORE VALUES OF CURRENT LINE NUMBER AND
1196 e68e 9f 68              	STX	CURLIN	* BASIC'S INPUT POINTER FOR THIS SUBROUTINE
1197 e690 df 83              	STU	CHARAD	* AND LOAD ACCA WITH SUB TOKEN ($A6)
1198                         *
1199                         * DATA
1200 e692 8d 06              DATA	BSR	LAEE8	MOVE INPUT POINTER TO END OF SUBLINE OR LINE
1201 e694 8c                 	FCB	SKP2	SKIP 2 BYTES
1202                         
1203                         * REM, ELSE
1204                         ELSE
1205 e695 8d 06              REM	BSR	LAEEB	MOVE INPUT POINTER TO END OF LINE
1206 e697 9f 83              	STX	CHARAD	RESET BASIC�S INPUT POINTER
1207 e699 39                 LAEE7	RTS
1208                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
1209 e69a c6 3a              LAEE8	LDB	#':	COLON = SUBLINE TERMINATOR CHARACTER
1210 e69c 86                 LAEEA	FCB	SKP1LD	SKPILD SKIP ONE BYTE; LDA #$5F
1211                         * ADVANCE BASIC'S INPUT POINTER TO END OF
1212                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
1213 e69d 5f                 LAEEB	CLRB		0 = LINE TERMINATOR CHARACTER
1214 e69e d7 01              	STB	CHARAC	TEMP STORE PRIMARY TERMINATOR CHARACTER
1215 e6a0 5f                 	CLRB		0 (END OF LINE) = ALTERNATE TERM. CHAR.
1216 e6a1 9e 83              	LDX	CHARAD	LOAD X W/BASIC�S INPUT POINTER
1217 e6a3 1f 98              LAEF1	TFR	B,A	* CHANGE TERMINATOR CHARACTER
1218 e6a5 d6 01              	LDB	CHARAC	* FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
1219                         *	IN	CHARAC
1220 e6a7 97 01              	STA	CHARAC	SWAP PRIMARY AND SECONDARY TERMINATORS
1221 e6a9 a6 84              LAEF7	LDA	,X	GET NEXT INPUT CHARACTER
1222 e6ab 27 ec              	BEQ	LAEE7	RETURN IF 0 (END OF LINE)
1223 e6ad 34 04              	PSHS	B	SAVE TERMINATOR ON STACK
1224 e6af a1 e0              	CMPA	,S+	COMPARE TO INPUT CHARACTER
1225 e6b1 27 e6              	BEQ	LAEE7	RETURN IF EQUAL
1226 e6b3 30 01              	LEAX	1,X	MOVE POINTER UP ONE
1227 e6b5 81 22              	CMPA	#'"	CHECK FOR DOUBLE QUOTES
1228 e6b7 27 ea              	BEQ	LAEF1	BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
1229 e6b9 4c                 	INCA		* CHECK FOR $FF AND BRANCH IF
1230 e6ba 26 02              	BNE	LAF0C	* NOT SECONDARY TOKEN
1231 e6bc 30 01              	LEAX	1,X	MOVE INPUT POINTER 1 MORE IF SECONDARY
1232 e6be 81 86              LAF0C	CMPA	#TOK_IF+1	TOKEN FOR IF?
1233 e6c0 26 e7              	BNE	LAEF7	NO - GET ANOTHER INPUT CHARACTER
1234 e6c2 0c 04              	INC	IFCTR	INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
1235                         *		'IF' STATEMENTS ARE NESTED IN ONE LINE
1236 e6c4 20 e3              	BRA	LAEF7	GET ANOTHER INPUT CHARACTER
1237                         
1238                         * IF
1239 e6c6 bd e8 cf           IF	JSR	LB141	EVALUATE NUMERIC EXPRESSION
1240 e6c9 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1241 e6cb 81 81              	CMPA	#TOK_GO	TOKEN FOR GO
1242 e6cd 27 05              	BEQ	LAF22	TREAT 'GO' THE SAME AS 'THEN'
1243 e6cf c6 a2              	LDB	#TOK_THEN	TOKEN FOR THEN
1244 e6d1 bd e9 fd           	JSR	LB26F	DO A SYNTAX CHECK ON ACCB
1245 e6d4 96 4f              LAF22	LDA	FP0EXP	CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
1246 e6d6 26 13              	BNE	LAF39	BRANCH IF CONDITION TRUE
1247 e6d8 0f 04              	CLR	IFCTR	CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
1248                         *		 TO SEARCH FOR IN NESTED 'IF' LOOPS
1249 e6da 8d b6              LAF28	BSR	DATA	MOVE BASIC�S POINTER TO END OF SUBLINE
1250 e6dc 4d                 	TSTA		* CHECK TO SEE IF END OF LINE OR SUBLINE
1251 e6dd 27 ba              	BEQ	LAEE7	* AND RETURN IF END OF LINE
1252 e6df 9d 7c              	JSR	GETNCH	GET AN INPUT CHARACTER FROM BASIC
1253 e6e1 81 84              	CMPA	#TOK_ELSE	TOKEN FOR ELSE
1254 e6e3 26 f5              	BNE	LAF28	IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
1255                         *		 END OF LINE (ZERO BYTE)
1256 e6e5 0a 04              	DEC	IFCTR	CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
1257 e6e7 2a f1              	BPL	LAF28	BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
1258 e6e9 9d 7c              	JSR	GETNCH	GET AN INPUT CHARACTER FROM BASIC
1259 e6eb 9d 82              LAF39	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1260 e6ed 10 25 ff 65        	LBCS	LAEA4	BRANCH TO 'GOTO' IF NUMERIC CHARACTER
1261 e6f1 7e e5 7c           	JMP	LADC6	RETURN TO MAIN INTERPRETATION LOOP
1262                         
1263                         * ON
1264 e6f4 bd ee 94           ON	JSR	LB70B	EVALUATE EXPRESSION
1265 e6f7 c6 81              	LDB	#TOK_GO	TOKEN FOR GO
1266 e6f9 bd e9 fd           	JSR	LB26F	SYNTAX CHECK FOR GO
1267 e6fc 34 02              	PSHS	A	SAVE NEW TOKEN (TO,SUB)
1268 e6fe 81 a1              	CMPA	#TOK_SUB	TOKEN FOR SUB?
1269 e700 27 04              	BEQ	LAF54	YES
1270 e702 81 a0              	CMPA	#TOK_TO	TOKEN FOR TO?
1271 e704 26 83              LAF52	BNE	LAED7	'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
1272 e706 0a 53              LAF54	DEC	FPA0+3	DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
1273                         *		 IS THE ARGUMENT OF THE 'ON' STATEMENT
1274 e708 26 05              	BNE	LAF5D	BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
1275 e70a 35 04              	PULS	B	GET BACK THE TOKEN FOLLOWING 'GO'
1276 e70c 7e e6 3a           	JMP	LAE88	GO DO A 'GOTO' OR 'GOSUB'
1277 e70f 9d 7c              LAF5D	JSR	GETNCH	GET A CHARACTER FROM BASIC
1278 e711 8d 06              	BSR	LAF67	CONVERT BASIC LINE NUMBER TO BINARY
1279 e713 81 2c              	CMPA	#',	IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
1280 e715 27 ef              	BEQ	LAF54	YES
1281 e717 35 84              	PULS	B,PC	IF NOT, FALL THROUGH TO NEXT COMMAND
1282 e719 9e 74              LAF67	LDX	ZERO	DEFAULT LINE NUMBER OF ZERO
1283 e71b 9f 2b              	STX	BINVAL	SAVE IT IN BINVAL
1284                         *
1285                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
1286                         *
1287 e71d 24 61              LAF6B	BCC	LAFCE	RETURN IF NOT NUMERIC CHARACTER
1288 e71f 80 30              	SUBA	#'0	MASK OFF ASCII
1289 e721 97 01              	STA	CHARAC	SAVE DIGIT IN VO1
1290 e723 dc 2b              	LDD	BINVAL	GET ACCUMULATED LINE NUMBER VALUE
1291 e725 81 18              	CMPA	#24	LARGEST LINE NUMBER IS $F9FF (63999) -
1292                         *	(24*256+255)*10+9
1293 e727 22 db              	BHI	LAF52	'SYNTAX' ERROR IF TOO BIG
1294                         * MULT ACCD X 10
1295 e729 58                 	ASLB		*
1296 e72a 49                 	ROLA		* TIMES 2
1297 e72b 58                 	ASLB		=
1298 e72c 49                 	ROLA		= TIMES 4
1299 e72d d3 2b              	ADDD	BINVAL	ADD 1 = TIMES 5
1300 e72f 58                 	ASLB		*
1301 e730 49                 	ROLA		* TIMES 10
1302 e731 db 01              	ADDB	CHARAC	ADD NEXT DIGIT
1303 e733 89 00              	ADCA	#0	PROPAGATE CARRY
1304 e735 dd 2b              	STD	BINVAL	SAVE NEW ACCUMULATED LINE NUMBER
1305 e737 9d 7c              	JSR	GETNCH	GET NEXT CHARACTER FROM BASIC
1306 e739 20 e2              	BRA	LAF6B	LOOP- PROCESS NEXT DIGIT
1307                         *
1308                         * LET (EXBAS)
1309                         * EVALUATE A NON-TOKEN EXPRESSION
1310                         * TARGET = REPLACEMENT
1311 e73b bd ea e0           LET	JSR	LB357	FIND TARGET VARIABLE DESCRIPTOR
1312 e73e 9f 3b              	STX	VARDES	SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
1313 e740 c6 ae              	LDB	#TOK_EQUALS	TOKEN FOR "="
1314 e742 bd e9 fd           	JSR	LB26F	DO A SYNTAX CHECK FOR �=� 
1315 e745 96 06              	LDA	VALTYP	* GET VARIABLE TYPE AND
1316 e747 34 02              	PSHS	A	* SAVE ON THE STACK
1317 e749 bd e8 e4           	JSR	LB156	EVALUATE EXPRESSION
1318 e74c 35 02              	PULS	A	* REGET VARIABLE TYPE OF 1ST EXPRESSION AND
1319 e74e 46                 	RORA		* SET CARRY IF STRING
1320 e74f bd e8 d6           	JSR	LB148	TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
1321                         *			BOTH SIDES OF EQUALS SIGN NOT THE SAME
1322 e752 10 27 0c 28        	LBEQ	LBC33	GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
1323                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
1324                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
1325                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
1326                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
1327                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
1328                         * STACK IF IT IS LAST ONE ON THE STACK
1329 e756 9e 52              LAFA4	LDX	FPA0+2	POINT X TO DESCRIPTOR OF REPLACEMENT STRING
1330 e758 dc 21              	LDD	FRETOP	LOAD ACCD WITH START OF STRING SPACE
1331 e75a 10 a3 02           	CMPD	2,X	IS THE STRING IN STRING SPACE?
1332 e75d 24 11              	BCC	LAFBE	BRANCH IF IT'S NOT IN THE STRING SPACE
1333 e75f 9c 1b              	CMPX	VARTAB	COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
1334 e761 25 0d              	BCS	LAFBE	BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
1335 e763 e6 84              LAFB1	LDB	,X	GET LENGTH OF REPLACEMENT STRING
1336 e765 bd ec 96           	JSR	LB50D	RESERVE ACCB BYTES OF STRING SPACE
1337 e768 9e 4d              	LDX	V4D	GET DESCRIPTOR ADDRESS BACK
1338 e76a bd ed cc           	JSR	LB643	MOVE STRING INTO STRING SPACE
1339 e76d 8e 00 56           	LDX	#STRDES	POINT X TO TEMP STRING DESCRIPTOR ADDRESS
1340 e770 9f 4d              LAFBE	STX	V4D	SAVE STRING DESCRIPTOR ADDRESS IN V4D
1341 e772 bd ed fe           	JSR	LB675	REMOVE STRING DESCRIPTOR IF LAST ONE
1342                         *	ON STRING STACK
1343 e775 de 4d              	LDU	V4D	POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
1344 e777 9e 3b              	LDX	VARDES	GET TARGET DESCRIPTOR ADDRESS
1345 e779 37 26              	PULU	A,B,Y	GET LENGTH AND START OF REPLACEMENT STRING
1346 e77b a7 84              	STA	,X	* SAVE STRING LENGTH AND START IN
1347 e77d 10 af 02           	STY	2,X	* TARGET DESCRIPTOR LOCATION
1348 e780 39                 LAFCE	RTS
1349                         
1350 e781 3f 52 45 44 4f     LAFCF	FCC	"?REDO"	?REDO MESSAGE
1351 e786 0d 00              	FCB	CR,$00
1352                         
1353                         LAFD6
1354 e788 7e e4 08           LAFDC	JMP	LAC46	JMP TO ERROR HANDLER
1355 e78b 96 09              LAFDF	LDA	INPFLG	= GET THE INPUT FLAG AND BRANCH
1356 e78d 27 07              	BEQ	LAFEA	= IF 'INPUT'
1357 e78f 9e 31              	LDX	DATTXT	* GET LINE NUMBER WHERE THE ERROR OCCURRED
1358 e791 9f 68              	STX	CURLIN	* AND USE IT AS THE CURRENT LINE NUMBER
1359 e793 7e ea 05           	JMP	LB277	'SYNTAX ERROR'
1360 e796 8e e7 80           LAFEA	LDX	#LAFCF-1	* POINT X TO '?REDO' AND PRINT
1361 e799 bd f0 e7           	JSR	LB99C	* IT ON THE SCREEN
1362 e79c 9e 2f              	LDX	TINPTR	= GET THE SAVED ABSOLUTE ADDRESS OF
1363 e79e 9f 83              	STX	CHARAD	= INPUT POINTER AND RESTORE IT
1364 e7a0 39                 	RTS
1365                         *
1366                         * INPUT
1367 e7a1 c6 16              INPUT	LDB	#11*2	'ID' ERROR
1368 e7a3 9e 68              	LDX	CURLIN	GET CURRENT LINE NUMBER
1369 e7a5 30 01              	LEAX	1,X	ADD ONE
1370 e7a7 27 df              	BEQ	LAFDC	'ID' ERROR BRANCH IF DIRECT MODE
1371 e7a9 8d 01              	BSR	LB00F	GET SOME INPUT DATA - WAS LB002
1372 e7ab 39                 	RTS
1373 e7ac 81 22              LB00F	CMPA	#'"	CHECK FOR PROMPT STRING DELIMITER
1374 e7ae 26 0b              	BNE	LB01E	BRANCH IF NO PROMPT STRING
1375 e7b0 bd e9 d2           	JSR	LB244	PUT PROMPT STRING ON STRING STACK
1376 e7b3 c6 3b              	LDB	#';	*
1377 e7b5 bd e9 fd           	JSR	LB26F	* DO A SYNTAX CHECK FOR SEMICOLON
1378 e7b8 bd f0 ea           	JSR	LB99F	PRINT MESSAGE TO CONSOLE OUT
1379 e7bb 8e 00 f3           LB01E	LDX	#LINBUF	POINT TO BASIC�S LINE BUFFER
1380 e7be 6f 84              	CLR	,X	CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
1381                         *	IN LINE BUFFER
1382 e7c0 8d 06              	BSR	LB02F	INPUT A STRING TO LINE BUFFER
1383 e7c2 c6 2c              	LDB	#',	* INSERT A COMMA AT THE END
1384 e7c4 e7 84              	STB	,X	* OF THE LINE INPUT BUFFER
1385 e7c6 20 16              	BRA	LB049
1386                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
1387 e7c8 bd f0 fa           LB02F	JSR	LB9AF	SEND A "?" TO CONSOLE OUT
1388 e7cb bd f0 f7           	JSR	LB9AC	SEND A 'SPACE' TO CONSOLE OUT
1389 e7ce bd e1 43           LB035	JSR	LA390	GO READ IN A BASIC LINE
1390 e7d1 24 05              	BCC	LB03F	BRANCH IF ENTER KEY ENDED ENTRY
1391 e7d3 32 64              	LEAS	4,S	PURGE TWO RETURN ADDRESSES OFF THE STACK
1392 e7d5 7e e5 cb           	JMP	LAE11	GO DO A �STOP� IF BREAK KEY ENDED LINE ENTRY
1393 e7d8 c6 2e              LB03F	LDB	#2*23	'INPUT PAST END OF FILE' ERROR
1394 e7da 39                 	RTS
1395                         *
1396                         * READ
1397 e7db 9e 33              READ	LDX	DATPTR	GET 'READ' START ADDRESS
1398 e7dd 86                 	FCB	SKP1LD	SKIP ONE BYTE - LDA #*$4F
1399 e7de 4f                 LB049	CLRA		'INPUT' ENTRY POINT: INPUT FLAG = 0
1400 e7df 97 09              	STA	INPFLG	SET INPUT FLAG; 0 = INPUT: <> 0 = READ
1401 e7e1 9f 35              	STX	DATTMP	SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
1402 e7e3 bd ea e0           LB04E	JSR	LB357	EVALUATE A VARIABLE
1403 e7e6 9f 3b              	STX	VARDES	SAVE DESCRIPTOR ADDRESS
1404 e7e8 9e 83              	LDX	CHARAD	* GET BASIC'S INPUT POINTER
1405 e7ea 9f 2b              	STX	BINVAL	* AND SAVE IT
1406 e7ec 9e 35              	LDX	DATTMP	GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
1407 e7ee a6 84              	LDA	,X	GET A CHARACTER FROM THE BASIC PROGRAM
1408 e7f0 26 09              	BNE	LB069	BRANCH IF NOT END OF LINE
1409 e7f2 96 09              	LDA	INPFLG	* CHECK INPUT FLAG AND BRANCH
1410 e7f4 26 51              	BNE	LB0B9	* IF LOOKING FOR DATA (READ)
1411                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
1412                         * NOT COMING FROM SCREEN
1413 e7f6 bd f0 fa           	JSR	LB9AF	SEND A '?' TO CONSOLE OUT
1414 e7f9 8d cd              	BSR	LB02F	FILL INPUT BUFFER FROM CONSOLE IN
1415 e7fb 9f 83              LB069	STX	CHARAD	RESET BASIC'S INPUT POINTER
1416 e7fd 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
1417 e7ff d6 06              	LDB	VALTYP	* CHECK VARIABLE TYPE AND
1418 e801 27 23              	BEQ	LB098	* BRANCH IF NUMERIC
1419                         * READ/INPUT A STRING VARIABLE
1420 e803 9e 83              	LDX	CHARAD	LOAD X WITH CURRENT BASIC INPUT POINTER
1421 e805 97 01              	STA	CHARAC	SAVE CURRENT INPUT CHARACTER
1422 e807 81 22              	CMPA	#'"	CHECK FOR STRING DELIMITER
1423 e809 27 0e              	BEQ	LB08B	BRANCH IF STRING DELIMITER
1424 e80b 30 1f              	LEAX	-1,X	BACK UP POINTER
1425 e80d 4f                 	CLRA		* ZERO = END OF LINE CHARACTER
1426 e80e 97 01              	STA	CHARAC	* SAVE AS TERMINATOR
1427 e810 bd e1 35           	JSR	LA35F	SET UP PRINT PARAMETERS
1428 e813 86 3a              	LDA	#':	END OF SUBLINE CHARACTER
1429 e815 97 01              	STA	CHARAC	SAVE AS TERMINATOR I
1430 e817 86 2c              	LDA	#',	COMMA
1431 e819 97 02              LB08B	STA	ENDCHR	SAVE AS TERMINATOR 2
1432 e81b bd ec a7           	JSR	LB51E	STRIP A STRING FROM THE INPUT BUFFER
1433 e81e bd e9 d7           	JSR	LB249	MOVE INPUT POINTER TO END OF STRING
1434 e821 bd e7 56           	JSR	LAFA4	PUT A STRING INTO THE STRING SPACE IF NECESSARY
1435 e824 20 06              	BRA	LB09E	CHECK FOR ANOTHER DATA ITEM
1436                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
1437 e826 bd f4 5d           LB098	JSR	LBD12	CONVERT AN ASCII STRING TO FP NUMBER
1438 e829 bd f3 7e           	JSR	LBC33	PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
1439                         *			INPUT OR READ DATA ITEM
1440 e82c 9d 82              LB09E	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1441 e82e 27 06              	BEQ	LB0A8	BRANCH IF END OF LINE
1442 e830 81 2c              	CMPA	#',	CHECK FOR A COMMA
1443 e832 10 26 ff 52        	LBNE	LAFD6	BAD FILE DATA' ERROR OR RETRY
1444 e836 9e 83              LB0A8	LDX	CHARAD	* GET CURRENT INPUT
1445 e838 9f 35              	STX	DATTMP	* POINTER (USED AS A DATA POINTER) AND SAVE IT
1446 e83a 9e 2b              	LDX	BINVAL	* RESET INPUT POINTER TO INPUT OR
1447 e83c 9f 83              	STX	CHARAD	* READ STATEMENT
1448 e83e 9d 82              	JSR	GETCCH	GET CURRENT CHARACTER FROM BASIC
1449 e840 27 21              	BEQ	LB0D5	BRANCH IF END OF LINE - EXIT COMMAND
1450 e842 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
1451 e845 20 9c              	BRA	LB04E	GET ANOTHER INPUT OR READ ITEM
1452                         * SEARCH FROM ADDRESS IN X FOR
1453                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
1454 e847 9f 83              LB0B9	STX	CHARAD	RESET BASIC'S INPUT POINTER
1455 e849 bd e6 9a           	JSR	LAEE8	SEARCH FOR END OF CURRENT LINE OR SUBLINE
1456 e84c 30 01              	LEAX	1,X	MOVE X ONE PAST END OF LINE
1457 e84e 4d                 	TSTA		CHECK FOR END OF LINE
1458 e84f 26 0a              	BNE	LB0CD	BRANCH IF END OF SUBLINE
1459 e851 c6 06              	LDB	#2*3	'OUT OF DATA' ERROR
1460 e853 ee 81              	LDU	,X++	GET NEXT 2 CHARACTERS
1461 e855 27 41              	BEQ	LB10A	'OD' ERROR IF END OF PROGRAM
1462 e857 ec 81              	LDD	,X++	GET BASIC LINE NUMBER AND
1463 e859 dd 31              	STD	DATTXT	SAVE IT IN DATTXT
1464 e85b a6 84              LB0CD	LDA	,X	GET AN INPUT CHARACTER
1465 e85d 81 86              	CMPA	#TOK_DATA	DATA TOKEN?
1466 e85f 26 e6              	BNE	LB0B9	NO - KEEP LOOKING
1467 e861 20 98              	BRA	LB069	YES
1468                         * EXIT READ AND INPUT COMMANDS
1469 e863 9e 35              LB0D5	LDX	DATTMP	GET DATA POINTER
1470 e865 d6 09              	LDB	INPFLG	* CHECK INPUT FLAG
1471 e867 10 26 fd 3a        	LBNE	LADE8	* SAVE NEW DATA POINTER IF READ
1472 e86b a6 84              	LDA	,X	= CHECK NEXT CHARACTER IN 'INPUT' BUFFER
1473 e86d 27 06              	BEQ	LB0E7	=
1474 e86f 8e e8 75           	LDX	#LB0E8-1	POINT X TO �?EXTRA IGNORED� 
1475 e872 7e f0 e7           	JMP	LB99C	PRINT THE MESSAGE
1476 e875 39                 LB0E7	RTS
1477                         
1478 e876 3f 45 58 54 52 41  LB0E8	FCC	"?EXTRA IGNORED" ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
1479                         
1480                         
1481 e884 0d 00              	FCB	CR,$00
1482                         
1483                         * NEXT
1484 e886 26 04              NEXT	BNE	LB0FE	BRANCH IF ARGUMENT GIVEN
1485 e888 9e 74              	LDX	ZERO	X = 0: DEFAULT FOR NO ARGUMENT
1486 e88a 20 03              	BRA	LB101
1487 e88c bd ea e0           LB0FE	JSR	LB357	EVALUATE AN ALPHA EXPRESSION
1488 e88f 9f 3b              LB101	STX	VARDES	SAVE VARIABLE DESCRIPTOR POINTER
1489 e891 bd e3 bb           	JSR	LABF9	GO SCAN FOR 'FOR/NEXT' DATA ON STACK
1490 e894 27 04              	BEQ	LB10C	BRANCH IF DATA FOUND
1491 e896 c6 00              	LDB	#0	'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
1492 e898 20 47              LB10A	BRA	LB153	PROCESS ERROR
1493 e89a 1f 14              LB10C	TFR	X,S	POINT S TO START OF 'FOR/NEXT' DATA
1494 e89c 30 03              	LEAX	3,X	POINT X TO FP VALUE OF STEP
1495 e89e bd f3 5f           	JSR	LBC14	COPY A FP NUMBER FROM (X) TO FPA0
1496 e8a1 a6 68              	LDA	8,S	GET THE DIRECTION OF STEP
1497 e8a3 97 54              	STA	FP0SGN	SAVE IT AS THE SIGN OF FPA0
1498 e8a5 9e 3b              	LDX	VARDES	POINT (X) TO INDEX VARIABLE DESCRIPTOR
1499 e8a7 bd f1 0d           	JSR	LB9C2	ADD (X) TO FPA0 (STEP TO INDEX)
1500 e8aa bd f3 7e           	JSR	LBC33	PACK FPA0 AND STORE IT IN ADDRESS
1501                         *		 CONTAINED IN VARDES
1502 e8ad 30 69              	LEAX	9,S	POINT (X) TO TERMINAL VALUE OF INDEX
1503 e8af bd f3 e1           	JSR	LBC96	COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
1504 e8b2 e0 68              	SUBB	8,S	ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
1505                         *			STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
1506                         *			STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
1507 e8b4 27 0c              	BEQ	LB134	BRANCH IF 'FOR/NEXT' LOOP DONE
1508 e8b6 ae 6e              	LDX	14,S	* GET LINE NUMBER AND
1509 e8b8 9f 68              	STX	CURLIN	* BASIC POINTER OF
1510 e8ba ae e8 10           	LDX	16,S	* STATEMENT FOLLOWING THE
1511 e8bd 9f 83              	STX	CHARAD	* PROPER FOR STATEMENT
1512 e8bf 7e e5 44           LB131	JMP	LAD9E	JUMP BACK TO COMMAND INTEPR. LOOP
1513 e8c2 32 e8 12           LB134	LEAS	18,S	PULL THE 'FOR-NEXT' DATA OFF THE STACK
1514 e8c5 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1515 e8c7 81 2c              	CMPA	#',	CHECK FOR ANOTHER ARGUMENT
1516 e8c9 26 f4              	BNE	LB131	RETURN IF NONE
1517 e8cb 9d 7c              	JSR	GETNCH	GET NEXT CHARACTER FROM BASIC
1518 e8cd 8d bd              	BSR	LB0FE	BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
1519                         
1520                         
1521 e8cf 8d 13              LB141	BSR	LB156	EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
1522 e8d1 1c fe              LB143	ANDCC	#$FE	CLEAR CARRY FLAG
1523 e8d3 7d                 LB145	FCB	$7D	OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
1524                         *	NOT CHANGE CARRY FLAG)
1525 e8d4 1a 01              LB146	ORCC	#1	SET CARRY
1526                         
1527                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
1528                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
1529                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
1530                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
1531                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
1532 e8d6 0d 06              LB148	TST	VALTYP	TEST TYPE FLAG; DO NOT CHANGE CARRY
1533 e8d8 25 03              	BCS	LB14F	BRANCH IF STRING
1534 e8da 2a 99              	BPL	LB0E7	RETURN ON PLUS
1535 e8dc 8c                 	FCB	SKP2	SKIP 2 BYTES - 'TM' ERROR
1536 e8dd 2b 96              LB14F	BMI	LB0E7	RETURN ON MINUS
1537 e8df c6 18              	LDB	#12*2	'TYPE M1SMATCH' ERROR
1538 e8e1 7e e4 08           LB153	JMP	LAC46	PROCESS ERROR
1539                         * EVALUATE EXPRESSION
1540 e8e4 8d 6e              LB156	BSR	LB1C6	BACK UP INPUT POINTER
1541 e8e6 4f                 LB158	CLRA		END OF OPERATION PRECEDENCE FLAG
1542 e8e7 8c                 	FCB	SKP2	SKIP TWO BYTES
1543 e8e8 34 04              LB15A	PSHS	B	SAVE FLAG (RELATIONAL OPERATOR FLAG)
1544 e8ea 34 02              	PSHS	A	SAVE FLAG (PRECEDENCE FLAG)
1545 e8ec c6 01              	LDB	#1	*
1546 e8ee bd e3 f5           	JSR	LAC33	* SEE IF ROOM IN FREE RAM FOR (B) WORDS
1547 e8f1 bd e9 b1           	JSR	LB223	GO EVALUATE AN EXPRESSION
1548 e8f4 0f 3f              	CLR	TRELFL	RESET RELATIONAL OPERATOR FLAG
1549 e8f6 9d 82              LB168	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1550                         * CHECK FOR RELATIONAL OPERATORS
1551 e8f8 80 ad              LB16A	SUBA	#TOK_GREATER	TOKEN FOR >
1552 e8fa 25 13              	BCS	LB181	BRANCH IF LESS THAN RELATIONAL OPERATORS
1553 e8fc 81 03              	CMPA	#3	*
1554 e8fe 24 0f              	BCC	LB181	* BRANCH IF GREATER THAN RELATIONAL OPERATORS
1555 e900 81 01              	CMPA	#1	SET CARRY IF �>� 
1556 e902 49                 	ROLA		CARRY TO BIT 0
1557 e903 98 3f              	EORA	TRELFL	* CARRY SET IF
1558 e905 91 3f              	CMPA	TRELFL	* TRELFL = ACCA
1559 e907 25 64              	BCS	LB1DF	BRANCH IF SYNTAX ERROR : == << OR >>
1560 e909 97 3f              	STA	TRELFL	BIT 0: >, BIT 1 =, BIT 2: <
1561 e90b 9d 7c              	JSR	GETNCH	GET AN INPUT CHARACTER
1562 e90d 20 e9              	BRA	LB16A	CHECK FOR ANOTHER RELATIONAL OPERATOR
1563                         *
1564 e90f d6 3f              LB181	LDB	TRELFL	GET RELATIONAL OPERATOR FLAG
1565 e911 26 33              	BNE	LB1B8	BRANCH IF RELATIONAL COMPARISON
1566 e913 10 24 00 6b        	LBCC	LB1F4	BRANCH IF > RELATIONAL OPERATOR
1567 e917 8b 07              	ADDA	#7	SEVEN ARITHMETIC/LOGICAL OPERATORS
1568 e919 24 67              	BCC	LB1F4	BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
1569 e91b 99 06              	ADCA	VALTYP	ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
1570 e91d 10 27 04 77        	LBEQ	LB60F	BRANCH IF VALTYP = FF, AND ACCA = �+� TOKEN -
1571                         *			CONCATENATE TWO STRINGS
1572 e921 89 ff              	ADCA	#-1	RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
1573 e923 34 02              	PSHS	A	* STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
1574 e925 48                 	ASLA		* THEN ADD THE STORED STACK DATA = MULTIPLY
1575 e926 ab e0              	ADDA	,S+	* X 3; 3 BYTE/TABLE ENTRY
1576 e928 8e e2 0d           	LDX	#LAA51	JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
1577 e92b 30 86              	LEAX	A,X	POINT X TO PROPER TABLE
1578 e92d 35 02              LB19F	PULS	A	GET PRECEDENCE FLAG FROM STACK
1579 e92f a1 84              	CMPA	,X	COMPARE TO CURRENT OPERATOR
1580 e931 24 55              	BCC	LB1FA	BRANCH IF STACK OPERATOR > CURRENT OPERATOR
1581 e933 8d 9c              	BSR	LB143	'TM' ERROR IF VARIABLE TYPE = STRING
1582                         
1583                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
1584 e935 34 02              LB1A7	PSHS	A	SAVE PRECEDENCE FLAG
1585 e937 8d 29              	BSR	LB1D4	PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
1586 e939 9e 3d              	LDX	RELPTR	GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
1587                         *		 LAST CALCULATED OPERATION
1588 e93b 35 02              	PULS	A	GET PRECEDENCE FLAG OF PREVIOUS OPERATION
1589 e93d 26 1d              	BNE	LB1CE	BRANCH IF NOT END OF OPERATION
1590 e93f 4d                 	TSTA		CHECK TYPE OF PRECEDENCE FLAG
1591 e940 10 27 00 6a        	LBEQ	LB220	BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
1592 e944 20 4b              	BRA	LB203	EVALUATE AN OPERATION
1593                         
1594 e946 08 06              LB1B8	ASL	VALTYP	BIT 7 OF TYPE FLAG TO CARRY
1595 e948 59                 	ROLB		SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
1596 e949 8d 09              	BSR	LB1C6	MOVE THE INPUT POINTER BACK ONE
1597 e94b 8e e9 59           	LDX	#LB1CB	POINT X TO RELATIONAL COMPARISON JUMP TABLE
1598 e94e d7 3f              	STB	TRELFL	SAVE RELATIONAL COMPARISON DATA
1599 e950 0f 06              	CLR	VALTYP	SET VARIABLE TYPE TO NUMERIC
1600 e952 20 d9              	BRA	LB19F	PERFORM OPERATION OR SAVE ON STACK
1601                         
1602 e954 9e 83              LB1C6	LDX	CHARAD	* GET BASIC�S INPUT POINTER AND
1603 e956 7e e6 6d           	JMP	LAEBB	* MOVE IT BACK ONE
1604                         * RELATIONAL COMPARISON JUMP TABLE
1605 e959 64                 LB1CB	FCB	$64	RELATIONAL COMPARISON FLAG
1606 e95a ea 7d              LB1CC	FDB	LB2F4	JUMP ADDRESS
1607                         
1608 e95c a1 84              LB1CE	CMPA	,X	COMPARE PRECEDENCE OF LAST DONE OPERATION TO
1609                         *	NEXT TO BE DONE OPERATION
1610 e95e 24 31              	BCC	LB203	EVALUATE OPERATION IF LOWER PRECEDENCE
1611 e960 20 d3              	BRA	LB1A7	PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
1612                         
1613                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
1614 e962 ec 01              LB1D4	LDD	1,X	GET ADDRESS OF OPERATOR ROUTINE
1615 e964 34 06              	PSHS	B,A	SAVE IT ON THE STACK
1616 e966 8d 08              	BSR	LB1E2	PUSH FPA0 ONTO STACK
1617 e968 d6 3f              	LDB	TRELFL	GET BACK RELATIONAL OPERATOR FLAG
1618 e96a 16 ff 7b           	LBRA	LB15A	EVALUATE ANOTHER EXPRESSION
1619 e96d 7e ea 05           LB1DF	JMP	LB277	'SYNTAX ERROR'
1620                         * PUSH FPA0 ONTO THE STACK. ,S	= EXPONENT
1621                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
1622                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
1623 e970 d6 54              LB1E2	LDB	FP0SGN	GET SIGN OF FPA0 MANTISSA
1624 e972 a6 84              	LDA	,X	GET PRECEDENCE CODE TO ACCA
1625 e974 35 20              LB1E6	PULS Y	GET RETURN ADDRESS FROM STACK & PUT IT IN Y
1626 e976 34 04              	PSHS	B	SAVE ACCB ON STACK
1627 e978 d6 4f              LB1EA	LDB	FP0EXP	* PUSH FPA0 ONTO THE STACK
1628 e97a 9e 50              	LDX	FPA0	*
1629 e97c de 52              	LDU	FPA0+2	*
1630 e97e 34 54              	PSHS	U,X,B	*
1631 e980 6e a4              	JMP	,Y	JUMP TO ADDRESS IN Y
1632                         
1633                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
1634 e982 9e 74              LB1F4	LDX	ZERO	POINT X TO DUMMY VALUE (ZERO)
1635 e984 a6 e0              	LDA	,S+	GET PRECEDENCE FLAG FROM STACK
1636 e986 27 26              	BEQ	LB220	BRANCH IF END OF EXPRESSION
1637 e988 81 64              LB1FA	CMPA	#$64	* CHECK FOR RELATIONAL COMPARISON FLAG
1638 e98a 27 03              	BEQ	LB201	* AND BRANCH IF RELATIONAL COMPARISON
1639 e98c bd e8 d1           	JSR	LB143	'TM' ERROR IF VARIABLE TYPE = STRING
1640 e98f 9f 3d              LB201	STX	RELPTR	SAVE POINTER TO OPERATOR ROUTINE
1641 e991 35 04              LB203	PULS	B	GET RELATIONAL OPERATOR FLAG FROM STACK
1642 e993 81 5a              	CMPA	#$5A	CHECK FOR 'NOT' OPERATOR
1643 e995 27 19              	BEQ	LB222	RETURN IF 'NOT' - NO RELATIONAL COMPARISON
1644 e997 81 7d              	CMPA	#$7D	CHECK FOR NEGATION (UNARY) FLAG
1645 e999 27 15              	BEQ	LB222	RETURN IF NEGATION - NO RELATIONAL COMPARISON
1646                         
1647                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
1648                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
1649                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
1650                         * TO EVALUATING ROUTINE.
1651 e99b 54                 	LSRB		= ROTATE VALTYP BIT INTO CARRY
1652 e99c d7 0a              	STB	RELFLG	= FLAG AND SAVE NEW RELFLG
1653 e99e 35 52              	PULS	A,X,U	* PULL A FP VALUE OFF OF THE STACK
1654 e9a0 97 5c              	STA	FP1EXP	* AND SAVE IT IN FPA1
1655 e9a2 9f 5d              	STX	FPA1	*
1656 e9a4 df 5f              	STU	FPA1+2	*
1657 e9a6 35 04              	PULS	B	= GET MANTISSA SIGN AND
1658 e9a8 d7 61              	STB	FP1SGN	= SAVE IT IN FPA1
1659 e9aa d8 54              	EORB	FP0SGN	EOR IT WITH FPA1 MANTISSA SIGN
1660 e9ac d7 62              	STB	RESSGN	SAVE IT IN RESULT SIGN BYTE
1661 e9ae d6 4f              LB220	LDB	FP0EXP	GET EXPONENT OF FPA0
1662 e9b0 39                 LB222	RTS
1663                         
1664 e9b1 bd fb fb           LB223	JSR	XVEC15	CALL EXTENDED BASIC ADD-IN
1665 e9b4 0f 06              	CLR	VALTYP	INITIALIZE TYPE FLAG TO NUMERIC
1666 e9b6 9d 7c              	JSR	GETNCH	GET AN INPUT CHAR
1667 e9b8 24 03              	BCC	LB22F	BRANCH IF NOT NUMERIC
1668 e9ba 7e f4 5d           LB22C	JMP	LBD12	CONVERT ASCII STRING TO FLOATING POINT -
1669                         *	RETURN RESULT IN FPA0
1670                         * PROCESS A NON NUMERIC FIRST CHARACTER
1671 e9bd bd eb 2b           LB22F	JSR	LB3A2	SET CARRY IF NOT ALPHA
1672 e9c0 24 50              	BCC	LB284	BRANCH IF ALPHA CHARACTER
1673 e9c2 81 2e              	CMPA	#'.	IS IT �.� (DECIMAL POINT)?
1674 e9c4 27 f4              	BEQ	LB22C	CONVERT ASCII STRING TO FLOATING POINT
1675 e9c6 81 a7              	CMPA	#TOK_MINUS	MINUS TOKEN
1676 e9c8 27 40              	BEQ	LB27C	YES - GO PROCESS THE MINUS OPERATOR
1677 e9ca 81 a6              	CMPA	#TOK_PLUS	PLUS TOKEN
1678 e9cc 27 e3              	BEQ	LB223	YES - GET ANOTHER CHARACTER
1679 e9ce 81 22              	CMPA	#'"	STRING DELIMITER?
1680 e9d0 26 0a              	BNE	LB24E	NO
1681 e9d2 9e 83              LB244	LDX	CHARAD	CURRENT BASIC POINTER TO X
1682 e9d4 bd ec a1           	JSR	LB518	SAVE STRING ON STRING STACK
1683 e9d7 9e 64              LB249	LDX	COEFPT	* GET ADDRESS OF END OF STRING AND
1684 e9d9 9f 83              	STX	CHARAD	* PUT BASIC�S INPUT POINTER THERE
1685 e9db 39                 	RTS
1686 e9dc 81 a3              LB24E	CMPA	#TOK_NOT	NOT TOKEN?
1687 e9de 26 0d              	BNE	LB25F	NO
1688                         * PROCESS THE NOT OPERATOR
1689 e9e0 86 5a              	LDA	#$5A	'NOT' PRECEDENCE FLAG
1690 e9e2 bd e8 e8           	JSR	LB15A	PROCESS OPERATION FOLLOWING 'NOT'
1691 e9e5 bd eb 76           	JSR	INTCNV	CONVERT FPA0 TO INTEGER IN ACCD
1692 e9e8 43                 	COMA		* 'NOT' THE INTEGER
1693 e9e9 53                 	COMB		*
1694 e9ea 7e ec 7d           	JMP	GIVABF	CONVERT ACCD TO FLOATING POINT (FPA0)
1695 e9ed 4c                 LB25F	INCA		CHECK FOR TOKENS PRECEEDED BY $FF
1696 e9ee 27 2e              	BEQ	LB290	IT WAS PRECEEDED BY $FF
1697 e9f0 8d 06              LB262	BSR	LB26A	SYNTAX CHECK FOR A �(� 
1698 e9f2 bd e8 e4           	JSR	LB156	EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
1699                         *	HIGHEST PRECEDENCE
1700 e9f5 c6 29              LB267	LDB	#')	SYNTAX CHECK FOR �)� 
1701 e9f7 8c                 	FCB	SKP2	SKIP 2 BYTES
1702 e9f8 c6 28              LB26A	LDB	#'(	SYNTAX CHECK FOR �(� 
1703 e9fa 8c                 	FCB	SKP2	SKIP 2 BYTES
1704 e9fb c6 2c              LB26D	LDB	#',	SYNTAX CHECK FOR COMMA
1705 e9fd e1 9f 00 83        LB26F	CMPB	[CHARAD]	* COMPARE ACCB TO CURRENT INPUT
1706 ea01 26 02              	BNE	LB277	* CHARACTER - SYNTAX ERROR IF NO MATCH
1707 ea03 0e 7c              	JMP	GETNCH	GET A CHARACTER FROM BASIC
1708 ea05 c6 02              LB277	LDB	#2*1	SYNTAX ERROR
1709 ea07 7e e4 08           	JMP	LAC46	JUMP TO ERROR HANDLER
1710                         
1711                         * PROCESS THE MINUS (UNARY) OPERATOR
1712 ea0a 86 7d              LB27C	LDA	#$7D	MINUS (UNARY) PRECEDENCE FLAG
1713 ea0c bd e8 e8           	JSR	LB15A	PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
1714 ea0f 7e f6 34           	JMP	LBEE9	CHANGE SIGN OF FPA0 MANTISSA
1715                         
1716                         * EVALUATE ALPHA EXPRESSION
1717 ea12 bd ea e0           LB284	JSR	LB357	FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
1718 ea15 9f 52              LB287	STX	FPA0+2	SAVE DESCRIPTOR ADDRESS IN FPA0
1719 ea17 96 06              	LDA	VALTYP	TEST VARIABLE TYPE
1720 ea19 26 95              	BNE	LB222	RETURN IF STRING
1721 ea1b 7e f3 5f           	JMP	LBC14	COPY A FP NUMBER FROM (X) TO FPA0
1722                         
1723                         * EVALUATING A SECONDARY TOKEN
1724 ea1e 9d 7c              LB290	JSR	GETNCH	GET AN INPUT CHARACTER (SECONDARY TOKEN)
1725 ea20 1f 89              	TFR	A,B	SAVE IT IN ACCB
1726 ea22 58                 	ASLB		X2 & BET RID OF BIT 7
1727 ea23 9d 7c              	JSR	GETNCH	GET ANOTHER INPUT CHARACTER
1728 ea25 c1 38              	CMPB	#NUM_SEC_FNS-1*2 29 SECONDARY FUNCTIONS - 1
1729 ea27 23 03              	BLS	LB29F	BRANCH IF COLOR BASIC TOKEN
1730 ea29 7e ea 05           	JMP	LB277	SYNTAX ERROR
1731 ea2c 34 04              LB29F	PSHS	B	SAVE TOKEN OFFSET ON STACK
1732 ea2e c1 2a              	CMPB	#TOK_LEFT-$80*2 CHECK FOR TOKEN WITH AN ARGUMENT
1733 ea30 25 1e              	BCS	LB2C7	DO SECONDARIES STRING$ OR LESS
1734 ea32 c1 30              	CMPB	#TOK_INKEY-$80*2 *
1735 ea34 24 1c              	BCC	LB2C9	* DO SECONDARIES $92 (INKEY$) OR >
1736 ea36 8d c0              	BSR	LB26A	SYNTAX CHECK FOR A �(� 
1737 ea38 a6 e4              	LDA	,S	GET TOKEN NUMBER
1738                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
1739 ea3a bd e8 e4           	JSR	LB156	EVALUATE FIRST STRING IN ARGUMENT
1740 ea3d 8d bc              	BSR	LB26D	SYNTAX CHECK FOR A COMMA
1741 ea3f bd e8 d4           	JSR	LB146	'TM' ERROR IF NUMERIC VARiABLE
1742 ea42 35 02              	PULS	A	GET TOKEN OFFSET FROM STACK
1743 ea44 de 52              	LDU	FPA0+2	POINT U TO STRING DESCRIPTOR
1744 ea46 34 42              	PSHS	U,A	SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
1745 ea48 bd ee 94           	JSR	LB70B	EVALUATE FIRST NUMERIC ARGUMENT
1746 ea4b 35 02              	PULS	A	GET TOKEN OFFSET FROM STACK
1747 ea4d 34 06              	PSHS	B,A	SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
1748 ea4f 8e                 	FCB	$8E	OP CODE OF LDX# - SKlP 2 BYTES
1749 ea50 8d 9e              LB2C7	BSR	LB262	SYNTAX CHECK FOR A �(� 
1750 ea52 35 04              LB2C9	PULS	B	GET TOKEN OFFSET
1751 ea54 be e0 fb           	LDX	COMVEC+8	GET SECONDARY FUNCTION JUMP TABLE ADDRESS
1752 ea57 3a                 LB2CE	ABX		ADD IN COMMAND OFFSET
1753                         *
1754                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
1755 ea58 ad 94              	JSR	[,X]	GO DO AN SECONDARY FUNCTION
1756 ea5a 7e e8 d1           	JMP	LB143	'TM' ERROR IF VARIABLE TYPE = STRING
1757                         
1758                         * LOGICAL OPERATOR 'OR' JUMPS HERE
1759 ea5d 86                 LB2D4	FCB	SKP1LD	SKIP ONE BYTE - 'OR' FLAG = $4F
1760                         
1761                         * LOGICAL OPERATOR 'AND' JUMPS HERE
1762 ea5e 4f                 LB2D5	CLRA		AND FLAG = 0
1763 ea5f 97 03              	STA	TMPLOC	AND/OR FLAG
1764 ea61 bd eb 76           	JSR	INTCNV	CONVERT FPA0 INTO AN INTEGER IN ACCD
1765 ea64 dd 01              	STD	CHARAC	TEMP SAVE ACCD
1766 ea66 bd f3 95           	JSR	LBC4A	MOVE FPA1 TO FPA0
1767 ea69 bd eb 76           	JSR	INTCNV	CONVERT FPA0 INTO AN INTEGER IN ACCD
1768 ea6c 0d 03              	TST	TMPLOC	CHECK AND/OR FLAG
1769 ea6e 26 06              	BNE	LB2ED	BRANCH IF OR
1770 ea70 94 01              	ANDA	CHARAC	* 'AND' ACCD WITH FPA0 INTEGER
1771 ea72 d4 02              	ANDB	ENDCHR	* STORED IN ENDCHR
1772 ea74 20 04              	BRA	LB2F1	CONVERT TO FP
1773 ea76 9a 01              LB2ED	ORA	CHARAC	* 'OR' ACCD WITH FPA0 INTEGER
1774 ea78 da 02              	ORB	ENDCHR	* STORED IN CHARAC
1775 ea7a 7e ec 7d           LB2F1	JMP	GIVABF	CONVERT THE VALUE IN ACCD INTO A FP NUMBER
1776                         
1777                         * RELATIONAL COMPARISON PROCESS HANDLER
1778 ea7d bd e8 d6           LB2F4	JSR	LB148	'TM' ERROR IF TYPE MISMATCH
1779 ea80 26 10              	BNE	LB309	BRANCH IF STRING VARIABLE
1780 ea82 96 61              	LDA	FP1SGN	* 'PACK' THE MANTISSA
1781 ea84 8a 7f              	ORA	#$7F	* SIGN OF FPA1 INTO
1782 ea86 94 5d              	ANDA	FPA1	* BIT 7 OF THE
1783 ea88 97 5d              	STA	FPA1	* MANTISSA MS BYTE
1784 ea8a 8e 00 5c           	LDX	#FP1EXP	POINT X TO FPA1
1785 ea8d bd f3 e1           	JSR	LBC96	COMPARE FPA0 TO FPA1
1786 ea90 20 36              	BRA	LB33F	CHECK TRUTH OF RELATIONAL COMPARISON
1787                         
1788                         * RELATIONAL COMPARISON OF STRINGS
1789 ea92 0f 06              LB309	CLR	VALTYP	SET VARIABLE TYPE TO NUMERIC
1790 ea94 0a 3f              	DEC	TRELFL	REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
1791                         *		 DESIRED RELATIONAL COMPARISON DATA
1792 ea96 bd ed e0           	JSR	LB657	GET LENGTH AND ADDRESS OF STRING WHOSE
1793                         *		 DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
1794 ea99 d7 56              	STB	STRDES	* SAVE LENGTH AND ADDRESS IN TEMPORARY
1795 ea9b 9f 58              	STX	STRDES+2	* DESCRIPTOR (STRING B)
1796 ea9d 9e 5f              	LDX	FPA1+2	= RETURN LENGTH AND ADDRESS OF STRING
1797 ea9f bd ed e2           	JSR	LB659	= WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
1798 eaa2 96 56              	LDA	STRDES	LOAD ACCA WITH LENGTH OF STRING B
1799 eaa4 34 04              	PSHS	B	SAVE LENGTH A ON STACK
1800 eaa6 a0 e0              	SUBA	,S+	SUBTRACT LENGTH A FROM LENGTH B
1801 eaa8 27 07              	BEQ	LB328	BRANCH IF STRINGS OF EQUAL LENGTH
1802 eaaa 86 01              	LDA	#1	TRUE FLAG
1803 eaac 24 03              	BCC	LB328	TRUE IF LENGTH B > LENGTH A
1804 eaae d6 56              	LDB	STRDES	LOAD ACCB WITH LENGTH B
1805 eab0 40                 	NEGA		SET FLAG = FALSE (1FF)
1806 eab1 97 54              LB328	STA	FP0SGN	SAVE TRUE/FALSE FLAG
1807 eab3 de 58              	LDU	STRDES+2	POINT U TO START OF STRING
1808 eab5 5c                 	INCB		COMPENSATE FOR THE DECB BELOW
1809                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
1810 eab6 5a                 LB32D	DECB		DECREMENT SHORTER STRING LENGTH
1811 eab7 26 04              	BNE	LB334	BRANCH IF ALL OF STRING NOT COMPARED
1812 eab9 d6 54              	LDB	FP0SGN	GET TRUE/FALSE FLAB
1813 eabb 20 0b              	BRA	LB33F	CHECK TRUTH OF RELATIONAL COMPARISON
1814 eabd a6 80              LB334	LDA	,X+	GET A BYTE FROM STRING A
1815 eabf a1 c0              	CMPA	,U+	COMPARE TO STRING B
1816 eac1 27 f3              	BEQ	LB32D	CHECK ANOTHER CHARACTER IF =
1817 eac3 c6 ff              	LDB	#$FF	FALSE FLAG IF STRING A > B
1818 eac5 24 01              	BCC	LB33F	BRANCH IF STRING A > STRING B
1819 eac7 50                 	NEGB		SET FLAG = TRUE
1820                         
1821                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
1822 eac8 cb 01              LB33F	ADDB	#1	CONVERT $FF,0,1 TO 0,1,2
1823 eaca 59                 	ROLB		NOW IT�S 1,2,4 FOR > = <
1824 eacb d4 0a              	ANDB	RELFLG	'AND' THE ACTUAL COMPARISON WITH THE DESIRED - COMPARISON
1825 eacd 27 02              	BEQ	LB348	BRANCH IF FALSE (NO MATCHING BITS)
1826 eacf c6 ff              	LDB	#$FF	TRUE FLAG
1827 ead1 7e f3 c7           LB348	JMP	LBC7C	CONVERT ACCB INTO FP NUMBER IN FPA0
1828                         
1829                         * DIM
1830 ead4 bd e9 fb           LB34B	JSR	LB26D	SYNTAX CHECK FOR COMMA
1831 ead7 c6 01              DIM	LDB	#1	DIMENSION FLAG
1832 ead9 8d 08              	BSR	LB35A	SAVE ARRAY SPACE FOR THIS VARIABLE
1833 eadb 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1834 eadd 26 f5              	BNE	LB34B	KEEP DIMENSIONING IF NOT END OF LINE
1835 eadf 39                 	RTS
1836                         * EVALUATE A VARIABLE - RETURN X AND
1837                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
1838                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
1839                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
1840                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
1841                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
1842                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
1843                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
1844                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
1845                         * IS NUMERIC.
1846                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
1847                         * INSERTED INTO THE VARIABLE SPACE
1848 eae0 5f                 LB357	CLRB		DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
1849 eae1 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1850 eae3 d7 05              LB35A	STB	DIMFLG	SAVE ARRAY FLAG
1851                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
1852 eae5 97 37              LB35C	STA	VARNAM	SAVE INPUT CHARACTER
1853 eae7 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1854 eae9 8d 40              	BSR	LB3A2	SET CARRY IF NOT ALPHA
1855 eaeb 10 25 ff 16        	LBCS	LB277	SYNTAX ERROR IF NOT ALPHA
1856 eaef 5f                 	CLRB		DEFAULT 2ND VARIABLE CHARACTER TO ZERO
1857 eaf0 d7 06              	STB	VALTYP	SET VARIABLE TYPE TO NUMERIC
1858 eaf2 9d 7c              	JSR	GETNCH	GET ANOTHER CHARACTER FROM BASIC
1859 eaf4 25 04              	BCS	LB371	BRANCH IF NUMERIC (2ND CHARACTER IN
1860                         *			VARIABLE MAY BE NUMERIC)
1861 eaf6 8d 33              	BSR	LB3A2	SET CARRY IF NOT ALPHA
1862 eaf8 25 0a              	BCS	LB37B	BRANCH IF NOT ALPHA
1863 eafa 1f 89              LB371	TFR	A,B	SAVE 2ND CHARACTER IN ACCB
1864                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
1865                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
1866                         * IN VARIABLE NAME AFTER THE 1ST TWO
1867 eafc 9d 7c              LB373	JSR	GETNCH	GET AN INPUT CHARACTER
1868 eafe 25 fc              	BCS	LB373	BRANCH IF NUMERIC
1869 eb00 8d 29              	BSR	LB3A2	SET CARRY IF NOT ALPHA
1870 eb02 24 f8              	BCC	LB373	BRANCH IF ALPHA
1871 eb04 81 24              LB37B	CMPA	#'$	CHECK FOR A STRING VARIABLE
1872 eb06 26 06              	BNE	LB385	BRANCH IF IT IS NOT A STRING
1873 eb08 03 06              	COM	VALTYP	SET VARIABLE TYPE TO STRING
1874 eb0a cb 80              	ADDB	#$80	SET BIT 7 OF 2ND CHARACTER (STRING)
1875 eb0c 9d 7c              	JSR	GETNCH	GET AN INPUT CHARACTER
1876 eb0e d7 38              LB385	STB	VARNAM+1	SAVE 2ND CHARACTER IN VARNAM+1
1877 eb10 9a 08              	ORA	ARYDIS	OR IN THE ARRAY DISABLE FLAG - IF = $80,
1878                         *	DON'T SEARCH FOR VARIABLES IN THE ARRAYS
1879 eb12 80 28              	SUBA	#'(	IS THIS AN ARRAY VARIABLE?
1880 eb14 10 27 00 75        	LBEQ	LB404	BRANCH IF IT IS
1881 eb18 0f 08              	CLR	ARYDIS	RESET THE ARRAY DISABLE FLAG
1882 eb1a 9e 1b              	LDX	VARTAB	POINT X TO THE START OF VARIABLES
1883 eb1c dc 37              	LDD	VARNAM	GET VARIABLE IN QUESTION
1884 eb1e 9c 1d              LB395	CMPX	ARYTAB	COMPARE X TO THE END OF VARIABLES
1885 eb20 27 12              	BEQ	LB3AB	BRANCH IF END OF VARIABLES
1886 eb22 10 a3 81           	CMPD	,X++	* COMPARE VARIABLE IN QUESTION TO CURRENT
1887 eb25 27 3e              	BEQ	LB3DC	* VARIABLE AND BRANCH IF MATCH
1888 eb27 30 05              	LEAX	5,X	= MOVE POINTER TO NEXT VARIABLE AND
1889 eb29 20 f3              	BRA	LB395	= KEEP LOOKING
1890                         
1891                         * SET CARRY IF NOT UPPER CASE ALPHA
1892 eb2b 81 41              LB3A2	CMPA	#'A	* CARRY SET IF < 'A'
1893 eb2d 25 04              	BCS	LB3AA	*
1894 eb2f 80 5b              	SUBA	#'Z+1	=
1895                         *	SUBA	#-('Z+1)	= CARRY CLEAR IF <= 'Z'
1896 eb31 80 a5              	FCB	$80,$A5
1897 eb33 39                 LB3AA	RTS
1898                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
1899 eb34 8e 00 74           LB3AB	LDX	#ZERO	POINT X TO ZERO LOCATION
1900 eb37 ee e4              	LDU	,S	GET CURRENT RETURN ADDRESS
1901 eb39 11 83 ea 15        	CMPU	#LB287	DID WE COME FROM 'EVALUATE ALPHA EXPR'
1902 eb3d 27 28              	BEQ	LB3DE	YES - RETURN A ZERO VALUE
1903 eb3f dc 1f              	LDD	ARYEND	* GET END OF ARRAYS ADDRESS AND
1904 eb41 dd 43              	STD	V43	* SAVE IT AT V43
1905 eb43 c3 00 07           	ADDD	#7	= ADD 7 TO END OF ARRAYS (EACH
1906 eb46 dd 41              	STD	V41	= VARIABLE = 7 BYTES) AND SAVE AT V41
1907 eb48 9e 1d              	LDX	ARYTAB	* GET END OF VARIABLES AND SAVE AT V47
1908 eb4a 9f 47              	STX	V47	*
1909 eb4c bd e3 e0           	JSR	LAC1E	MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
1910                         *	TOP	OF VARIABLES
1911 eb4f 9e 41              	LDX	V41	= GET NEW END OF ARRAYS AND SAVE IT
1912 eb51 9f 1f              	STX	ARYEND	=
1913 eb53 9e 45              	LDX	V45	* GET NEW END OF VARIABLES AND SAVE IT
1914 eb55 9f 1d              	STX	ARYTAB	*
1915 eb57 9e 47              	LDX	V47	GET OLD END OF VARIABLES
1916 eb59 dc 37              	LDD	VARNAM	GET NEW VARIABLE NAME
1917 eb5b ed 81              	STD	,X++	SAVE VARIABLE NAME
1918 eb5d 4f                 	CLRA		* ZERO OUT THE FP VALUE OF THE NUMERIC
1919 eb5e 5f                 	CLRB		* VARIABLE OR THE LENGTH AND ADDRESS
1920 eb5f ed 84              	STD	,X	* OF A STRING VARIABLE
1921 eb61 ed 02              	STD	2,X	*
1922 eb63 a7 04              	STA	4,X	*
1923 eb65 9f 39              LB3DC	STX	VARPTR	STORE ADDRESS OF VARIABLE VALUE
1924 eb67 39                 LB3DE	RTS
1925                         *
1926 eb68 90 80 00 00 00     LB3DF	FCB	$90,$80,$00,$00,$00 * FLOATING POINT -32768
1927                         *		 SMALLEST SIGNED TWO BYTE INTEGER
1928                         *
1929 eb6d 9d 7c              LB3E4	JSR	GETNCH	GET AN INPUT CHARACTER FROM BASIC
1930 eb6f bd e8 cf           LB3E6	JSR	LB141	GO EVALUATE NUMERIC EXPRESSION
1931 eb72 96 54              LB3E9	LDA	FP0SGN	GET FPA0 MANTISSA SIGN
1932 eb74 2b 5d              	BMI	LB44A	'FC' ERROR IF NEGATIVE NUMBER
1933                         
1934                         
1935 eb76 bd e8 d1           INTCNV	JSR	LB143	'TM' ERROR IF STRING VARIABLE
1936 eb79 96 4f              	LDA	FP0EXP	GET FPA0 EXPONENT
1937 eb7b 81 90              	CMPA	#$90	* COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
1938 eb7d 25 08              	BCS	LB3FE	* BRANCH IF FPA0 < 32768
1939 eb7f 8e eb 68           	LDX	#LB3DF	POINT X TO FP VALUE OF -32768
1940 eb82 bd f3 e1           	JSR	LBC96	COMPARE -32768 TO FPA0
1941 eb85 26 4c              	BNE	LB44A	'FC' ERROR IF NOT =
1942 eb87 bd f4 13           LB3FE	JSR	LBCC8	CONVERT FPA0 TO A TWO BYTE INTEGER
1943 eb8a dc 52              	LDD	FPA0+2	GET THE INTEGER
1944 eb8c 39                 	RTS
1945                         * EVALUATE AN ARRAY VARIABLE
1946 eb8d dc 05              LB404	LDD	DIMFLG	GET ARRAY FLAG AND VARIABLE TYPE
1947 eb8f 34 06              	PSHS	B,A	SAVE THEM ON STACK
1948 eb91 12                 	NOP		DEAD SPACE CAUSED BY 1.2 REVISION
1949 eb92 5f                 	CLRB		RESET DIMENSION COUNTER
1950 eb93 9e 37              LB40A	LDX	VARNAM	GET VARIABLE NAME
1951 eb95 34 14              	PSHS	X,B	SAVE VARIABLE NAME AND DIMENSION COUNTER
1952 eb97 8d d4              	BSR	LB3E4	EVALUATE EXPRESSION (DIMENSlON LENGTH)
1953 eb99 35 34              	PULS	B,X,Y	PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
1954                         *		 ARRAY FLAG
1955 eb9b 9f 37              	STX	VARNAM	SAVE VARIABLE NAME AND VARIABLE TYPE
1956 eb9d de 52              	LDU	FPA0+2	GET DIMENSION LENGTH
1957 eb9f 34 60              	PSHS	U,Y	SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
1958 eba1 5c                 	INCB		INCREASE DIMENSION COUNTER
1959 eba2 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
1960 eba4 81 2c              	CMPA	#',	CHECK FOR ANOTHER DIMENSION
1961 eba6 27 eb              	BEQ	LB40A	BRANCH IF MORE
1962 eba8 d7 03              	STB	TMPLOC	SAVE DIMENSION COUNTER
1963 ebaa bd e9 f5           	JSR	LB267	SYNTAX CHECK FOR A �)� 
1964 ebad 35 06              	PULS	A,B	* RESTORE VARIABLE TYPE AND ARRAY
1965 ebaf dd 05              	STD	DIMFLG	* FLAG - LEAVE DIMENSION LENGTH ON STACK
1966 ebb1 9e 1d              	LDX	ARYTAB	GET START OF ARRAYS
1967 ebb3 9c 1f              LB42A	CMPX	ARYEND	COMPARE TO END OF ARRAYS
1968 ebb5 27 21              	BEQ	LB44F	BRANCH IF NO MATCH FOUND
1969 ebb7 dc 37              	LDD	VARNAM	GET VARIABLE IN QUESTION
1970 ebb9 10 a3 84           	CMPD	,X	COMPARE TO CURRENT VARIABLE
1971 ebbc 27 06              	BEQ	LB43B	BRANCH IF =
1972 ebbe ec 02              	LDD	2,X	GET OFFSET TO NEXT ARRAY VARIABLE
1973 ebc0 30 8b              	LEAX	D,X	ADD TO CURRENT POINTER
1974 ebc2 20 ef              	BRA	LB42A	KEEP SEARCHING
1975 ebc4 c6 12              LB43B	LDB	#2*9	'REDIMENSIONED ARRAY' ERROR
1976 ebc6 96 05              	LDA	DIMFLG	* TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
1977 ebc8 26 0b              	BNE	LB44C	* TO REDIMENSION AN ARRAY
1978 ebca d6 03              	LDB	TMPLOC	GET NUMBER OF DIMENSIONS IN ARRAY
1979 ebcc e1 04              	CMPB	4,X	COMPARE TO THIS ARRAYS DIMENSIONS
1980 ebce 27 59              	BEQ	LB4A0	BRANCH IF =
1981 ebd0 c6 10              LB447	LDB	#8*2	'BAD SUBSCRIPT'
1982 ebd2 8c                 	FCB	SKP2	SKIP TWO BYTES
1983 ebd3 c6 08              LB44A	LDB	#4*2	'ILLEGAL FUNCTION CALL'
1984 ebd5 7e e4 08           LB44C	JMP	LAC46	JUMP TO ERROR SERVICING ROUTINE
1985                         
1986                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
1987                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
1988                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
1989                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
1990                         * AS FOLLOWS: BYTES 0,1:VARIABLE�S NAME; 2,3:TOTAL LENGTH
1991                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
1992                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
1993                         * SION 2;� 4+N,5+N:LENGTH OF DIMENSION N.
1994                         
1995 ebd8 cc 00 05           LB44F	LDD	#5	* 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
1996 ebdb dd 64              	STD	COEFPT	*
1997 ebdd dc 37              	LDD	VARNAM	= GET NAME OF ARRAY AND SAVE IN
1998 ebdf ed 84              	STD	,X	= FIRST 2 BYTES OF DESCRIPTOR
1999 ebe1 d6 03              	LDB	TMPLOC	GET NUMBER OF DIMENSIONS AND SAVE IN
2000 ebe3 e7 04              	STB	4,X	* 5TH BYTE OF DESCRIPTOR
2001 ebe5 bd e3 f5           	JSR	LAC33	CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
2002 ebe8 9f 41              	STX	V41	TEMPORARILY SAVE DESCRIPTOR ADDRESS
2003 ebea c6 0b              LB461	LDB	#11	* DEFAULT DIMENSION VALUE:X(10)
2004 ebec 4f                 	CLRA		*
2005 ebed 0d 05              	TST	DIMFLG	= CHECK ARRAY FLAG AND BRANCH IF
2006 ebef 27 05              	BEQ	LB46D	= NOT DIMENSIONING AN ARRAY
2007 ebf1 35 06              	PULS	A,B	GET DIMENSION LENGTH
2008 ebf3 c3 00 01           	ADDD	#1	ADD ONE (X(0) HAS A LENGTH OF ONE)
2009 ebf6 ed 05              LB46D	STD	5,X	SAVE LENGTH OF ARRAY DIMENSION
2010 ebf8 8d 5d              	BSR	LB4CE	MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
2011                         *		 OF NEW DIMENSION
2012 ebfa dd 64              	STD	COEFPT	TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
2013 ebfc 30 02              	LEAX	2,X	BUMP POINTER UP TWO
2014 ebfe 0a 03              	DEC	TMPLOC	* DECREMENT DIMENSION COUNTER AND BRANCH IF
2015 ec00 26 e8              	BNE	LB461	* NOT DONE WITH ALL DIMENSIONS
2016 ec02 9f 0f              	STX	TEMPTR	SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
2017 ec04 d3 0f              	ADDD	TEMPTR	ADD TOTAL SIZE OF NEW ARRAY
2018 ec06 10 25 f7 fc        	LBCS	LAC44	'OM' ERROR IF > $FFFF
2019 ec0a 1f 01              	TFR	D,X	SAVE END OF ARRAY IN X
2020 ec0c bd e3 f9           	JSR	LAC37	MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
2021 ec0f 83 00 35           	SUBD	#STKBUF-5	SUBTRACT OUT THE (STACK BUFFER - 5)
2022 ec12 dd 1f              	STD	ARYEND	SAVE NEW END OF ARRAYS
2023 ec14 4f                 	CLRA		ZERO = TERMINATOR BYTE
2024 ec15 30 1f              LB48C	LEAX	-1,X	* STORE TWO TERMINATOR BYTES AT
2025 ec17 a7 05              	STA	5,X	* THE END OF THE ARRAY DESCRIPTOR
2026 ec19 9c 0f              	CMPX	TEMPTR	*
2027 ec1b 26 f8              	BNE	LB48C	*
2028 ec1d 9e 41              	LDX	V41	GET ADDRESS OF START OF DESCRIPTOR
2029 ec1f 96 1f              	LDA	ARYEND	GET MSB OF END OF ARRAYS; LSB ALREADY THERE
2030 ec21 93 41              	SUBD	V41	SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
2031 ec23 ed 02              	STD	2,X	SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
2032 ec25 96 05              	LDA	DIMFLG	* GET ARRAY FLAG AND BRANCH
2033 ec27 26 2d              	BNE	LB4CD	* BACK IF DIMENSIONING
2034                         * CALCULATE POINTER TO CORRECT ELEMENT
2035 ec29 e6 04              LB4A0	LDB	4,X	GET THE NUMBER OF DIMENSIONS
2036 ec2b d7 03              	STB	TMPLOC	TEMPORARILY SAVE
2037 ec2d 4f                 	CLRA		* INITIALIZE POINTER
2038 ec2e 5f                 	CLRB		* TO ZERO
2039 ec2f dd 64              LB4A6	STD	COEFPT	SAVE ACCUMULATED POINTER
2040 ec31 35 06              	PULS	A,B	* PULL DIMENSION ARGUMENT OFF THE
2041 ec33 dd 52              	STD	FPA0+2	* STACK AND SAVE IT
2042 ec35 10 a3 05           	CMPD	5,X	COMPARE TO STORED �DIM� ARGUMENT
2043 ec38 24 3a              	BCC	LB4EB	'BS' ERROR IF > = "DIM" ARGUMENT
2044 ec3a de 64              	LDU	COEFPT	* GET ACCUMULATED POINTER AND
2045 ec3c 27 04              	BEQ	LB4B9	* BRANCH IF 1ST DIMENSION
2046 ec3e 8d 17              	BSR	LB4CE	= MULTIPLY ACCUMULATED POINTER AND DIMENSION
2047 ec40 d3 52              	ADDD	FPA0+2	= LENGTH AND ADD TO CURRENT ARGUMENT
2048 ec42 30 02              LB4B9	LEAX	2,X	MOVE POINTER TO NEXT DIMENSION
2049 ec44 0a 03              	DEC	TMPLOC	* DECREMENT DIMENSION COUNTER AND
2050 ec46 26 e7              	BNE	LB4A6	* BRANCH IF ANY DIMENSIONS LEFT
2051                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
2052 ec48 ed e3              	STD	,--S
2053 ec4a 58                 	ASLB
2054 ec4b 49                 	ROLA		TIMES 2
2055 ec4c 58                 	ASLB
2056 ec4d 49                 	ROLA		TIMES 4
2057 ec4e e3 e1              	ADDD	,S++	TIMES 5
2058 ec50 30 8b              	LEAX	D,X	ADD OFFSET TO START OF ARRAY
2059 ec52 30 05              	LEAX	5,X	ADJUST POINTER FOR SIZE OF DESCRIPTOR
2060 ec54 9f 39              	STX	VARPTR	SAVE POINTER TO ARRAY VALUE
2061 ec56 39                 LB4CD	RTS
2062                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
2063                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
2064 ec57 86 10              LB4CE	LDA	#16	16 SHIFTS TO DO A MULTIPLY
2065 ec59 97 45              	STA	V45	SHIFT COUNTER
2066 ec5b ec 05              	LDD	5,X	* GET SIZE OF DIMENSION
2067 ec5d dd 17              	STD	BOTSTK	* AND SAVE IT
2068 ec5f 4f                 	CLRA		* ZERO
2069 ec60 5f                 	CLRB		* ACCD
2070 ec61 58                 LB4D8	ASLB		= SHIFT ACCB LEFT
2071 ec62 49                 	ROLA		= ONE BIT
2072 ec63 25 0f              	BCS	LB4EB	BS' ERROR IF CARRY
2073 ec65 08 65              	ASL	COEFPT+1	* SHIFT MULTIPLICAND LEFT ONE
2074 ec67 09 64              	ROL	COEFPT	* BIT - ADD MULTIPLIER TO ACCUMULATOR
2075 ec69 24 04              	BCC	LB4E6	* IF CARRY <> 0
2076 ec6b d3 17              	ADDD	BOTSTK	ADD MULTIPLIER TO ACCD
2077 ec6d 25 05              	BCS	LB4EB	BS' ERROR IF CARRY (>$FFFF)
2078 ec6f 0a 45              LB4E6	DEC	V45	* DECREMENT SHIFT COUNTER
2079 ec71 26 ee              	BNE	LB4D8	* IF NOT DONE
2080 ec73 39                 	RTS
2081 ec74 7e eb d0           LB4EB	JMP	LB447	BS' ERROR
2082                         *
2083                         * MEM
2084                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
2085                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
2086                         * FOR WHICH MEM DOES NOT ALLOW.
2087                         *
2088 ec77 1f 40              MEM	TFR	S,D	PUT STACK POINTER INTO ACCD
2089 ec79 93 1f              	SUBD	ARYEND	SUBTRACT END OF ARRAYS
2090 ec7b 21                 	FCB	SKP1	SKIP ONE BYTE
2091                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
2092 ec7c 4f                 LB4F3	CLRA		CLEAR MS BYTE OF ACCD
2093                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
2094 ec7d 0f 06              GIVABF	CLR	VALTYP	SET VARIABLE TYPE TO NUMERIC
2095 ec7f dd 50              	STD	FPA0	SAVE ACCD IN TOP OF FACA
2096 ec81 c6 90              	LDB	#$90	EXPONENT REQUIRED IF THE TOP TWO BYTES
2097                         *	OF	FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
2098 ec83 7e f3 cd           	JMP	LBC82	CONVERT THE REST OF FPA0 TO AN INTEGER
2099                         
2100                         * STR$
2101 ec86 bd e8 d1           STR	JSR	LB143	TM' ERROR IF STRING VARIABLE
2102 ec89 ce 01 f0           	LDU	#STRBUF+2	*CONVERT FP NUMBER TO ASCII STRING IN
2103 ec8c bd f5 27           	JSR	LBDDC	*THE STRING BUFFER
2104 ec8f 32 62              	LEAS	2,S	PURGE THE RETURN ADDRESS FROM THE STACK
2105 ec91 8e 01 ef           	LDX	#STRBUF+1	*POINT X TO STRING BUFFER AND SAVE
2106 ec94 20 0b              	BRA	LB518	*THE STRING IN THE STRING SPACE
2107                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
2108                         * ADDRESS IN (X) AND FRESPC
2109 ec96 9f 4d              LB50D	STX	V4D	SAVE X IN V4D
2110 ec98 8d 5c              LB50F	BSR	LB56D	RESERVE ACCB BYTES IN STRING SPACE
2111 ec9a 9f 58              LB511	STX	STRDES+2	SAVE NEW STRING ADDRESS
2112 ec9c d7 56              	STB	STRDES	SAVE LENGTH OF RESERVED BLOCK
2113 ec9e 39                 	RTS
2114 ec9f 30 1f              LB516	LEAX	-1,X	MOVE POINTER BACK ONE
2115                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
2116                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
2117                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
2118                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
2119 eca1 86 22              LB518	LDA	#'"	* INITIALIZE
2120 eca3 97 01              	STA	CHARAC	* TERMINATORS
2121 eca5 97 02              LB51A	STA	ENDCHR	* TO "
2122 eca7 30 01              LB51E	LEAX	1,X	MOVE POINTER UP ONE
2123 eca9 9f 62              	STX	RESSGN	TEMPORARILY SAVE START OF STRING
2124 ecab 9f 58              	STX	STRDES+2	SAVE START OF STRING IN TEMP DESCRIPTOR
2125 ecad c6 ff              	LDB	#-1	INITIALIZE CHARACTER COUNTER TO - 1
2126 ecaf 5c                 LB526	INCB		INCREMENT CHARACTER COUNTER
2127 ecb0 a6 80              	LDA	,X+	GET CHARACTER
2128 ecb2 27 0c              	BEQ	LB537	BRANCH IF END OF LINE
2129 ecb4 91 01              	CMPA	CHARAC	* CHECK FOR TERMINATORS
2130 ecb6 27 04              	BEQ	LB533	* IN CHARAC AND ENDCHR
2131 ecb8 91 02              	CMPA	ENDCHR	* DON'T MOVE POINTER BACK
2132 ecba 26 f3              	BNE	LB526	* ONE IF TERMINATOR IS "MATCHED"
2133 ecbc 81 22              LB533	CMPA	#'"	= COMPARE CHARACTER TO STRING DELIMITER
2134 ecbe 27 02              	BEQ	LB539	= & DON'T MOVE POINTER BACK IF SO
2135 ecc0 30 1f              LB537	LEAX	-1,X	MOVE POINTER BACK ONE
2136 ecc2 9f 64              LB539	STX	COEFPT	SAVE END OF STRING ADDRESS
2137 ecc4 d7 56              	STB	STRDES	SAVE STRING LENGTH IN TEMP DESCRIPTOR
2138 ecc6 de 62              	LDU	RESSGN	GET INITlAL STRING START
2139 ecc8 11 83 01 f0        	CMPU	#STRBUF+2	COMPARE TO START OF STRING BUFFER
2140 eccc 22 07              LB543	BHI	LB54C	BRANCH IF > START OF STRING BUFFER
2141 ecce 8d c6              	BSR	LB50D	GO RESERVE SPACE FOR THE STRING
2142 ecd0 9e 62              	LDX	RESSGN	POINT X TO THE BEGINNING OF THE STRING
2143 ecd2 bd ed ce           	JSR	LB645	MOVE (B) BYTES FROM (X) TO
2144                         *		 [FRESPC] - MOVE STRING DATA
2145                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
2146                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
2147 ecd5 9e 0b              LB54C	LDX	TEMPPT	GET NEXT AVAILABLE STRING STACK DESCRIPTOR
2148 ecd7 8c 00 f1           	CMPX	#LINHDR	COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
2149 ecda 26 05              	BNE	LB558	FORMULA O.K.
2150 ecdc c6 1e              	LDB	#15*2	STRING FORMULA TOO COMPLEX' ERROR
2151 ecde 7e e4 08           LB555	JMP	LAC46	JUMP TO ERROR SERVICING ROUTINE
2152 ece1 96 56              LB558	LDA	STRDES	* GET LENGTH OF STRING AND SAVE IT
2153                         *	STA	,X	* IN BYTE 0 OF DESCRIPTOR
2154 ece3 a7 00              	FCB	$A7,$00
2155 ece5 dc 58              	LDD	STRDES+2	= GET START ADDRESS OF ACTUAL STRING
2156 ece7 ed 02              	STD	2,X	= AND SAVE IN BYTES 2,3 OF DESCRIPTOR
2157 ece9 86 ff              	LDA	#$FF	* VARIABLE TYPE = STRING
2158 eceb 97 06              	STA	VALTYP	* SAVE IN VARIABLE TYPE FLAG
2159 eced 9f 0d              	STX	LASTPT	= SAVE START OF DESCRIPTOR
2160 ecef 9f 52              	STX	FPA0+2	= ADDRESS IN LASTPT AND FPA0
2161 ecf1 30 05              	LEAX	5,X	5 BYTES/STRING DESCRIPTOR
2162 ecf3 9f 0b              	STX	TEMPPT	NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
2163 ecf5 39                 	RTS
2164                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
2165                         * RETURN WITH THE STARTING ADDRESS OF THE
2166                         * RESERVED STRING SPACE IN (X) AND FRESPC
2167 ecf6 0f 07              LB56D	CLR	GARBFL	CLEAR STRING REORGANIZATION FLAG
2168 ecf8 4f                 LB56F	CLRA		* PUSH THE LENGTH OF THE
2169 ecf9 34 06              	PSHS	B,A	* STRING ONTO THE STACK
2170 ecfb dc 23              	LDD	STRTAB	GET START OF STRING VARIABLES
2171 ecfd a3 e0              	SUBD	,S+	SUBTRACT STRING LENGTH
2172 ecff 10 93 21           	CMPD	FRETOP	COMPARE TO START OF STRING STORAGE
2173 ed02 25 0a              	BCS	LB585	IF BELOW START, THEN REORGANIZE
2174 ed04 dd 23              	STD	STRTAB	SAVE NEW START OF STRING VARIABLES
2175 ed06 9e 23              	LDX	STRTAB	GET START OF STRING VARIABLES
2176 ed08 30 01              	LEAX	1,X	ADD ONE
2177 ed0a 9f 25              	STX	FRESPC	SAVE START ADDRESS OF NEWLY RESERVED SPACE
2178 ed0c 35 84              	PULS	B,PC	RESTORE NUMBER OF BYTES RESERVED AND RETURN
2179 ed0e c6 1a              LB585	LDB	#2*13	OUT OF STRING SPACE' ERROR
2180 ed10 03 07              	COM	GARBFL	TOGGLE REORGANIZATiON FLAG
2181 ed12 27 ca              	BEQ	LB555	ERROR IF FRESHLY REORGANIZED
2182 ed14 8d 04              	BSR	LB591	GO REORGANIZE STRING SPACE
2183 ed16 35 04              	PULS	B	GET BACK THE NUMBER OF BYTES TO RESERVE
2184 ed18 20 de              	BRA	LB56F	TRY TO RESERVE ACCB BYTES AGAIN
2185                         * REORGANIZE THE STRING SPACE
2186 ed1a 9e 27              LB591	LDX	MEMSIZ	GET THE TOP OF STRING SPACE
2187 ed1c 9f 23              LB593	STX	STRTAB	SAVE TOP OF UNORGANIZED STRING SPACE
2188 ed1e 4f                 	CLRA		* ZERO OUT ACCD
2189 ed1f 5f                 	CLRB		* AND RESET VARIABLE
2190 ed20 dd 4b              	STD	V4B	* POINTER TO 0
2191 ed22 9e 21              	LDX	FRETOP	POINT X TO START OF STRING SPACE
2192 ed24 9f 47              	STX	V47	SAVE POINTER IN V47
2193 ed26 8e 00 c9           	LDX	#STRSTK	POINT X TO START OF STRING DESCRIPTOR STACK
2194 ed29 9c 0b              LB5A0	CMPX	TEMPPT	COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
2195 ed2b 27 04              	BEQ	LB5A8	BRANCH IF TOP OF STRING STACK
2196 ed2d 8d 32              	BSR	LB5D8	CHECK FOR STRING IN UNORGANIZED STRING SPACE
2197 ed2f 20 f8              	BRA	LB5A0	KEEP CHECKING
2198 ed31 9e 1b              LB5A8	LDX	VARTAB	GET THE END OF BASIC PROGRAM
2199 ed33 9c 1d              LB5AA	CMPX	ARYTAB	COMPARE TO END OF VARIABLES
2200 ed35 27 04              	BEQ	LB5B2	BRANCH IF AT TOP OF VARIABLES
2201 ed37 8d 22              	BSR	LB5D2	CHECK FOR STRING IN UNORGANIZED STRING SPACE
2202 ed39 20 f8              	BRA	LB5AA	KEEP CHECKING VARIABLES
2203 ed3b 9f 41              LB5B2	STX	V41	SAVE ADDRESS OF THE END OF VARIABLES
2204 ed3d 9e 41              LB5B4	LDX	V41	GET CURRENT ARRAY POINTER
2205 ed3f 9c 1f              LB5B6	CMPX	ARYEND	COMPARE TO THE END OF ARRAYS
2206 ed41 27 35              	BEQ	LB5EF	BRANCH IF AT END OF ARRAYS
2207 ed43 ec 02              	LDD	2,X	GET LENGTH OF ARRAY AND DESCRIPTOR
2208 ed45 d3 41              	ADDD	V41	* ADD TO CURRENT ARRAY POINTER
2209 ed47 dd 41              	STD	V41	* AND SAVE IT
2210 ed49 a6 01              	LDA	1,X	GET 1ST CHARACTER OF VARIABLE NAME
2211 ed4b 2a f0              	BPL	LB5B4	BRANCH IF NUMERIC ARRAY
2212 ed4d e6 04              	LDB	4,X	GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
2213 ed4f 58                 	ASLB		MULTIPLY BY 2
2214 ed50 cb 05              	ADDB	#5	ADD FIVE BYTES (VARIABLE NAME, ARRAY
2215                         *		 LENGTH, NUMBER DIMENSIONS)
2216 ed52 3a                 	ABX		X NOW POINTS TO START OF ARRAY ELEMENTS
2217 ed53 9c 41              LB5CA	CMPX	V41	AT END OF THIS ARRAY?
2218 ed55 27 e8              	BEQ	LB5B6	YES - CHECK FOR ANOTHER
2219 ed57 8d 08              	BSR	LB5D8	CHECK FOR STRING LOCATED IN
2220                         *		 UNORGANIZED STRING SPACE
2221 ed59 20 f8              	BRA	LB5CA	KEEP CHECKING ELEMENTS IN THIS ARRAY
2222 ed5b a6 01              LB5D2	LDA	1,X	GET F1RST BYTE OF VARIABLE NAME
2223 ed5d 30 02              	LEAX	2,X	MOVE POINTER TO DESCRIPTOR
2224 ed5f 2a 14              	BPL	LB5EC	BRANCH IF VARIABLE IS NUMERIC
2225                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
2226                         * THE STRING DESCRIPTOR. IF STRING IS STORED
2227                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
2228                         * IN V4B AND RESET V47 TO STRING ADDRESS
2229 ed61 e6 84              LB5D8	LDB	,X	GET THE LENGTH OF THE STRING
2230 ed63 27 10              	BEQ	LB5EC	BRANCH IF NULL - NO STRING
2231 ed65 ec 02              	LDD	2,X	GET STARTING ADDRESS OF THE STRING
2232 ed67 10 93 23           	CMPD	STRTAB	COMPARE TO THE START OF STRING VARIABLES
2233 ed6a 22 09              	BHI	LB5EC	BRANCH IF THIS STRING IS STORED IN
2234                         *	THE STRING VARIABLES
2235 ed6c 10 93 47           	CMPD	V47	COMPARE TO START OF STRING SPACE
2236 ed6f 23 04              	BLS	LB5EC	BRANCH IF NOT STORED IN THE STRING SPACE
2237 ed71 9f 4b              	STX	V4B	SAVE VARIABLE POINTER IF STORED IN STRING SPACE
2238 ed73 dd 47              	STD	V47	SAVE STRING STARTING ADDRESS
2239 ed75 30 05              LB5EC	LEAX	5,X	MOVE TO NEXT VARIABLE DESCRIPTOR
2240 ed77 39                 LB5EE	RTS
2241 ed78 9e 4b              LB5EF	LDX	V4B	GET ADDRESS OF THE DESCRIPTOR FOR THE
2242                         *	STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
2243                         *	THE UNORGANIZED STRING SPACE
2244 ed7a 27 fb              	BEQ	LB5EE	BRANCH IF NONE FOUND AND REORGANIZATION DONE
2245 ed7c 4f                 	CLRA		CLEAR MS BYTE OF LENGTH
2246 ed7d e6 84              	LDB	,X	GET LENGTH OF STRING
2247 ed7f 5a                 	DECB		SUBTRACT ONE
2248 ed80 d3 47              	ADDD	V47	ADD LENGTH OF STRING TO ITS STARTING ADDRESS
2249 ed82 dd 43              	STD	V43	SAVE AS MOVE STARTING ADDRESS
2250 ed84 9e 23              	LDX	STRTAB	POINT X TO THE START OF ORGANIZED STRING VARIABLES
2251 ed86 9f 41              	STX	V41	SAVE AS MOVE ENDING ADDRESS
2252 ed88 bd e3 e2           	JSR	LAC20	MOVE STRING FROM CURRENT POSITION TO THE
2253                         *	TOP OF UNORGANIZED STRING SPACE
2254 ed8b 9e 4b              	LDX	V4B	POINT X TO STRING DESCRIPTOR
2255 ed8d dc 45              	LDD	V45	* GET NEW STARTING ADDRESS OF STRING AND
2256 ed8f ed 02              	STD	2,X	* SAVE IT IN DESCRIPTOR
2257 ed91 9e 45              	LDX	V45	GET NEW TOP OF UNORGANIZED STRING SPACE
2258 ed93 30 1f              	LEAX	-1,X	MOVE POINTER BACK ONE
2259 ed95 7e ed 1c           	JMP	LB593	JUMP BACK AND REORGANIZE SOME MORE
2260                         
2261                         
2262 ed98 dc 52              LB60F	LDD	FPA0+2	* GET DESCRIPTOR ADDRESS OF STRING A
2263 ed9a 34 06              	PSHS	B,A	* AND SAVE IT ON THE STACK
2264 ed9c bd e9 b1           	JSR	LB223	GET DESCRIPTOR ADDRESS OF STRING B
2265 ed9f bd e8 d4           	JSR	LB146	'TM' ERROR IF NUMERIC VARIABLE
2266 eda2 35 10              	PULS	X	* POINT X TO STRING A DESCRIPTOR
2267 eda4 9f 62              	STX	RESSGN	* ADDRESS AND SAVE IT IN RESSGN
2268 eda6 e6 84              	LDB	,X	GET LENGTH OF STRING A
2269 eda8 9e 52              	LDX	FPA0+2	POINT X TO DESCRIPTOR OF STRING B
2270 edaa eb 84              	ADDB	,X	ADD LENGTH OF STRING B TO STR1NG A
2271 edac 24 05              	BCC	LB62A	BRANCH IF LENGTH < 256
2272 edae c6 1c              	LDB	#2*14	STRING TOO LONG' ERROR IF LENGTH > 255
2273 edb0 7e e4 08           	JMP	LAC46	JUMP TO ERROR SERVICING ROUTINE
2274 edb3 bd ec 96           LB62A	JSR	LB50D	RESERVE ROOM IN STRING SPACE FOR NEW STRING
2275 edb6 9e 62              	LDX	RESSGN	GET DESCRIPTOR ADDRESS OF STRING A
2276 edb8 e6 84              	LDB	,X	GET LENGTH OF STRING A
2277 edba 8d 10              	BSR	LB643	MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
2278 edbc 9e 4d              	LDX	V4D	GET DESCRIPTOR ADDRESS OF STRING B
2279 edbe 8d 22              	BSR	LB659	GET LENGTH AND ADDRESS OF STRING B
2280 edc0 8d 0c              	BSR	LB645	MOVE STRING B INTO REST OF RESERVED BUFFER
2281 edc2 9e 62              	LDX	RESSGN	POINT X TO DESCRIPTOR OF STRING A
2282 edc4 8d 1c              	BSR	LB659	DELETE STRING A IF LAST STRING ON STRING STACK
2283 edc6 bd ec d5           	JSR	LB54C	PUT STRING DESCRIPTOR ON THE STRING STACK
2284 edc9 7e e8 f6           	JMP	LB168	BRANCH BACK TO EXPRESSION EVALUATION
2285                         
2286                         * MOVE (B) BYTES FROM 2,X TO FRESPC
2287 edcc ae 02              LB643	LDX	2,X	POINT X TO SOURCE ADDRESS
2288 edce de 25              LB645	LDU	FRESPC	POINT U TO DESTINATION ADDRESS
2289 edd0 5c                 	INCB		COMPENSATION FOR THE DECB BELOW
2290 edd1 20 04              	BRA	LB64E	GO MOVE THE BYTES
2291                         * MOVE B BYTES FROM (X) TO (U)
2292 edd3 a6 80              LB64A	LDA	,X+	* GET A SOURCE BYTE AND MOVE IT
2293 edd5 a7 c0              	STA	,U+	* TO THE DESTINATION
2294 edd7 5a                 LB64E	DECB		DECREMENT BYTE COUNTER
2295 edd8 26 f9              	BNE	LB64A	BRANCH IF ALL BYTES NOT MOVED
2296 edda df 25              	STU	FRESPC	SAVE ENDING ADDRESS IN FRESPC
2297 eddc 39                 	RTS
2298                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
2299                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
2300                         * DELETE THE STRING IF IT IS THE LAST ONE
2301                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
2302                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
2303 eddd bd e8 d4           LB654	JSR	LB146	TM' ERROR IF VARIABLE TYPE = NUMERIC
2304 ede0 9e 52              LB657	LDX	FPA0+2	GET ADDRESS OF SELECTED STRING DESCRIPTOR
2305 ede2 e6 84              LB659	LDB	,X	GET LENGTH OF STRING
2306 ede4 8d 18              	BSR	LB675	* CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
2307 ede6 26 13              	BNE	LB672	* THE LAST ONE PUT ON THE STRING STACK AND
2308                         *		 * BRANCH IF NOT
2309 ede8 ae 07              	LDX	5+2,X	GET START ADDRESS OF STRING JUST REMOVED
2310 edea 30 1f              	LEAX	-1,X	MOVE POINTER DOWN ONE
2311 edec 9c 23              	CMPX	STRTAB	COMPARE TO START OF STRING VARIABLES
2312 edee 26 08              	BNE	LB66F	BRANCH IF THIS STRING IS NOT AT THE BOTTOM
2313                         *		 OF STRING VARIABLES
2314 edf0 34 04              	PSHS	B	SAVE LENGTH; ACCA WAS CLEARED
2315 edf2 d3 23              	ADDD	STRTAB	* ADD THE LENGTH OF THE JUST REMOVED STRING
2316 edf4 dd 23              	STD	STRTAB	* TO THE START OF STRING VARIABLES - THIS WILL
2317                         *		 * REMOVE THE STRING FROM THE STRING SPACE
2318 edf6 35 04              	PULS	B	RESTORE LENGTH
2319 edf8 30 01              LB66F	LEAX	1,X	ADD ONE TO POINTER
2320 edfa 39                 	RTS
2321 edfb ae 02              LB672	LDX	2,X	*POINT X TO ADDRESS OF STRING NOT
2322 edfd 39                 	RTS		*ON THE STRING STACK
2323                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
2324                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
2325                         * STRING FROM STACK IF IT IS ON TOP OF THE
2326                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
2327 edfe 9c 0d              LB675	CMPX	LASTPT	*COMPARE TO LAST USED DESCRIPTOR ADDRESS
2328 ee00 26 07              	BNE	LB680	*ON THE STRING STACK, RETURN IF DESCRIPTOR
2329                         *		 *ADDRESS NOT ON THE STRING STACK
2330 ee02 9f 0b              	STX	TEMPPT	SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
2331 ee04 30 1b              	LEAX	-5,X	* MOVE LAST USED DESCRIPTOR BACK 5 BYTES
2332 ee06 9f 0d              	STX	LASTPT	* AND SAVE AS THE LAST USED DESCRIPTOR ADDR
2333 ee08 4f                 	CLRA		SET ZERO FLAG
2334 ee09 39                 LB680	RTS
2335                         
2336                         * LEN
2337 ee0a 8d 03              LEN	BSR	LB686	POINT X TO PROPER STRING AND GET LENGTH
2338 ee0c 7e ec 7c           LB683	JMP	LB4F3	CONVERT ACCB TO FP NUMBER IN FPA0
2339                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
2340                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
2341                         * BOTTOM TWO BYTES OF FPA0
2342 ee0f 8d cc              LB686	BSR	LB654	GET LENGTH AND ADDRESS OF STRING
2343 ee11 0f 06              	CLR	VALTYP	SET VARIABLE TYPE TO NUMERIC
2344 ee13 5d                 	TSTB		SET FLAGS ACCORDING TO LENGTH
2345 ee14 39                 	RTS
2346                         
2347                         * CHR$
2348 ee15 bd ee 97           CHR	JSR	LB70E	CONVERT FPA0 TO AN INTEGER IN ACCD
2349 ee18 c6 01              LB68F	LDB	#1	* RESERVE ONE BYTE IN
2350 ee1a bd ec f6           	JSR	LB56D	* THE STRING SPACE
2351 ee1d 96 53              	LDA	FPA0+3	GET ASCII STRING VALUE
2352 ee1f bd ec 9a           	JSR	LB511	SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
2353 ee22 a7 84              	STA	,X	SAVE THE STRING (IT�S ONLY ONE BYTE)
2354 ee24 32 62              LB69B	LEAS	2,S	PURGE THE RETURN ADDRESS OFF OF THE STACK
2355 ee26 7e ec d5           LB69D	JMP	LB54C	PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
2356                         
2357                         
2358 ee29 8d 02              ASC	BSR	LB6A4	PUT 1ST CHARACTER OF STRING INTO ACCB
2359 ee2b 20 df              	BRA	LB683	CONVERT ACCB INTO FP NUMBER IN FPA0
2360 ee2d 8d e0              LB6A4	BSR	LB686	POINT X TO STRING DESCRIPTOR
2361 ee2f 27 5e              	BEQ	LB706	FC' ERROR IF NULL STRING
2362 ee31 e6 84              	LDB	,X	GET FIRST BYTE OF STRING
2363 ee33 39                 	RTS
2364                         
2365                         
2366 ee34 8d 48              LEFT	BSR	LB6F5	GET ARGUMENTS FROM STACK
2367 ee36 4f                 LB6AD	CLRA		CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
2368 ee37 e1 84              LB6AE	CMPB	,X	* COMPARE LENGTH PARAMETER TO LENGTH OF
2369 ee39 23 03              	BLS	LB6B5	* STRING AND BRANCH IF LENGTH OF STRING
2370                         *		 >= LENGTH PARAMETER
2371 ee3b e6 84              	LDB	,X	USE LENGTH OF STRING OTHERWISE
2372 ee3d 4f                 	CLRA		CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
2373 ee3e 34 06              LB6B5	PSHS	B,A	PUSH PARAMETERS ONTO STACK
2374 ee40 bd ec 98           	JSR	LB50F	RESERVE ACCB BYTES IN THE STRING SPACE
2375 ee43 9e 4d              	LDX	V4D	POINT X TO STRING DESCRIPTOR
2376 ee45 8d 9b              	BSR	LB659	GET ADDRESS OF OLD STRING (X=ADDRESS)
2377 ee47 35 04              	PULS	B	* PULL STRING POINTER OFFSET OFF OF THE STACK
2378 ee49 3a                 	ABX		* AND ADD IT TO STRING ADDRESS
2379 ee4a 35 04              	PULS	B	PULL LENGTH PARAMETER OFF OF THE STACK
2380 ee4c bd ed ce           	JSR	LB645	MOVE ACCB BYTES FROM (X) TO [FRESPC]
2381 ee4f 20 d5              	BRA	LB69D	PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
2382                         
2383                         * RIGHT$
2384 ee51 8d 2b              RIGHT	BSR	LB6F5	GET ARGUMENTS FROM STACK
2385 ee53 a0 84              	SUBA	,X	ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
2386 ee55 40                 	NEGA		NOW ACCA = LENGTH OF OLD STRING
2387 ee56 20 df              	BRA	LB6AE	PUT NEW STRING IN THE STRING SPACE
2388                         
2389                         * MID$
2390 ee58 c6 ff              MID	LDB	#$FF	* GET DEFAULT VALUE OF LENGTH AND
2391 ee5a d7 53              	STB	FPA0+3	* SAVE IT IN FPA0
2392 ee5c 9d 82              	JSR	GETCCH	GET CURRENT CHARACTER FROM BASIC
2393 ee5e 81 29              	CMPA	#')	ARGUMENT DELIMITER?
2394 ee60 27 05              	BEQ	LB6DE	YES - NO LENGTH PARAMETER GIVEN
2395 ee62 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
2396 ee65 8d 2d              	BSR	LB70B	EVALUATE NUMERIC EXPRESSION (LENGTH)
2397 ee67 8d 15              LB6DE	BSR	LB6F5	GET ARGUMENTS FROM STACK
2398 ee69 27 24              	BEQ	LB706	FC' ERROR IF NULL STRING
2399 ee6b 5f                 	CLRB		CLEAR LENGTH COUNTER (DEFAULT VALUE)
2400 ee6c 4a                 	DECA		*SUOTRACT ONE FROM POSITION PARAMETER (THESE
2401 ee6d a1 84              	CMPA	,X	*ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
2402                         *		 *AND COMPARE IT TO LENGTH OF OLD STRING
2403 ee6f 24 cd              	BCC	LB6B5	IF POSITION > LENGTH OF OLD STRING, THEN NEW
2404                         *		 STRING WILL BE A NULL STRING
2405 ee71 1f 89              	TFR	A,B	SAVE ABSOLUTE POSITION PARAMETER IN ACCB
2406 ee73 e0 84              	SUBB	,X	ACCB=POSITION-LENGTH OF OLD STRING
2407 ee75 50                 	NEGB		NOW ACCB=LENGTH OF OLDSTRING-POSITION
2408 ee76 d1 53              	CMPB	FPA0+3	*IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
2409 ee78 23 c4              	BLS	LB6B5	*POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
2410                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
2411                         * INSTEAD OF THE LENGTH PARAMETER
2412 ee7a d6 53              	LDB	FPA0+3	GET LENGTH OF NEW STRING
2413 ee7c 20 c0              	BRA	LB6B5	PUT NEW STRING IN STRING SPACE
2414                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
2415                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
2416 ee7e bd e9 f5           LB6F5	JSR	LB267	SYNTAX CHECK FOR A ")"
2417 ee81 ee e4              	LDU	,S	LOAD THE RETURN ADDRESS INTO U REGISTER
2418 ee83 ae 65              	LDX	5,S	* GET ADDRESS OF STRING AND
2419 ee85 9f 4d              	STX	V4D	* SAVE IT IN V4D
2420 ee87 a6 64              	LDA	4,S	= PUT LENGTH OF STRING IN
2421 ee89 e6 64              	LDB	4,S	= BOTH ACCA AND ACCB
2422 ee8b 32 67              	LEAS	7,S	REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
2423 ee8d 1f 35              	TFR	U,PC	JUMP TO ADDRESS IN U REGISTER
2424 ee8f 7e eb d3           LB706	JMP	LB44A	ILLEGAL FUNCTION CALL'
2425                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
2426                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
2427 ee92 9d 7c              LB709	JSR	GETNCH	GET NEXT BASIC INPUT CHARACTER
2428 ee94 bd e8 cf           LB70B	JSR	LB141	EVALUATE A NUMERIC EXPRESSION
2429 ee97 bd eb 72           LB70E	JSR	LB3E9	CONVERT FPA0 TO INTEGER IN ACCD
2430 ee9a 4d                 	TSTA		TEST MS BYTE OF INTEGER
2431 ee9b 26 f2              	BNE	LB706	FC' ERROR IF EXPRESSION > 255
2432 ee9d 0e 82              	JMP	GETCCH	GET CURRENT INPUT CHARACTER FROM BASIC
2433                         
2434                         * VAL
2435 ee9f bd ee 0f           VAL	JSR	LB686	POINT X TO STRING ADDRESS
2436 eea2 10 27 02 de        	LBEQ	LBA39	IF NULL STRING SET FPA0
2437 eea6 de 83              	LDU	CHARAD	SAVE INPUT POINTER IN REGISTER U
2438 eea8 9f 83              	STX	CHARAD	POINT INPUT POINTER TO ADDRESS OF STRING
2439 eeaa 3a                 	ABX	MOVE POINTER TO END OF STRING TERMINATOR
2440 eeab a6 84              	LDA	,X	GET LAST BYTE OF STRING
2441 eead 34 52              	PSHS	U,X,A	SAVE INPUT POINTER, STRING TERMINATOR
2442                         *	ADDRESS AND CHARACTER
2443 eeaf 6f 84              	CLR	,X	CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
2444 eeb1 9d 82              	JSR	GETCCH	GET CURRENT CHARACTER FROM BASIC
2445 eeb3 bd f4 5d           	JSR	LBD12	CONVERT AN ASCII STRING TO FLOATING POINT
2446 eeb6 35 52              	PULS	A,X,U	RESTORE CHARACTERS AND POINTERS
2447 eeb8 a7 84              	STA	,X	REPLACE STRING TERMINATOR
2448 eeba df 83              	STU	CHARAD	RESTORE INPUT CHARACTER
2449 eebc 39                 	RTS
2450                         
2451 eebd 8d 07              LB734	BSR	LB73D	* EVALUATE AN EXPRESSION, RETURN
2452 eebf 9f 2b              	STX	BINVAL	* THE VALUE IN X; STORE IT IN BINVAL
2453 eec1 bd e9 fb           LB738	JSR	LB26D	SYNTAX CHECK FOR A COMMA
2454 eec4 20 ce              	BRA	LB70B	EVALUATE EXPRESSION IN RANGE 0 <= X < 256
2455                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
2456                         
2457 eec6 bd e8 cf           LB73D	JSR	LB141	EVALUATE NUMERIC EXPRESSION
2458 eec9 96 54              LB740	LDA	FP0SGN	GET SIGN OF FPA0 MANTISSA
2459 eecb 2b c2              	BMI	LB706	ILLEGAL FUNCTION CALL' IF NEGATIVE
2460 eecd 96 4f              	LDA	FP0EXP	GET EXPONENT OF FPA0
2461 eecf 81 90              	CMPA	#$90	COMPARE TO LARGEST POSITIVE INTEGER
2462 eed1 22 bc              	BHI	LB706	ILLEGAL FUNCTION CALL' IF TOO LARGE
2463 eed3 bd f4 13           	JSR	LBCC8	SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
2464 eed6 9e 52              	LDX	FPA0+2	LOAD X WITH LOWER TWO BYTES OF FPA0
2465 eed8 39                 	RTS
2466                         
2467                         * PEEK
2468 eed9 8d ee              PEEK	BSR	LB740	CONVERT FPA0 TO INTEGER IN REGISTER X
2469 eedb e6 84              	LDB	,X	GET THE VALUE BEING 'PEEK'ED
2470 eedd 7e ec 7c           	JMP	LB4F3	CONVERT ACCB INTO A FP NUMBER
2471                         
2472                         * POKE
2473 eee0 8d db              POKE	BSR	LB734	EVALUATE 2 EXPRESSIONS
2474 eee2 9e 2b              	LDX	BINVAL	GET THE ADDRESS TO BE 'POKE'ED
2475 eee4 e7 84              	STB	,X	STORE THE DATA IN THAT ADDRESS
2476 eee6 39                 	RTS
2477                         
2478                         
2479                         * LIST
2480 eee7 34 01              LIST	PSHS	CC	SAVE ZERO FLAG ON STACK
2481 eee9 bd e7 19           	JSR	LAF67	CONVERT DECIMAL LINE NUMBER TO BINARY
2482 eeec bd e4 a7           	JSR	LAD01	* FIND RAM ADDRESS OF THAT LINE NUMBER AND
2483 eeef 9f 66              	STX	LSTTXT	* SAVE IT IN LSTTXT
2484 eef1 35 01              	PULS	CC	GET ZERO FLAG FROM STACK
2485 eef3 27 12              	BEQ	LB784	BRANCH IF END OF LINE
2486 eef5 9d 82              	JSR	GETCCH	GET CURRENT CHARACTER FROM BASIC
2487 eef7 27 13              	BEQ	LB789	BRANCH IF END OF LINE
2488 eef9 81 a7              	CMPA	#TOK_MINUS	MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
2489 eefb 26 09              	BNE	LB783	NO - RETURN
2490 eefd 9d 7c              	JSR	GETNCH	GET NEXT CHARACTER FROM BASIC
2491 eeff 27 06              	BEQ	LB784	BRANCH IF END OF LINE
2492 ef01 bd e7 19           	JSR	LAF67	GET ENDING LINE NUMBER
2493 ef04 27 06              	BEQ	LB789	BRANCH IF LEGAL LINE NUMBER
2494 ef06 39                 LB783 RTS
2495                         * LIST THE ENTIRE PROGRAM
2496 ef07 ce ff ff           LB784	LDU	#$FFFF	* SET THE DEFAULT ENDING LINE NUMBER
2497 ef0a df 2b              	STU	BINVAL	* TO $FFFF
2498 ef0c 32 62              LB789	LEAS	2,S	PURGE RETURN ADDRESS FROM THE STACK
2499 ef0e 9e 66              	LDX	LSTTXT	POINT X TO STARTING LINE ADDRESS
2500 ef10 bd f0 ab           LB78D	JSR	LB95C	MOVE CURSOR TO START OF A NEW LINE
2501 ef13 bd e1 9c           	JSR	LA549	CHECK FOR A BREAK OR PAUSE
2502 ef16 ec 84              	LDD	,X	GET ADDRESS OF NEXT BASIC LINE
2503 ef18 26 03              	BNE	LB79F	BRANCH IF NOT END OF PROGRAM
2504                         LB797
2505 ef1a 7e e4 27           	JMP	LAC73	RETURN TO BASIC�S MAIN INPUT LOOP
2506 ef1d 9f 66              LB79F	STX	LSTTXT	SAVE NEW STARTING LINE ADDRESS
2507 ef1f ec 02              	LDD	2,X	* GET THE LINE NUMBER OF THIS LINE AND
2508 ef21 10 93 2b           	CMPD	BINVAL	* COMPARE IT TO ENDING LINE NUMBER
2509 ef24 22 f4              	BHI	LB797	EXIT IF LINE NUMBER > ENDING LINE NUMBER
2510 ef26 bd f5 17           	JSR	LBDCC	PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
2511 ef29 bd f0 f7           	JSR	LB9AC	SEND A SPACE TO CONSOLE OUT
2512 ef2c 9e 66              	LDX	LSTTXT	GET RAM ADDRESS OF THIS LINE
2513 ef2e 8d 10              	BSR	LB7C2	UNCRUNCH A LINE
2514 ef30 ae 9f 00 66        	LDX	[LSTTXT]	POINT X TO START OF NEXT LINE
2515 ef34 ce 00 f4           	LDU	#LINBUF+1	POINT U TO BUFFER FULL OF UNCRUNCHED LINE
2516 ef37 a6 c0              LB7B9	LDA	,U+	GET A BYTE FROM THE BUFFER
2517 ef39 27 d5              	BEQ	LB78D	BRANCH IF END OF BUFFER
2518 ef3b bd f0 fc           	JSR	LB9B1	SEND CHARACTER TO CONSOLE OUT
2519 ef3e 20 f7              	BRA	LB7B9	GET ANOTHER CHARACTER
2520                         
2521                         * UNCRUNCH A LINE INTO BASIC�S LINE INPUT BUFFER
2522 ef40 30 04              LB7C2	LEAX	4,X	MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
2523 ef42 10 8e 00 f4        	LDY	#LINBUF+1	UNCRUNCH LINE INTO LINE INPUT BUFFER
2524 ef46 a6 80              LB7CB	LDA	,X+	GET A CHARACTER
2525 ef48 27 51              	BEQ	LB820	BRANCH IF END OF LINE
2526 ef4a 2b 15              	BMI	LB7E6	BRANCH IF IT'S A TOKEN
2527 ef4c 81 3a              	CMPA	#':	CHECK FOR END OF SUB LINE
2528 ef4e 26 0d              	BNE	LB7E2	BRNCH IF NOT END OF SUB LINE
2529 ef50 e6 84              	LDB	,X	GET CHARACTER FOLLOWING COLON
2530 ef52 c1 84              	CMPB	#TOK_ELSE	TOKEN FOR ELSE?
2531 ef54 27 f0              	BEQ	LB7CB	YES - DON'T PUT IT IN BUFFER
2532 ef56 c1 83              	CMPB	#TOK_SNGL_Q	TOKEN FOR REMARK?
2533 ef58 27 ec              	BEQ	LB7CB	YES - DON'T PUT IT IN BUFFER
2534 ef5a 8c                 	FCB	SKP2	SKIP TWO BYTES
2535 ef5b 86 21              LB7E0	LDA	#'!	EXCLAMATION POINT
2536 ef5d 8d 30              LB7E2	BSR	LB814	PUT CHARACTER IN BUFFER
2537 ef5f 20 e5              	BRA	LB7CB	GET ANOTHER CHARACTER
2538                         
2539 ef61 ce e0 e9           LB7E6	LDU	#COMVEC-10	FIRST DO COMMANDS
2540 ef64 81 ff              	CMPA	#$FF	CHECK FOR SECONDARY TOKEN
2541 ef66 26 04              	BNE	LB7F1	BRANCH IF NON SECONDARY TOKEN
2542 ef68 a6 80              	LDA	,X+	GET SECONDARY TOKEN
2543 ef6a 33 45              	LEAU	5,U	BUMP IT UP TO SECONDARY FUNCTIONS
2544 ef6c 84 7f              LB7F1	ANDA	#$7F	MASK OFF BIT 7 OF TOKEN
2545 ef6e 33 4a              LB7F3	LEAU	10,U	MOVE TO NEXT COMMAND TABLE
2546 ef70 6d c4              	TST	,U	IS THIS TABLE ENABLED?
2547 ef72 27 e7              	BEQ	LB7E0	NO - ILLEGAL TOKEN
2548 ef74 a0 c4              	SUBA	,U	SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
2549 ef76 2a f6              	BPL	LB7F3	BRANCH IF TOKEN NOT IN THIS TABLE
2550 ef78 ab c4              	ADDA	,U	RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
2551 ef7a ee 41              	LDU	1,U	POINT U TO COMMAND DICTIONARY TABLE
2552 ef7c 4a                 LB801	DECA		DECREMENT TOKEN NUMBER
2553 ef7d 2b 06              	BMI	LB80A	BRANCH IF THIS IS THE CORRECT TOKEN
2554                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
2555 ef7f 6d c0              LB804	TST	,U+	GRAB A BYTE
2556 ef81 2a fc              	BPL	LB804	BRANCH IF BIT 7 NOT SET
2557 ef83 20 f7              	BRA	LB801	GO SEE IF THIS IS THE CORRECT TOKEN
2558 ef85 a6 c4              LB80A	LDA	,U	GET A CHARACTER FROM DICTIONARY TABLE
2559 ef87 8d 06              	BSR	LB814	PUT CHARACTER IN BUFFER
2560 ef89 6d c0              	TST	,U+	CHECK FOR START OF NEXT TOKEN
2561 ef8b 2a f8              	BPL	LB80A	BRANCH IF NOT DONE WITH THIS TOKEN
2562 ef8d 20 b7              	BRA	LB7CB	GO GET ANOTHER CHARACTER
2563 ef8f 10 8c 01 ed        LB814	CMPY #LINBUF+LBUFMX TEST FOR END OF LINE INPUT BUFFER
2564 ef93 24 06              	BCC	LB820	BRANCH IF AT END OF BUFFER
2565 ef95 84 7f              	ANDA	#$7F	MASK OFF BIT 7
2566 ef97 a7 a0              	STA	,Y+	* SAVE CHARACTER IN BUFFER AND
2567 ef99 6f a4              	CLR	,Y	* CLEAR NEXT CHARACTER SLOT IN BUFFER
2568 ef9b 39                 LB820	RTS
2569                         *
2570                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
2571                         * POINTING TO INTO THE LINE INPUT BUFFER
2572                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
2573                         *
2574 ef9c 9e 83              LB821	LDX	CHARAD	GET BASIC'S INPUT POINTER ADDRESS
2575 ef9e ce 00 f3           	LDU	#LINBUF	POINT X TO LINE INPUT BUFFER
2576 efa1 0f 43              LB829	CLR	V43	CLEAR ILLEGAL TOKEN FLAG
2577 efa3 0f 44              	CLR	V44	CLEAR DATA FLAG
2578 efa5 a6 80              LB82D	LDA	,X+	GET INPUT CHAR
2579 efa7 27 21              	BEQ	LB852	BRANCH IF END OF LINE
2580 efa9 0d 43              	TST	V43	* CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
2581 efab 27 0f              	BEQ	LB844	* PROCESSING AN ILLEGAL TOKEN
2582 efad bd eb 2b           	JSR	LB3A2	SET CARRY IF NOT UPPER CASE ALPHA
2583 efb0 24 18              	BCC	LB852	BRANCH IF UPPER CASE ALPHA
2584 efb2 81 30              	CMPA	#'0	* DON�T CRUNCH ASCII NUMERIC CHARACTERS
2585 efb4 25 04              	BLO	LB842	* BRANCH IF NOT NUMERIC
2586 efb6 81 39              	CMPA	#'9	*
2587 efb8 23 10              	BLS	LB852	* BRANCH IF NUMERIC
2588                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
2589 efba 0f 43              LB842	CLR	V43	CLEAR ILLEGAL TOKEN FLAG
2590 efbc 81 20              LB844	CMPA	#SPACE	SPACE?
2591 efbe 27 0a              	BEQ	LB852	DO NOT REMOVE SPACES
2592 efc0 97 42              	STA	V42	SAVE INPUT CHARACTER AS SCAN DELIMITER
2593 efc2 81 22              	CMPA	#'"	CHECK FOR STRING DELIMITER
2594 efc4 27 38              	BEQ	LB886	BRANCH IF STRING
2595 efc6 0d 44              	TST	V44	* CHECK DATA FLAG AND BRANCH IF CLEAR
2596 efc8 27 19              	BEQ	LB86B	* DO NOT CRUNCH DATA
2597 efca a7 c0              LB852	STA	,U+	SAVE CHARACTER IN BUFFER
2598 efcc 27 06              	BEQ	LB85C	BRANCH IF END OF LINE
2599 efce 81 3a              	CMPA	#':	* CHECK FOR END OF SUBLINE
2600 efd0 27 cf              	BEQ	LB829	* AND RESET FLAGS IF END OF SUBLINE
2601 efd2 20 d1              LB85A	BRA	LB82D	GO GET ANOTHER CHARACTER
2602 efd4 6f c0              LB85C	CLR	,U+	* DOUBLE ZERO AT END OF LINE
2603 efd6 6f c0              	CLR	,U+	*
2604 efd8 1f 30              	TFR	U,D	SAVE ADDRESS OF END OF LINE IN ACCD
2605 efda 83 00 f1           	SUBD	#LINHDR	LENGTH OF LINE IN ACCD
2606 efdd 8e 00 f2           	LDX	#LINBUF-1	* SET THE INPUT POINTER TO ONE BEFORE
2607 efe0 9f 83              	STX	CHARAD	* THE START OF THE CRUNCHED LINE
2608 efe2 39                 	RTS	EXIT 'CRUNCH'
2609 efe3 81 3f              LB86B	CMPA	#'?	CHECK FOR "?" - PRINT ABBREVIATION
2610 efe5 26 04              	BNE	LB873	BRANCH IF NOT PRINT ABBREVIATION
2611 efe7 86 87              	LDA	#TOK_PRINT	* GET THE PRINT TOKEN AND SAVE IT
2612 efe9 20 df              	BRA	LB852	* IN BUFFER
2613 efeb 81 27              LB873	CMPA	#''	APOSTROPHE IS SAME AS REM
2614 efed 26 13              	BNE	LB88A	BRANCH IF NOT REMARK
2615 efef cc 3a 83           	LDD	#$3A00+TOK_SNGL_Q COLON, REM TOKEN
2616 eff2 ed c1              	STD	,U++	SAVE IN BUFFER
2617 eff4 0f 42              LB87C	CLR	V42	SET DELIMITER = 0 (END OF LINE)
2618 eff6 a6 80              LB87E	LDA	,X+	SCAN TILL WE MATCH [V42]
2619 eff8 27 d0              	BEQ	LB852	BRANCH IF END OF LINE
2620 effa 91 42              	CMPA	V42	DELIMITER?
2621 effc 27 cc              	BEQ	LB852	BRANCH OUT IF SO
2622 effe a7 c0              LB886	STA	,U+	DON'T CRUNCH REMARKS OR STRINGS
2623 f000 20 f4              	BRA	LB87E	GO GET MORE STRING OR REMARK
2624 f002 81 30              LB88A	CMPA	#'0	* LESS THAN ASCII ZERO?
2625 f004 25 04              	BCS	LB892	* BRANCH IF SO
2626 f006 81 3c              	CMPA	#';+1	= CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
2627 f008 25 c0              	BCS	LB852	= AND INSERT IN BUFFER IF SO
2628 f00a 30 1f              LB892	LEAX	-1,X	MOVE INPUT POINTER BACK ONE
2629 f00c 34 50              	PSHS	U,X	SAVE POINTERS TO INPUT STRING, OUTPUT STRING
2630 f00e 0f 41              	CLR	V41	TOKEN FLAG 0 = COMMAND, FF = SECONDARY
2631 f010 ce e0 e9           	LDU	#COMVEC-10	POINT U TO COMMAND INTERPRETATION
2632                         *		 TABLE FOR BASIC - 10
2633 f013 0f 42              LB89B	CLR	V42	INITIALIZE V42 AS TOKEN COUNTER
2634 f015 33 4a              LB89D	LEAU	10,U	MOVE TO NEXT COMMAND INTERPRETATION TABLE
2635 f017 a6 c4              	LDA	,U	GET NUMBER OF COMMANDS
2636 f019 27 31              	BEQ	LB8D4	GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
2637 f01b 10 ae 41           	LDY	1,U	POINT Y TO COMMAND DICTIONARY TABLE
2638 f01e ae e4              LB8A6	LDX	,S	GET POINTER TO INPUT STRING
2639 f020 e6 a0              LB8A8	LDB	,Y+	GET A BYTE FROM DICTIONARY TABLE
2640 f022 e0 80              	SUBB	,X+	SUBTRACT INPUT CHARACTER
2641 f024 27 fa              	BEQ	LB8A8	LOOP IF SAME
2642 f026 c1 80              	CMPB	#$80	LAST CHAR IN RESERVED WORD TABLE HAD
2643                         *		 BIT 7 SET, SO IF WE HAVE $80 HERE
2644                         *		 THEN IT IS A GOOD COMPARE
2645 f028 26 38              	BNE	LB8EA	BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
2646 f02a 32 62              	LEAS	2,S	DELETE OLD INPUT POINTER FROM STACK
2647 f02c 35 40              	PULS	U	GET POINTER TO OUTPUT STRING
2648 f02e da 42              	ORB	V42	OR IN THE TABLE POSITION TO MAKE THE TOKEN
2649                         *		 - NOTE THAT B ALREADY HAD $80 IN IT -
2650 f030 96 41              	LDA	V41	* CHECK TOKEN FLAG AND BRANCH
2651 f032 26 06              	BNE	LB8C2	* IF SECONDARY
2652 f034 c1 84              	CMPB	#TOK_ELSE	IS IT ELSE TOKEN?
2653 f036 26 06              	BNE	LB8C6	NO
2654 f038 86 3a              	LDA	#':	PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
2655 f03a ed c1              LB8C2	STD	,U++	SECONDARY TOKENS PRECEEDED BY $FF
2656 f03c 20 94              	BRA	LB85A	GO PROCESS MORE INPUT CHARACTERS
2657 f03e e7 c0              LB8C6	STB	,U+	SAVE THIS TOKEN
2658 f040 c1 86              	CMPB	#TOK_DATA	DATA TOKEN?
2659 f042 26 02              	BNE	LB8CE	NO
2660 f044 0c 44              	INC	V44	SET DATA FLAG
2661 f046 c1 82              LB8CE	CMPB	#TOK_REM	REM TOKEN?
2662 f048 27 aa              	BEQ	LB87C	YES
2663 f04a 20 86              LB8D2	BRA	LB85A	GO PROCESS MORE INPUT CHARACTERS
2664                         * CHECK FOR A SECONDARY TOKEN
2665 f04c ce e0 ee           LB8D4	LDU	#COMVEC-5	NOW DO SECONDARY FUNCTIONS
2666 f04f 03 41              	COM	V41	TOGGLE THE TOKEN FLAG
2667 f051 26 c0              	BNE	LB89B	BRANCH IF NOW CHECKING SECONDARY COMMANDS
2668                         
2669                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
2670                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
2671 f053 35 50              	PULS	X,U	RESTORE INPUT AND OUTPUT POINTERS
2672 f055 a6 80              	LDA	,X+	* MOVE THE FIRST CHARACTER OF AN
2673 f057 a7 c0              	STA	,U+	* ILLEGAL TOKEN
2674 f059 bd eb 2b           	JSR	LB3A2	SET CARRY IF NOT ALPHA
2675 f05c 25 ec              	BCS	LB8D2	BRANCH IF NOT ALPHA
2676 f05e 03 43              	COM	V43	SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
2677 f060 20 e8              	BRA	LB8D2	PROCESS MORE INPUT CHARACTERS
2678 f062 0c 42              LB8EA	INC	V42	INCREMENT TOKEN COUNTER
2679 f064 4a                 	DECA		DECR COMMAND COUNTER
2680 f065 27 ae              	BEQ	LB89D	GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
2681 f067 31 3f              	LEAY	-1,Y	MOVE POINTER BACK ONE
2682 f069 e6 a0              LB8F1	LDB	,Y+	* GET TO NEXT
2683 f06b 2a fc              	BPL	LB8F1	* RESERVED WORD
2684 f06d 20 af              	BRA	LB8A6	GO SEE IF THIS WORD IS A MATCH
2685                         
2686                         * PRINT
2687 f06f 27 36              PRINT	BEQ	LB958	BRANCH IF NO ARGUMENT
2688 f071 8d 01              	BSR	LB8FE	CHECK FOR ALL PRINT OPTIONS
2689 f073 39                 	RTS
2690                         LB8FE
2691 f074 27 3e              LB91B	BEQ	LB965	RETURN IF END OF LINE
2692 f076 81 9f              LB91D	CMPA	#TOK_TAB	TOKEN FOR TAB( ?
2693 f078 27 53              	BEQ	LB97E	YES
2694 f07a 81 2c              	CMPA	#',	COMMA?
2695 f07c 27 37              	BEQ	LB966	YES - ADVANCE TO NEXT TAB FIELD
2696 f07e 81 3b              	CMPA	#';	SEMICOLON?
2697 f080 27 60              	BEQ	LB997	YES - DO NOT ADVANCE CURSOR
2698 f082 bd e8 e4           	JSR	LB156	EVALUATE EXPRESSION
2699 f085 96 06              	LDA	VALTYP	* GET VARIABLE TYPE AND
2700 f087 34 02              	PSHS	A	* SAVE IT ON THE STACK
2701 f089 26 06              	BNE	LB938	BRANCH IF STRING VARIABLE
2702 f08b bd f5 24           	JSR	LBDD9	CONVERT FP NUMBER TO AN ASCII STRING
2703 f08e bd ec 9f           	JSR	LB516	PARSE A STRING FROM (X-1) AND PUT
2704                         *		 DESCRIPTOR ON STRING STACK
2705 f091 8d 57              LB938	BSR	LB99F	PRINT STRING POINTED TO BY X
2706 f093 35 04              	PULS	B	GET VARIABLE TYPE BACK
2707 f095 bd e1 35           	JSR	LA35F	SET UP TAB WIDTH ZONE, ETC
2708 f098 5d                 LB949	TSTB		CHECK CURRENT PRINT POSITION
2709 f099 26 08              	BNE	LB954	BRANCH IF NOT AT START OF LINE
2710 f09b 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
2711 f09d 81 2c              	CMPA	#',	COMMA?
2712 f09f 27 14              	BEQ	LB966	SKIP TO NEXT TAB FIELD
2713 f0a1 8d 54              	BSR	LB9AC	SEND A SPACE TO CONSOLE OUT
2714 f0a3 9d 82              LB954	JSR	GETCCH	GET CURRENT INPUT CHARACTER
2715 f0a5 26 cf              	BNE	LB91D	BRANCH IF NOT END OF LINE
2716 f0a7 86 0d              LB958	LDA	#CR	* SEND A CR TO
2717 f0a9 20 51              	BRA	LB9B1	* CONSOLE OUT
2718 f0ab bd e1 35           LB95C	JSR	LA35F	SET UP TAB WIDTH, ZONE ETC
2719 f0ae 27 f7              	BEQ	LB958	BRANCH IF WIDTH = ZERO
2720 f0b0 96 6c              	LDA	DEVPOS	GET PRINT POSITION
2721 f0b2 26 f3              	BNE	LB958	BRANCH IF NOT AT START OF LINE
2722 f0b4 39                 LB965	RTS
2723                         * SKIP TO NEXT TAB FIELD
2724 f0b5 bd e1 35           LB966	JSR	LA35F	SET UP TAB WIDTH, ZONE ETC
2725 f0b8 27 0a              	BEQ	LB975	BRANCH IF LINE WIDTH = 0 (CASSETTE)
2726 f0ba d6 6c              	LDB	DEVPOS	GET CURRENT POSITION
2727 f0bc d1 6b              	CMPB	DEVLCF	COMPARE TO LAST TAB ZONE
2728 f0be 25 06              	BCS	LB977	BRANCH IF < LAST TAB ZONE
2729 f0c0 8d e5              	BSR	LB958	SEND A CARRIAGE RETURN TO CONSOLE OUT
2730 f0c2 20 1e              	BRA	LB997	GET MORE DATA
2731 f0c4 d6 6c              LB975	LDB	DEVPOS	*
2732 f0c6 d0 6a              LB977	SUBB	DEVCFW	* SUBTRACT TAB FIELD WIDTH FROM CURRENT
2733 f0c8 24 fc              	BCC	LB977	* POSITION UNTIL CARRY SET - NEGATING THE
2734 f0ca 50                 	NEGB		* REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
2735                         *	* TAB ZONE IN ACCB
2736 f0cb 20 10              	BRA	LB98E	GO ADVANCE TO NEXT TAB ZONE
2737                         
2738                         * PRINT TAB(
2739 f0cd bd ee 92           LB97E	JSR	LB709	EVALUATE EXPRESSION - RETURN VALUE IN B
2740 f0d0 81 29              	CMPA	#')	* 'SYNTAX' ERROR IF NOT ')'
2741 f0d2 10 26 f9 2f        	LBNE	LB277	*
2742 f0d6 bd e1 35           	JSR	LA35F	SET UP TAB WIDTH, ZONE ETC
2743 f0d9 d0 6c              	SUBB	DEVPOS	GET DIFFERENCE OF PRINT POSITION & TAB POSITION
2744 f0db 23 05              	BLS	LB997	BRANCH IF TAB POSITION < CURRENT POSITION
2745                         LB98E
2746 f0dd 8d 18              LB992	BSR	LB9AC	SEND A SPACE TO CONSOLE OUT
2747 f0df 5a                 	DECB		DECREMENT DIFFERENCE COUNT
2748 f0e0 26 fb              	BNE	LB992	BRANCH UNTIL CURRENT POSITION = TAB POSITION
2749 f0e2 9d 7c              LB997	JSR	GETNCH	GET NEXT CHARACTER FROM BASIC
2750 f0e4 7e f0 74           	JMP	LB91B	LOOK FOR MORE PRINT DATA
2751                         * COPY A STRING FROM (X) TO CONSOLE OUT
2752 f0e7 bd ec a1           LB99C	JSR	LB518	PARSE A STRING FROM X AND PUT
2753                         *	DESCRIPTOR ON STRING STACK
2754 f0ea bd ed e0           LB99F	JSR	LB657	GET LENGTH OF STRING AND REMOVE
2755                         *	DESCRIPTOR FROM STRING STACK
2756 f0ed 5c                 	INCB		COMPENSATE FOR DECB BELOW
2757 f0ee 5a                 LB9A3	DECB		DECREMENT COUNTER
2758 f0ef 27 c3              	BEQ	LB965	EXIT ROUTINE
2759 f0f1 a6 80              	LDA	,X+	GET A CHARACTER FROM X
2760 f0f3 8d 07              	BSR	LB9B1	SEND TO CONSOLE OUT
2761 f0f5 20 f7              	BRA	LB9A3	KEEP LOOPING
2762 f0f7 86 20              LB9AC	LDA	#SPACE	SPACE TO CONSOLE OUT
2763 f0f9 8c                 	FCB	SKP2	SKIP NEXT TWO BYTES
2764 f0fa 86 3f              LB9AF	LDA	#'?	QUESTION MARK TO CONSOLE OUT
2765 f0fc 7e e0 14           LB9B1	JMP	PUTCHR	JUMP TO CONSOLE OUT
2766                         
2767                         * FLOATING POINT MATH PACKAGE
2768                         
2769                         * ADD .5 TO FPA0
2770 f0ff 8e f6 0b           LB9B4	LDX	#LBEC0	FLOATING POINT CONSTANT (.5)
2771 f102 20 09              	BRA	LB9C2	ADD .5 TO FPA0
2772                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
2773                         * TO BY (X), LEAVE RESULT IN FPA0
2774 f104 bd f2 7a           LB9B9	JSR	LBB2F	COPY PACKED FP DATA FROM (X) TO FPA1
2775                         
2776                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
2777                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
2778 f107 03 54              LB9BC	COM	FP0SGN	CHANGE MANTISSA SIGN OF FPA0
2779 f109 03 62              	COM	RESSGN	REVERSE RESULT SIGN FLAG
2780 f10b 20 03              	BRA	LB9C5	GO ADD FPA1 AND FPA0
2781                         * ADD FP NUMBER POINTED TO BY
2782                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
2783 f10d bd f2 7a           LB9C2	JSR	LBB2F	UNPACK PACKED FP DATA FROM (X) TO
2784                         *	FPA1; RETURN EXPONENT OF FPA1 IN ACCA
2785                         
2786                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
2787                         
2788 f110 5d                 LB9C5	TSTB		CHECK EXPONENT OF FPA0
2789 f111 10 27 02 80        	LBEQ	LBC4A	COPY FPA1 TO FPA0 IF FPA0 =
2790 f115 8e 00 5c           	LDX	#FP1EXP	POINT X TO FPA1
2791 f118 1f 89              LB9CD	TFR	A,B	PUT EXPONENT OF FPA1 INTO ACCB
2792 f11a 5d                 	TSTB		CHECK EXPONENT
2793 f11b 27 6c              	BEQ	LBA3E	RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
2794 f11d d0 4f              	SUBB	FP0EXP	SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
2795 f11f 27 69              	BEQ	LBA3F	BRANCH IF EXPONENTS ARE EQUAL
2796 f121 25 0a              	BCS	LB9E2	BRANCH IF EXPONENT FPA0 > FPA1
2797 f123 97 4f              	STA	FP0EXP	REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
2798 f125 96 61              	LDA	FP1SGN	* REPLACE FPA0 MANTISSA SIGN
2799 f127 97 54              	STA	FP0SGN	* WITH FPA1 MANTISSA SIGN
2800 f129 8e 00 4f           	LDX	#FP0EXP	POINT X TO FPA0
2801 f12c 50                 	NEGB		NEGATE DIFFERENCE OF EXPONENTS
2802 f12d c1 f8              LB9E2	CMPB	#-8	TEST DIFFERENCE OF EXPONENTS
2803 f12f 2f 59              	BLE	LBA3F	BRANCH IF DIFFERENCE OF EXPONENTS <= 8
2804 f131 4f                 	CLRA		CLEAR OVERFLOW BYTE
2805 f132 64 01              	LSR	1,X	SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
2806 f134 bd f2 05           	JSR	LBABA	GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
2807 f137 d6 62              LB9EC	LDB	RESSGN	GET SIGN FLAG
2808 f139 2a 0b              	BPL	LB9FB	BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
2809 f13b 63 01              	COM	1,X	* COMPLEMENT MANTISSA POINTED
2810 f13d 63 02              	COM	2,X	* TO BY (X) THE
2811 f13f 63 03              	COM	3,X	* ADCA BELOW WILL
2812 f141 63 04              	COM	4,X	* CONVERT THIS OPERATION
2813 f143 43                 	COMA		* INTO A NEG (MANTISSA)
2814 f144 89 00              	ADCA	#0	ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
2815                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
2816                         *
2817                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
2818 f146 97 63              LB9FB	STA	FPSBYT	SAVE FPA SUB BYTE
2819 f148 96 53              	LDA	FPA0+3	* ADD LS BYTE
2820 f14a 99 60              	ADCA	FPA1+3	* OF MANTISSA
2821 f14c 97 53              	STA	FPA0+3	SAVE IN FPA0 LSB
2822 f14e 96 52              	LDA	FPA0+2	* ADD NEXT BYTE
2823 f150 99 5f              	ADCA	FPA1+2	* OF MANTISSA
2824 f152 97 52              	STA	FPA0+2	SAVE IN FPA0
2825 f154 96 51              	LDA	FPA0+1	* ADD NEXT BYTE
2826 f156 99 5e              	ADCA	FPA1+1	* OF MANTISSA
2827 f158 97 51              	STA	FPA0+1	SAVE IN FPA0
2828 f15a 96 50              	LDA	FPA0	* ADD MS BYTE
2829 f15c 99 5d              	ADCA	FPA1	* OF MANTISSA
2830 f15e 97 50              	STA	FPA0	SAVE IN FPA0
2831 f160 5d                 	TSTB	TEST SIGN FLAG
2832 f161 2a 44              	BPL	LBA5C	BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
2833 f163 25 02              LBA18	BCS	LBA1C	BRANCH IF POSITIVE MANTISSA
2834 f165 8d 5d              	BSR	LBA79	NEGATE FPA0 MANTISSA
2835                         
2836                         * NORMALIZE FPA0
2837 f167 5f                 LBA1C	CLRB		CLEAR TEMPORARY EXPONENT ACCUMULATOR
2838 f168 96 50              LBA1D	LDA	FPA0	TEST MSB OF MANTISSA
2839 f16a 26 2e              	BNE	LBA4F	BRANCH IF <> 0
2840 f16c 96 51              	LDA	FPA0+1	* IF THE MSB IS
2841 f16e 97 50              	STA	FPA0	* 0, THEN SHIFT THE
2842 f170 96 52              	LDA	FPA0+2	* MANTISSA A WHOLE BYTE
2843 f172 97 51              	STA	FPA0+1	* AT A TIME. THIS
2844 f174 96 53              	LDA	FPA0+3	* IS FASTER THAN ONE
2845 f176 97 52              	STA	FPA0+2	* BIT AT A TIME
2846 f178 96 63              	LDA	FPSBYT	* BUT USES MORE MEMORY.
2847 f17a 97 53              	STA	FPA0+3	* FPSBYT, THE CARRY IN
2848 f17c 0f 63              	CLR	FPSBYT	* BYTE, REPLACES THE MATISSA LSB.
2849 f17e cb 08              	ADDB	#8	SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
2850 f180 c1 28              	CMPB	#5*8	CHECK FOR 5 SHIFTS
2851 f182 2d e4              	BLT	LBA1D	BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
2852 f184 4f                 LBA39	CLRA		A ZERO EXPONENT = 0 FLOATING POINT
2853 f185 97 4f              LBA3A	STA	FP0EXP	ZERO OUT THE EXPONENT
2854 f187 97 54              	STA	FP0SGN	ZERO OUT THE MANTISSA SIGN
2855 f189 39                 LBA3E	RTS
2856 f18a 8d 6d              LBA3F	BSR	LBAAE	SHIFT FPA0 MANTISSA TO RIGHT
2857 f18c 5f                 	CLRB		CLEAR CARRY FLAG
2858 f18d 20 a8              	BRA	LB9EC
2859                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
2860                         * OF MATISSA MS BYTE = 1
2861 f18f 5c                 LBA44	INCB		ADD ONE TO EXPONENT ACCUMULATOR
2862 f190 08 63              	ASL	FPSBYT	SHIFT SUB BYTE ONE LEFT
2863 f192 09 53              	ROL	FPA0+3	SHIFT LS BYTE
2864 f194 09 52              	ROL	FPA0+2	SHIFT NS BYTE
2865 f196 09 51              	ROL	FPA0+1	SHIFT NS BYTE
2866 f198 09 50              	ROL	FPA0	SHIFT MS BYTE
2867 f19a 2a f3              LBA4F	BPL	LBA44	BRANCH IF NOT YET NORMALIZED
2868 f19c 96 4f              	LDA	FP0EXP	GET CURRENT EXPONENT
2869 f19e 34 04              	PSHS	B	SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
2870 f1a0 a0 e0              	SUBA	,S+	SUBTRACT ACCUMULATED EXPONENT MODIFIER
2871 f1a2 97 4f              	STA	FP0EXP	SAVE AS NEW EXPONENT
2872 f1a4 23 de              	BLS	LBA39	SET FPA0 = 0 IF THE NORMALIZATION CAUSED
2873                         *	MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
2874                         *	SIZE OF THE EXPONENT
2875 f1a6 8c                 	FCB	SKP2	SKIP 2 BYTES
2876 f1a7 25 08              LBA5C	BCS	LBA66	BRANCH IF MANTISSA OVERFLOW
2877 f1a9 08 63              	ASL	FPSBYT	SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
2878                         *		 FLAG (TRUNCATE THE REST OF SUB BYTE)
2879 f1ab 86 00              	LDA	#0	CLRA, BUT DO NOT CHANGE CARRY FLAG
2880 f1ad 97 63              	STA	FPSBYT	CLEAR THE SUB BYTE
2881 f1af 20 0c              	BRA	LBA72	GO ROUND-OFF RESULT
2882 f1b1 0c 4f              LBA66	INC	FP0EXP	INCREMENT EXPONENT - MULTIPLY BY 2
2883 f1b3 27 28              	BEQ	LBA92	OVERFLOW ERROR IF CARRY PAST $FF
2884 f1b5 06 50              	ROR	FPA0	* SHIFT MANTISSA
2885 f1b7 06 51              	ROR	FPA0+1	* ONE TO
2886 f1b9 06 52              	ROR	FPA0+2	* THE RIGHT -
2887 f1bb 06 53              	ROR	FPA0+3	* DIVIDE BY TWO
2888 f1bd 24 04              LBA72	BCC	LBA78	BRANCH IF NO ROUND-OFF NEEDED
2889 f1bf 8d 0d              	BSR	LBA83	ADD ONE TO MANTISSA - ROUND OFF
2890 f1c1 27 ee              	BEQ	LBA66	BRANCH iF OVERFLOW - MANTISSA = 0
2891 f1c3 39                 LBA78	RTS
2892                         * NEGATE FPA0 MANTISSA
2893 f1c4 03 54              LBA79	COM	FP0SGN	TOGGLE SIGN OF MANTISSA
2894 f1c6 03 50              LBA7B	COM	FPA0	* COMPLEMENT ALL 4 MANTISSA BYTES
2895 f1c8 03 51              	COM	FPA0+1	*
2896 f1ca 03 52              	COM	FPA0+2	*
2897 f1cc 03 53              	COM	FPA0+3	*
2898                         * ADD ONE TO FPA0 MANTISSA
2899 f1ce 9e 52              LBA83	LDX	FPA0+2	* GET BOTTOM 2 MANTISSA
2900 f1d0 30 01              	LEAX	1,X	* BYTES, ADD ONE TO
2901 f1d2 9f 52              	STX	FPA0+2	* THEM AND SAVE THEM
2902 f1d4 26 06              	BNE	LBA91	BRANCH IF NO OVERFLOW
2903 f1d6 9e 50              	LDX	FPA0	* IF OVERFLOW ADD ONE
2904 f1d8 30 01              	LEAX	1,X	* TO TOP 2 MANTISSA
2905 f1da 9f 50              	STX	FPA0	* BYTES AND SAVE THEM
2906 f1dc 39                 LBA91	RTS
2907 f1dd c6 0a              LBA92	LDB	#2*5	OV' OVERFLOW ERROR
2908 f1df 7e e4 08           	JMP	LAC46	PROCESS AN ERROR
2909 f1e2 8e 00 12           LBA97	LDX	#FPA2-1	POINT X TO FPA2
2910                         * SHIFT FPA POINTED TO BY (X) TO
2911                         * THE RIGHT -(B) TIMES. EXIT WITH
2912                         * ACCA CONTAINING DATA SHIFTED OUT
2913                         * TO THE RIGHT (SUB BYTE) AND THE DATA
2914                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
2915 f1e5 a6 04              LBA9A	LDA	4,X	GET LS BYTE OF MANTISSA (X)
2916 f1e7 97 63              	STA	FPSBYT	SAVE IN FPA SUB BYTE
2917 f1e9 a6 03              	LDA	3,X	* SHIFT THE NEXT THREE BYTES OF THE
2918 f1eb a7 04              	STA	4,X	* MANTISSA RIGHT ONE COMPLETE BYTE.
2919 f1ed a6 02              	LDA	2,X	*
2920 f1ef a7 03              	STA	3,X	*
2921 f1f1 a6 01              	LDA	1,X	*
2922 f1f3 a7 02              	STA	2,X	*
2923 f1f5 96 5b              	LDA	FPCARY	GET THE CARRY IN BYTE
2924 f1f7 a7 01              	STA	1,X	STORE AS THE MS MANTISSA BYTE OF (X)
2925 f1f9 cb 08              LBAAE	ADDB	#8	ADD 8 TO DIFFERENCE OF EXPONENTS
2926 f1fb 2f e8              	BLE	LBA9A	BRANCH IF EXPONENT DIFFERENCE < -8
2927 f1fd 96 63              	LDA	FPSBYT	GET FPA SUB BYTE
2928 f1ff c0 08              	SUBB	#8	CAST OUT THE 8 ADDED IN ABOVE
2929 f201 27 0c              	BEQ	LBAC4	BRANCH IF EXPONENT DIFFERENCE = 0
2930                         
2931                         
2932 f203 67 01              LBAB8	ASR	1,X	* SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
2933 f205 66 02              LBABA	ROR	2,X	*
2934 f207 66 03              	ROR	3,X	*
2935 f209 66 04              	ROR	4,X	*
2936 f20b 46                 	RORA		*
2937 f20c 5c                 	INCB		ADD ONE TO EXPONENT DIFFERENCE
2938 f20d 26 f4              	BNE	LBAB8	BRANCH IF EXPONENTS NOT =
2939 f20f 39                 LBAC4	RTS
2940 f210 81 00 00 00 00     LBAC5	FCB	$81,$00,$00,$00,$00 FLOATING POINT CONSTANT 1.0
2941                         
2942                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
2943                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
2944 f215 8d 63              LBACA	BSR	LBB2F	MOVE PACKED FPA FROM (X) TO FPA1
2945 f217 27 60              LBACC	BEQ	LBB2E	BRANCH IF EXPONENT OF FPA0 = 0
2946 f219 8d 78              	BSR	LBB48	CALCULATE EXPONENT OF PRODUCT
2947                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
2948                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
2949                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
2950                         * BE STORED IN VAB-VAE.
2951 f21b 86 00              LBAD0	LDA	#0	* ZERO OUT MANTISSA OF FPA2
2952 f21d 97 13              	STA	FPA2	*
2953 f21f 97 14              	STA	FPA2+1	*
2954 f221 97 15              	STA	FPA2+2	*
2955 f223 97 16              	STA	FPA2+3	*
2956 f225 d6 53              	LDB	FPA0+3	GET LS BYTE OF FPA0
2957 f227 8d 22              	BSR	LBB00	MULTIPLY BY FPA1
2958 f229 d6 63              	LDB	FPSBYT	* TEMPORARILY SAVE SUB BYTE 4
2959 f22b d7 8b              	STB	VAE	*
2960 f22d d6 52              	LDB	FPA0+2	GET NUMBER 3 MANTISSA BYTE OF FPA0
2961 f22f 8d 1a              	BSR	LBB00	MULTIPLY BY FPA1
2962 f231 d6 63              	LDB	FPSBYT	* TEMPORARILY SAVE SUB BYTE 3
2963 f233 d7 8a              	STB	VAD	*
2964 f235 d6 51              	LDB	FPA0+1	GET NUMBER 2 MANTISSA BYTE OF FPA0
2965 f237 8d 12              	BSR	LBB00	MULTIPLY BY FPA1
2966 f239 d6 63              	LDB	FPSBYT	* TEMPORARILY SAVE SUB BYTE 2
2967 f23b d7 89              	STB	VAC	*
2968 f23d d6 50              	LDB	FPA0	GET MS BYTE OF FPA0 MANTISSA
2969 f23f 8d 0c              	BSR	LBB02	MULTIPLY BY FPA1
2970 f241 d6 63              	LDB	FPSBYT	* TEMPORARILY SAVE SUB BYTE 1
2971 f243 d7 88              	STB	VAB	*
2972 f245 bd f3 56           	JSR	LBC0B	COPY MANTISSA FROM FPA2 TO FPA0
2973 f248 7e f1 67           	JMP	LBA1C	NORMALIZE FPA0
2974 f24b 27 95              LBB00	BEQ	LBA97	SHIFT FPA2 ONE BYTE TO RIGHT
2975 f24d 43                 LBB02	COMA		SET CARRY FLAG
2976                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
2977                         * ADD PRODUCT TO FPA2 MANTISSA
2978 f24e 96 13              LBB03	LDA	FPA2	GET FPA2 MS BYTE
2979 f250 56                 	RORB ROTATE CARRY FLAG INTO SHIFT COUNTER;
2980                         *	DATA BIT INTO CARRY
2981 f251 27 26              	BEQ	LBB2E	BRANCH WHEN 8 SHIFTS DONE
2982 f253 24 16              	BCC	LBB20	DO NOT ADD FPA1 IF DATA BIT = 0
2983 f255 96 16              	LDA	FPA2+3	* ADD MANTISSA LS BYTE
2984 f257 9b 60              	ADDA	FPA1+3	*
2985 f259 97 16              	STA	FPA2+3	*
2986 f25b 96 15              	LDA	FPA2+2	= ADD MANTISSA NUMBER 3 BYTE
2987 f25d 99 5f              	ADCA	FPA1+2	=
2988 f25f 97 15              	STA	FPA2+2	=
2989 f261 96 14              	LDA	FPA2+1	* ADD MANTISSA NUMBER 2 BYTE
2990 f263 99 5e              	ADCA	FPA1+1	*
2991 f265 97 14              	STA	FPA2+1	*
2992 f267 96 13              	LDA	FPA2	= ADD MANTISSA MS BYTE
2993 f269 99 5d              	ADCA	FPA1	=
2994 f26b 46                 LBB20	RORA * ROTATE CARRY INTO MS BYTE
2995 f26c 97 13              	STA	FPA2	*
2996 f26e 06 14              	ROR	FPA2+1	= ROTATE FPA2 ONE BIT TO THE RIGHT
2997 f270 06 15              	ROR	FPA2+2	=
2998 f272 06 16              	ROR	FPA2+3	=
2999 f274 06 63              	ROR	FPSBYT	=
3000 f276 4f                 	CLRA		CLEAR CARRY FLAG
3001 f277 20 d5              	BRA	LBB03	KEEP LOOPING
3002 f279 39                 LBB2E	RTS
3003                         * UNPACK A FP NUMBER FROM (X) TO FPA1
3004 f27a ec 01              LBB2F	LDD	1,X	GET TWO MSB BYTES OF MANTISSA FROM
3005                         *	FPA	POINTED TO BY X
3006 f27c 97 61              	STA	FP1SGN	SAVE PACKED MANTISSA SIGN BYTE
3007 f27e 8a 80              	ORA	#$80	FORCE BIT 7 OF MSB MANTISSA = 1
3008 f280 dd 5d              	STD	FPA1	SAVE 2 MSB BYTES IN FPA1
3009 f282 d6 61              	LDB	FP1SGN	* GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
3010 f284 d8 54              	EORB	FP0SGN	* SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
3011 f286 d7 62              	STB	RESSGN	* NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
3012                         *		 * MANTISSA SIGN BYTE
3013 f288 ec 03              	LDD	3,X	= GET 2 LSB BYTES OF MANTISSA
3014 f28a dd 5f              	STD	FPA1+2	= AND PUT IN FPA1
3015 f28c a6 84              	LDA	,X	* GET EXPONENT FROM (X) AND
3016 f28e 97 5c              	STA	FP1EXP	* PUT IN EXPONENT OF FPA1
3017 f290 d6 4f              	LDB	FP0EXP	GET EXPONENT OF FPA0
3018 f292 39                 	RTS
3019                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
3020                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
3021 f293 4d                 LBB48	TSTA		TEST EXPONENT OF FPA1
3022 f294 27 16              	BEQ	LBB61	PURGE RETURN ADDRESS & SET FPA0 = 0
3023 f296 9b 4f              	ADDA	FP0EXP	ADD FPA1 EXPONENT TO FPA0 EXPONENT
3024 f298 46                 	RORA		ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
3025 f299 49                 	ROLA		SET OVERFLOW FLAG
3026 f29a 28 10              	BVC	LBB61	BRANCH IF EXPONENT TOO LARGE OR SMALL
3027 f29c 8b 80              	ADDA	#$80	ADD $80 BIAS TO EXPONENT
3028 f29e 97 4f              	STA	FP0EXP	SAVE NEW EXPONENT
3029 f2a0 27 0c              	BEQ	LBB63	SET FPA0
3030 f2a2 96 62              	LDA	RESSGN	GET MANTISSA SIGN
3031 f2a4 97 54              	STA	FP0SGN	SAVE AS MANTISSA SIGN OF FPA0
3032 f2a6 39                 	RTS
3033                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
3034                         * = IS NEGATIVE THEN FPA0 = 0
3035 f2a7 96 54              LBB5C	LDA	FP0SGN	GET MANTISSA SIGN OF FPA0
3036 f2a9 43                 	COMA		CHANGE SIGN OF FPA0 MANTISSA
3037 f2aa 20 02              	BRA	LBB63
3038 f2ac 32 62              LBB61	LEAS	2,S	PURGE RETURN ADDRESS FROM STACK
3039 f2ae 10 2a fe d2        LBB63	LBPL	LBA39	ZERO FPA0 MANTISSA SIGN & EXPONENT
3040 f2b2 7e f1 dd           LBB67	JMP	LBA92	OV' OVERFLOW ERROR
3041                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
3042 f2b5 bd f3 aa           LBB6A	JSR	LBC5F	TRANSFER FPA0 TO FPA1
3043 f2b8 27 0d              	BEQ	LBB7C	BRANCH IF EXPONENT = 0
3044 f2ba 8b 02              	ADDA	#2	ADD 2 TO EXPONENT (TIMES 4)
3045 f2bc 25 f4              	BCS	LBB67	OV' ERROR IF EXPONENT > $FF
3046 f2be 0f 62              	CLR	RESSGN	CLEAR RESULT SIGN BYTE
3047 f2c0 bd f1 18           	JSR	LB9CD	ADD FPA1 TO FPA0 (TIMES 5)
3048 f2c3 0c 4f              	INC	FP0EXP	ADD ONE TO EXPONENT (TIMES 10)
3049 f2c5 27 eb              	BEQ	LBB67	OV' ERROR IF EXPONENT > $FF
3050 f2c7 39                 LBB7C	RTS
3051 f2c8 84 20 00 00 00     LBB7D	FCB	$84,$20,$00,$00,$00 FLOATING POINT CONSTANT 10
3052                         * DIVIDE FPA0 BY 10
3053 f2cd bd f3 aa           LBB82	JSR	LBC5F	MOVE FPA0 TO FPA1
3054 f2d0 8e f2 c8           	LDX	#LBB7D	POINT TO FLOATING POINT CONSTANT 10
3055 f2d3 5f                 	CLRB		ZERO MANTISSA SIGN BYTE
3056 f2d4 d7 62              LBB89	STB	RESSGN	STORE THE QUOTIENT MANTISSA SIGN BYTE
3057 f2d6 bd f3 5f           	JSR	LBC14	UNPACK AN FP NUMBER FROM (X) INTO FPA0
3058 f2d9 8c                 	FCB	SKP2	SKIP TWO BYTES
3059                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
3060 f2da 8d 9e              LBB8F	BSR	LBB2F	GET FP NUMBER FROM (X) TO FPA1
3061                         
3062                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
3063                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
3064                         
3065                         * DIVIDE FPA1 BY FPA0
3066 f2dc 27 73              LBB91	BEQ	LBC06	/0' DIVIDE BY ZERO ERROR
3067 f2de 00 4f              	NEG	FP0EXP	GET EXPONENT OF RECIPROCAL OF DIVISOR
3068 f2e0 8d b1              	BSR	LBB48	CALCULATE EXPONENT OF QUOTIENT
3069 f2e2 0c 4f              	INC	FP0EXP	INCREMENT EXPONENT
3070 f2e4 27 cc              	BEQ	LBB67	OV' OVERFLOW ERROR
3071 f2e6 8e 00 13           	LDX	#FPA2	POINT X TO MANTISSA OF FPA2 - HOLD
3072                         *		 TEMPORARY QUOTIENT IN FPA2
3073 f2e9 c6 04              	LDB	#4	5 BYTE DIVIDE
3074 f2eb d7 03              	STB	TMPLOC	SAVE BYTE COUNTER
3075 f2ed c6 01              	LDB	#1	SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
3076                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
3077                         * SET CARRY FLAG IF FPA1 >= FPA0
3078 f2ef 96 50              LBBA4	LDA	FPA0	* COMPARE THE TWO MS BYTES
3079 f2f1 91 5d              	CMPA	FPA1	* OF FPA0 AND FPA1 AND
3080 f2f3 26 13              	BNE	LBBBD	* BRANCH IF <>
3081 f2f5 96 51              	LDA	FPA0+1	= COMPARE THE NUMBER 2
3082 f2f7 91 5e              	CMPA	FPA1+1	= BYTES AND
3083 f2f9 26 0d              	BNE	LBBBD	= BRANCH IF <>
3084 f2fb 96 52              	LDA	FPA0+2	* COMPARE THE NUMBER 3
3085 f2fd 91 5f              	CMPA	FPA1+2	* BYTES AND
3086 f2ff 26 07              	BNE	LBBBD	* BRANCH IF <>
3087 f301 96 53              	LDA	FPA0+3	= COMPARE THE LS BYTES
3088 f303 91 60              	CMPA	FPA1+3	= AND BRANCH
3089 f305 26 01              	BNE	LBBBD	= IF <>
3090 f307 43                 	COMA		SET CARRY FLAG IF FPA0 = FPA1
3091 f308 1f a8              LBBBD	TFR	CC,A	SAVE CARRY FLAG STATUS IN ACCA; CARRY
3092                         *	CLEAR IF FPA0 > FPA1
3093 f30a 59                 	ROLB		ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
3094 f30b 24 0a              	BCC	LBBCC	CARRY WILL BE SET AFTER 8 SHIFTS
3095 f30d e7 80              	STB	,X+	SAVE TEMPORARY QUOTIENT
3096 f30f 0a 03              	DEC	TMPLOC	DECREMENT BYTE COUNTER
3097 f311 2b 34              	BMI	LBBFC	BRANCH IF DONE
3098 f313 27 2e              	BEQ	LBBF8	BRANCH IF LAST BYTE
3099 f315 c6 01              	LDB	#1	RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
3100 f317 1f 8a              LBBCC	TFR	A,CC	RESTORE CARRY FLAG AND
3101 f319 25 0e              	BCS	LBBDE	BRANCH IF FPA0 =< FPA1
3102 f31b 08 60              LBBD0	ASL	FPA1+3	* SHIFT FPA1 MANTISSA 1 BIT TO LEFT
3103 f31d 09 5f              	ROL	FPA1+2	*
3104 f31f 09 5e              	ROL	FPA1+1	*
3105 f321 09 5d              	ROL	FPA1	*
3106 f323 25 e3              	BCS	LBBBD	BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
3107 f325 2b c8              	BMI	LBBA4	IF MSB OF HIGH ORDER MANTISSA BYTE IS
3108                         *	SET, CHECK THE MAGNITUDES OF FPA0, FPA1
3109 f327 20 df              	BRA	LBBBD	CARRY IS CLEAR, CHECK ANOTHER BIT
3110                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
3111 f329 96 60              LBBDE	LDA	FPA1+3	* SUBTRACT THE LS BYTES OF MANTISSA
3112 f32b 90 53              	SUBA	FPA0+3	*
3113 f32d 97 60              	STA	FPA1+3	*
3114 f32f 96 5f              	LDA	FPA1+2	= THEN THE NEXT BYTE
3115 f331 92 52              	SBCA	FPA0+2	=
3116 f333 97 5f              	STA	FPA1+2	=
3117 f335 96 5e              	LDA	FPA1+1	* AND THE NEXT
3118 f337 92 51              	SBCA	FPA0+1	*
3119 f339 97 5e              	STA	FPA1+1	*
3120 f33b 96 5d              	LDA	FPA1	= AND FINALLY, THE MS BYTE OF MANTISSA
3121 f33d 92 50              	SBCA	FPA0	=
3122 f33f 97 5d              	STA	FPA1	=
3123 f341 20 d8              	BRA	LBBD0	GO SHIFT FPA1
3124 f343 c6 40              LBBF8	LDB	#$40	USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
3125 f345 20 d0              	BRA	LBBCC	GO SHIFT THE LAST BYTE
3126 f347 56                 LBBFC	RORB		* SHIFT CARRY (ALWAYS SET HERE) INTO
3127 f348 56                 	RORB		* BIT 5 AND MOVE
3128 f349 56                 	RORB		* BITS 1,0 TO BITS 7,6
3129 f34a d7 63              	STB	FPSBYT	SAVE SUB BYTE
3130 f34c 8d 08              	BSR	LBC0B	MOVE MANTISSA OF FPA2 TO FPA0
3131 f34e 7e f1 67           	JMP	LBA1C	NORMALIZE FPA0
3132 f351 c6 14              LBC06	LDB	#2*10	/0' ERROR
3133 f353 7e e4 08           	JMP	LAC46	PROCESS THE ERROR
3134                         * COPY MANTISSA FROM FPA2 TO FPA0
3135 f356 9e 13              LBC0B	LDX	FPA2	* MOVE TOP 2 BYTES
3136 f358 9f 50              	STX	FPA0	*
3137 f35a 9e 15              	LDX	FPA2+2	= MOVE BOTTOM 2 BYTES
3138 f35c 9f 52              	STX	FPA0+2	=
3139 f35e 39                 	RTS
3140                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
3141 f35f 34 02              LBC14	PSHS	A	SAVE ACCA
3142 f361 ec 01              	LDD	1,X	GET TOP TWO MANTISSA BYTES
3143 f363 97 54              	STA	FP0SGN	SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
3144 f365 8a 80              	ORA	#$80	UNPACK MS BYTE
3145 f367 dd 50              	STD	FPA0	SAVE UNPACKED TOP 2 MANTISSA BYTES
3146 f369 0f 63              	CLR	FPSBYT	CLEAR MANTISSA SUB BYTE
3147 f36b e6 84              	LDB	,X	GET EXPONENT TO ACCB
3148 f36d ae 03              	LDX	3,X	* MOVE LAST 2
3149 f36f 9f 52              	STX	FPA0+2	* MANTISSA BYTES
3150 f371 d7 4f              	STB	FP0EXP	SAVE EXPONENT
3151 f373 35 82              	PULS	A,PC	RESTORE ACCA AND RETURN
3152                         
3153 f375 8e 00 45           LBC2A	LDX	#V45	POINT X TO MANTISSA OF FPA4
3154 f378 20 06              	BRA	LBC35	MOVE FPA0 TO FPA4
3155 f37a 8e 00 40           LBC2F	LDX	#V40	POINT X TO MANTISSA OF FPA3
3156 f37d 8c                 	FCB	SKP2	SKIP TWO BYTES
3157 f37e 9e 3b              LBC33	LDX	VARDES	POINT X TO VARIABLE DESCRIPTOR IN VARDES
3158                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
3159 f380 96 4f              LBC35	LDA	FP0EXP	* COPY EXPONENT
3160 f382 a7 84              	STA	,X	*
3161 f384 96 54              	LDA	FP0SGN	GET MANTISSA SIGN BIT
3162 f386 8a 7f              	ORA	#$7F	MASK THE BOTTOM 7 BITS
3163 f388 94 50              	ANDA	FPA0	AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
3164 f38a a7 01              	STA	1,X	SAVE MS BYTE
3165 f38c 96 51              	LDA	FPA0+1	* MOVE 2ND MANTISSA BYTE
3166 f38e a7 02              	STA	2,X	*
3167 f390 de 52              	LDU	FPA0+2	= MOVE BOTTOM 2 MANTISSA BYTES
3168 f392 ef 03              	STU	3,X	=
3169 f394 39                 	RTS
3170                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
3171 f395 96 61              LBC4A	LDA	FP1SGN	* COPY MANTISSA SIGN FROM
3172 f397 97 54              LBC4C	STA	FP0SGN	* FPA1 TO FPA0
3173 f399 9e 5c              	LDX	FP1EXP	= COPY EXPONENT + MS BYTE FROM
3174 f39b 9f 4f              	STX	FP0EXP	= FPA1 TO FPA0
3175 f39d 0f 63              	CLR	FPSBYT	CLEAR MANTISSA SUB BYTE
3176 f39f 96 5e              	LDA	FPA1+1	* COPY 2ND MANTISSA BYTE
3177 f3a1 97 51              	STA	FPA0+1	* FROM FPA1 TO FPA0
3178 f3a3 96 54              	LDA	FP0SGN	GET MANTISSA SIGN
3179 f3a5 9e 5f              	LDX	FPA1+2	* COPY 3RD AND 4TH MANTISSA BYTE
3180 f3a7 9f 52              	STX	FPA0+2	* FROM FPA1 TO FPA0
3181 f3a9 39                 	RTS
3182                         * TRANSFER FPA0 TO FPA1
3183 f3aa dc 4f              LBC5F	LDD	FP0EXP	* TRANSFER EXPONENT & MS BYTE
3184 f3ac dd 5c              	STD	FP1EXP	*
3185 f3ae 9e 51              	LDX	FPA0+1	= TRANSFER MIDDLE TWO BYTES
3186 f3b0 9f 5e              	STX	FPA1+1	=
3187 f3b2 9e 53              	LDX	FPA0+3	* TRANSFER BOTTOM TWO BYTES
3188 f3b4 9f 60              	STX	FPA1+3	*
3189 f3b6 4d                 	TSTA		SET FLAGS ACCORDING TO EXPONENT
3190 f3b7 39                 	RTS
3191                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
3192                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
3193 f3b8 d6 4f              LBC6D	LDB	FP0EXP	GET EXPONENT
3194 f3ba 27 08              	BEQ	LBC79	BRANCH IF FPA0 = 0
3195 f3bc d6 54              LBC71	LDB	FP0SGN	GET SIGN OF MANTISSA
3196 f3be 59                 LBC73	ROLB		BIT 7 TO CARRY
3197 f3bf c6 ff              	LDB	#$FF	NEGATIVE FLAG
3198 f3c1 25 01              	BCS	LBC79	BRANCH IF NEGATIVE MANTISSA
3199 f3c3 50                 	NEGB		ACCB = 1 IF POSITIVE MANTISSA
3200 f3c4 39                 LBC79	RTS
3201                         
3202                         * SGN
3203 f3c5 8d f1              SGN	BSR	LBC6D	SET ACCB ACCORDING TO SIGN OF FPA0
3204                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
3205 f3c7 d7 50              LBC7C	STB	FPA0	SAVE ACCB IN FPA0
3206 f3c9 0f 51              	CLR	FPA0+1	CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
3207 f3cb c6 88              	LDB	#$88	EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
3208 f3cd 96 50              LBC82	LDA	FPA0	GET MS BYTE OF MANTISSA
3209 f3cf 80 80              	SUBA	#$80	SET CARRY IF POSITIVE MANTISSA
3210 f3d1 d7 4f              LBC86	STB	FP0EXP	SAVE EXPONENT
3211 f3d3 dc 74              	LDD	ZERO	* ZERO OUT ACCD AND
3212 f3d5 dd 52              	STD	FPA0+2	* BOTTOM HALF OF FPA0
3213 f3d7 97 63              	STA	FPSBYT	CLEAR SUB BYTE
3214 f3d9 97 54              	STA	FP0SGN	CLEAR SIGN OF FPA0 MANTISSA
3215 f3db 7e f1 63           	JMP	LBA18	GO NORMALIZE FPA0
3216                         
3217                         * ABS
3218 f3de 0f 54              ABS	CLR	FP0SGN	FORCE MANTISSA SIGN OF FPA0 POSITIVE
3219 f3e0 39                 	RTS
3220                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
3221                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
3222                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
3223                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
3224 f3e1 e6 84              LBC96	LDB	,X	CHECK EXPONENT OF (X)
3225 f3e3 27 d3              	BEQ	LBC6D	BRANCH IF FPA = 0
3226 f3e5 e6 01              	LDB	1,X	GET MS BYTE OF MANTISSA OF (X)
3227 f3e7 d8 54              	EORB FP0SGN	EOR WITH SIGN OF FPA0
3228 f3e9 2b d1              	BMI	LBC71	BRANCH IF SIGNS NOT =
3229                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
3230                         * FPA0 IS NORMALIZED, (X) IS PACKED.
3231 f3eb d6 4f              LBCA0	LDB	FP0EXP	* GET EXPONENT OF
3232 f3ed e1 84              	CMPB	,X	* FPA0, COMPARE TO EXPONENT OF
3233 f3ef 26 1d              	BNE	LBCC3	* (X) AND BRANCH IF <>.
3234 f3f1 e6 01              	LDB	1,X	* GET MS BYTE OF (X), KEEP ONLY
3235 f3f3 ca 7f              	ORB	#$7F	* THE SIGN BIT - 'AND' THE BOTTOM 7
3236 f3f5 d4 50              	ANDB	FPA0	* BITS OF FPA0 INTO ACCB
3237 f3f7 e1 01              	CMPB	1,X	= COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
3238 f3f9 26 13              	BNE	LBCC3	= MS BYTE AND BRANCH IF <>
3239 f3fb d6 51              	LDB	FPA0+1	* COMPARE 2ND BYTE
3240 f3fd e1 02              	CMPB	2,X	* OF MANTISSA,
3241 f3ff 26 0d              	BNE	LBCC3	* BRANCH IF <>
3242 f401 d6 52              	LDB	FPA0+2	= COMPARE 3RD BYTE
3243 f403 e1 03              	CMPB	3,X	= OF MANTISSA,
3244 f405 26 07              	BNE	LBCC3	= BRANCH IF <>
3245 f407 d6 53              	LDB	FPA0+3	* SUBTRACT LS BYTE
3246 f409 e0 04              	SUBB	4,X	* OF (X) FROM LS BYTE OF
3247 f40b 26 01              	BNE	LBCC3	* FPA0, BRANCH IF <>
3248 f40d 39                 	RTS		RETURN IF FP (X) = FPA0
3249 f40e 56                 LBCC3	RORB		SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
3250 f40f d8 54              	EORB FP0SGN	TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
3251 f411 20 ab              	BRA	LBC73	GO SET ACCB ACCORDING TO COMPARISON
3252                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
3253                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
3254 f413 d6 4f              LBCC8	LDB	FP0EXP	GET EXPONENT OF FPA0
3255 f415 27 3d              	BEQ	LBD09	ZERO MANTISSA IF FPA0 = 0
3256 f417 c0 a0              	SUBB	#$A0	SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
3257                         *		 THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
3258                         *		 THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
3259                         *		 WILL BE TO THE RIGHT OF THE MANTISSA
3260 f419 96 54              	LDA	FP0SGN	TEST SIGN OF FPA0 MANTISSA
3261 f41b 2a 05              	BPL	LBCD7	BRANCH IF POSITIVE
3262 f41d 03 5b              	COM	FPCARY	COMPLEMENT CARRY IN BYTE
3263 f41f bd f1 c6           	JSR	LBA7B	NEGATE MANTISSA OF FPA0
3264 f422 8e 00 4f           LBCD7	LDX	#FP0EXP	POINT X TO FPA0
3265 f425 c1 f8              	CMPB	#-8	EXPONENT DIFFERENCE < -8?
3266 f427 2e 06              	BGT	LBCE4	YES
3267 f429 bd f1 f9           	JSR	LBAAE	SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
3268 f42c 0f 5b              	CLR	FPCARY	CLEAR CARRY IN BYTE
3269 f42e 39                 	RTS
3270 f42f 0f 5b              LBCE4	CLR	FPCARY	CLEAR CARRY IN BYTE
3271 f431 96 54              	LDA	FP0SGN	* GET SIGN OF FPA0 MANTISSA
3272 f433 49                 	ROLA		* ROTATE IT INTO THE CARRY FLAG
3273 f434 06 50              	ROR	FPA0	ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
3274                         *		 OF LS BYTE OF MANTISSA
3275 f436 7e f2 05           	JMP	LBABA	DE-NORMALIZE FPA0
3276                         
3277                         * INT
3278                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
3279                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
3280                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
3281                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
3282                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
3283                         *
3284 f439 d6 4f              INT	LDB	FP0EXP	GET EXPONENT OF FPA0
3285 f43b c1 a0              	CMPB	#$A0	LARGEST POSSIBLE INTEGER EXPONENT
3286 f43d 24 1d              	BCC	LBD11	RETURN IF FPA0 >= 32768
3287 f43f 8d d2              	BSR	LBCC8	SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
3288                         *		 LS BYTE OF THE FPA0 MANTISSA
3289 f441 d7 63              	STB	FPSBYT	ACCB = 0: ZERO OUT THE SUB BYTE
3290 f443 96 54              	LDA	FP0SGN	GET MANTISSA SIGN
3291 f445 d7 54              	STB	FP0SGN	FORCE MANTISSA SIGN TO BE POSITIVE
3292 f447 80 80              	SUBA	#$80	SET CARRY IF MANTISSA
3293 f449 86 a0              	LDA	#$A0	* GET DENORMALIZED EXPONENT AND
3294 f44b 97 4f              	STA	FP0EXP	* SAVE IT IN FPA0 EXPONENT
3295 f44d 96 53              	LDA	FPA0+3	= GET LS BYTE OF FPA0 AND
3296 f44f 97 01              	STA	CHARAC	= SAVE IT IN CHARAC
3297 f451 7e f1 63           	JMP	LBA18	NORMALIZE FPA0
3298                         
3299 f454 d7 50              LBD09	STB	FPA0	* LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
3300 f456 d7 51              	STB	FPA0+1	*
3301 f458 d7 52              	STB	FPA0+2	*
3302 f45a d7 53              	STB	FPA0+3	*
3303 f45c 39                 LBD11	RTS		*
3304                         
3305                         * CONVERT ASCII STRING TO FLOATING POINT
3306 f45d 9e 74              LBD12	LDX	ZERO	(X) = 0
3307 f45f 9f 54              	STX	FP0SGN	* ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
3308 f461 9f 4f              	STX	FP0EXP	*
3309 f463 9f 51              	STX	FPA0+1	*
3310 f465 9f 52              	STX	FPA0+2	*
3311 f467 9f 47              	STX	V47	INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
3312 f469 9f 45              	STX	V45	INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
3313 f46b 25 64              	BCS	LBD86	IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
3314                         *	NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
3315 f46d bd fb 9a           	JSR	XVEC19	CALL EXTENDED BASIC ADD-IN
3316 f470 81 2d              LBD25	CMPA	#'-	* CHECK FOR A LEADING MINUS SIGN AND BRANCH
3317 f472 26 04              	BNE	LBD2D	* IF NO MINUS SIGN
3318 f474 03 55              	COM	COEFCT	TOGGLE SIGN; 0 = +; FF = -
3319 f476 20 04              	BRA	LBD31	INTERPRET THE REST OF THE STRING
3320 f478 81 2b              LBD2D	CMPA	#'+	* CHECK FOR LEADING PLUS SlGN AND BRANCH
3321 f47a 26 04              	BNE	LBD35	* IF NOT A PLUS SIGN
3322 f47c 9d 7c              LBD31	JSR	GETNCH	GET NEXT INPUT CHARACTER FROM BASIC
3323 f47e 25 51              	BCS	LBD86	BRANCH IF NUMERIC CHARACTER
3324 f480 81 2e              LBD35	CMPA	#'.	DECIMAL POlNT?
3325 f482 27 28              	BEQ	LBD61	YES
3326 f484 81 45              	CMPA	#'E	"E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
3327 f486 26 28              	BNE	LBD65	NO
3328                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
3329 f488 9d 7c              	JSR	GETNCH	GET NEXT INPUT CHARACTER FROM BASIC
3330 f48a 25 64              	BCS	LBDA5	BRANCH IF NUMERIC
3331 f48c 81 a7              	CMPA	#TOK_MINUS	MINUS TOKEN?
3332 f48e 27 0e              	BEQ	LBD53	YES
3333 f490 81 2d              	CMPA	#'-	ASCII MINUS?
3334 f492 27 0a              	BEQ	LBD53	YES
3335 f494 81 a6              	CMPA	#TOK_PLUS	PLUS TOKEN?
3336 f496 27 08              	BEQ	LBD55	YES
3337 f498 81 2b              	CMPA	#'+	ASCII PLUS?
3338 f49a 27 04              	BEQ	LBD55	YES
3339 f49c 20 06              	BRA	LBD59	BRANCH IF NO SIGN FOUND
3340 f49e 03 48              LBD53	COM	V48	SET EXPONENT SIGN FLAG TO NEGATIVE
3341                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
3342 f4a0 9d 7c              LBD55	JSR	GETNCH	GET NEXT INPUT CHARACTER FROM BASIC
3343 f4a2 25 4c              	BCS	LBDA5	IF NUMERIC CHARACTER, CONVERT TO BINARY
3344 f4a4 0d 48              LBD59	TST	V48	* CHECK EXPONENT SIGN FLAG
3345 f4a6 27 08              	BEQ	LBD65	* AND BRANCH IF POSITIVE
3346 f4a8 00 47              	NEG	V47	NEGATE VALUE OF EXPONENT
3347 f4aa 20 04              	BRA	LBD65
3348 f4ac 03 46              LBD61	COM	V46	*TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
3349 f4ae 26 cc              	BNE	LBD31	*CHARACTER IF <> 0 - TERMINATE INTERPRETATION
3350                         *	IF	SECOND DECIMAL POINT
3351                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
3352 f4b0 96 47              LBD65	LDA	V47	* GET EXPONENT, SUBTRACT THE NUMBER OF
3353 f4b2 90 45              	SUBA	V45	* PLACES TO THE RIGHT OF DECIMAL POINT
3354 f4b4 97 47              	STA	V47	* AND RESAVE IT.
3355 f4b6 27 12              	BEQ	LBD7F	EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
3356 f4b8 2a 09              	BPL	LBD78	BRANCH IF POSITIVE EXPONENT
3357 f4ba bd f2 cd           LBD6F	JSR	LBB82	DIVIDE FPA0 BY 10
3358 f4bd 0c 47              	INC	V47	INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
3359 f4bf 26 f9              	BNE	LBD6F	KEEP MULTIPLYING
3360 f4c1 20 07              	BRA	LBD7F	EXIT ROUTINE
3361 f4c3 bd f2 b5           LBD78	JSR	LBB6A	MULTIPLY FPA0 BY 10
3362 f4c6 0a 47              	DEC	V47	DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
3363 f4c8 26 f9              	BNE	LBD78	KEEP MULTIPLYING
3364 f4ca 96 55              LBD7F	LDA	COEFCT	GET THE SIGN FLAG
3365 f4cc 2a 8e              	BPL	LBD11	RETURN IF POSITIVE
3366 f4ce 7e f6 34           	JMP	LBEE9	TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
3367                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
3368 f4d1 d6 45              LBD86	LDB	V45	*GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
3369 f4d3 d0 46              	SUBB	V46	*THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
3370 f4d5 d7 45              	STB	V45	*FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
3371                         *		 -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
3372 f4d7 34 02              	PSHS	A	SAVE NEW DIGIT ON STACK
3373 f4d9 bd f2 b5           	JSR	LBB6A	MULTIPLY FPA0 BY 10
3374 f4dc 35 04              	PULS	B	GET NEW DIGIT BACK
3375 f4de c0 30              	SUBB	#'0	MASK OFF ASCII
3376 f4e0 8d 02              	BSR	LBD99	ADD ACCB TO FPA0
3377 f4e2 20 98              	BRA	LBD31	GET ANOTHER CHARACTER FROM BASIC
3378 f4e4 bd f3 7a           LBD99	JSR	LBC2F	PACK FPA0 AND SAVE IT IN FPA3
3379 f4e7 bd f3 c7           	JSR	LBC7C	CONVERT ACCB TO FP NUMBER IN FPA0
3380 f4ea 8e 00 40           	LDX	#V40	* ADD FPA0 TO
3381 f4ed 7e f1 0d           	JMP	LB9C2	* FPA3
3382                         
3383                         
3384 f4f0 d6 47              LBDA5	LDB	V47
3385 f4f2 58                 	ASLB		TIMES 2
3386 f4f3 58                 	ASLB		TIMES 4
3387 f4f4 db 47              	ADDB	V47	ADD 1 = TIMES 5
3388 f4f6 58                 	ASLB		TIMES 10
3389 f4f7 80 30              	SUBA	#'0	*MASK OFF ASCII FROM ACCA, PUSH
3390 f4f9 34 04              	PSHS	B	*RESULT ONTO THE STACK AND
3391 f4fb ab e0              	ADDA	,S+	ADD lT TO ACCB
3392 f4fd 97 47              	STA	V47	SAVE IN V47
3393 f4ff 20 9f              	BRA	LBD55	INTERPRET ANOTHER CHARACTER
3394                         *
3395 f501 9b 3e bc 1f fd     LBDB6	FCB	$9B,$3E,$BC,$1F,$FD * 99999999.9
3396 f506 9e 6e 6b 27 fd     LBDBB	FCB	$9E,$6E,$6B,$27,$FD * 999999999
3397 f50b 9e 6e 6b 28 00     LBDC0	FCB	$9E,$6E,$6B,$28,$00 * 1E + 09
3398                         *
3399 f510 8e e3 a9           LBDC5	LDX	#LABE8-1	POINT X TO " IN " MESSAGE
3400 f513 8d 0c              	BSR	LBDD6	COPY A STRING FROM (X) TO CONSOLE OUT
3401 f515 dc 68              	LDD	CURLIN	GET CURRENT BASIC LINE NUMBER TO ACCD
3402                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
3403                         * AND PRINT IT TO CONSOLE OUT
3404 f517 dd 50              LBDCC	STD	FPA0	SAVE ACCD IN TOP HALF OF FPA0
3405 f519 c6 90              	LDB	#$90	REQ�D EXPONENT IF TOP HALF OF ACCD = INTEGER
3406 f51b 43                 	COMA		SET CARRY FLAG - FORCE POSITIVE MANTISSA
3407 f51c bd f3 d1           	JSR	LBC86	ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
3408                         *	SAVE EXPONENT AND NORMALIZE IT
3409 f51f 8d 03              	BSR	LBDD9	CONVERT FP NUMBER TO ASCII STRING
3410 f521 7e f0 e7           LBDD6	JMP	LB99C	COPY A STRING FROM (X) TO CONSOLE OUT
3411                         
3412                         * CONVERT FP NUMBER TO ASCII STRING
3413 f524 ce 01 f1           LBDD9	LDU	#STRBUF+3	POINT U TO BUFFER WHICH WILL NOT CAUSE
3414                         *		 THE STRING TO BE STORED IN STRING SPACE
3415 f527 86 20              LBDDC	LDA	#SPACE	SPACE = DEFAULT SIGN FOR POSITIVE #
3416 f529 d6 54              	LDB	FP0SGN	GET SIGN OF FPA0
3417 f52b 2a 02              	BPL	LBDE4	BRANCH IF POSITIVE
3418 f52d 86 2d              	LDA	#'-	ASCII MINUS SIGN
3419 f52f a7 c0              LBDE4	STA	,U+	STORE SIGN OF NUMBER
3420 f531 df 64              	STU	COEFPT	SAVE BUFFER POINTER
3421 f533 97 54              	STA	FP0SGN	SAVE SIGN (IN ASCII)
3422 f535 86 30              	LDA	#'0	ASCII ZERO IF EXPONENT = 0
3423 f537 d6 4f              	LDB	FP0EXP	GET FPA0 EXPONENT
3424 f539 10 27 00 c6        	LBEQ	LBEB8	BRANCH IF FPA0 = 0
3425 f53d 4f                 	CLRA		BASE 10 EXPONENT=0 FOR FP NUMBER > 1
3426 f53e c1 80              	CMPB	#$80	CHECK EXPONENT
3427 f540 22 08              	BHI	LBDFF	BRANCH IF FP NUMBER > 1
3428                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
3429 f542 8e f5 0b           	LDX	#LBDC0	POINT X TO FP 1E+09
3430 f545 bd f2 15           	JSR	LBACA	MULTIPLY FPA0 BY (X)
3431 f548 86 f7              	LDA	#-9	BASE 10 EXPONENT = -9
3432 f54a 97 45              LBDFF	STA	V45	BASE 10 EXPONENT
3433                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
3434                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
3435                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
3436                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
3437                         * SCIENTIFIC NOTATION
3438 f54c 8e f5 06           LBE01	LDX	#LBDBB	POINT X TO FP 999,999,999
3439 f54f bd f3 eb           	JSR	LBCA0	COMPARE FPA0 TO 999,999,999
3440 f552 2e 0f              	BGT	LBE18	BRANCH IF > 999,999,999
3441 f554 8e f5 01           LBE09	LDX	#LBDB6	POINT X TO FP 99,999,999.9
3442 f557 bd f3 eb           	JSR	LBCA0	COMPARE FPA0 TO 99,999,999.9
3443 f55a 2e 0e              	BGT	LBE1F	BRANCH IF > 99,999,999.9 (IN RANGE)
3444 f55c bd f2 b5           	JSR	LBB6A	MULTIPLY FPA0 BY 10
3445 f55f 0a 45              	DEC	V45	SUBTRACT ONE FROM DECIMAL OFFSET
3446 f561 20 f1              	BRA	LBE09	PSEUDO - NORMALIZE SOME MORE
3447 f563 bd f2 cd           LBE18	JSR	LBB82	DIVIDE FPA0 BY 10
3448 f566 0c 45              	INC	V45	ADD ONE TO BASE 10 EXPONENT
3449 f568 20 e2              	BRA	LBE01	PSEUDO - NORMALIZE SOME MORE
3450 f56a bd f0 ff           LBE1F	JSR	LB9B4	ADD .5 TO FPA0 (ROUND OFF)
3451 f56d bd f4 13           	JSR	LBCC8	CONVERT FPA0 TO AN INTEGER
3452 f570 c6 01              	LDB	#1	DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
3453 f572 96 45              	LDA	V45	* GET BASE 10 EXPONENT AND ADD TEN TO IT
3454 f574 8b 0a              	ADDA	#9+1	* (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
3455 f576 2b 09              	BMI	LBE36	BRANCH IF NUMBER < 1.0
3456 f578 81 0b              	CMPA	#9+2	NINE PLACES MAY BE DISPLAYED WITHOUT
3457                         *	USING SCIENTIFIC NOTATION
3458 f57a 24 05              	BCC	LBE36	BRANCH IF SCIENTIFIC NOTATION REQUIRED
3459 f57c 4a                 	DECA		* SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
3460 f57d 1f 89              	TFR	A,B	* AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
3461 f57f 86 02              	LDA	#2	FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
3462 f581 4a                 LBE36	DECA		* SUBTRACT TWO (WITHOUT AFFECTING CARRY)
3463 f582 4a                 	DECA		* FROM BASE 10 EXPONENT
3464 f583 97 47              	STA	V47	SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
3465                         *	IN	SCIENTIFIC NOTATION
3466 f585 d7 45              	STB	V45	DECIMAL POINT FLAG - NUMBER OF PLACES TO
3467                         *	LEFT OF DECIMAL POINT
3468 f587 2e 0d              	BGT	LBE4B	BRANCH IF >= 1
3469 f589 de 64              	LDU	COEFPT	POINT U TO THE STRING BUFFER
3470 f58b 86 2e              	LDA	#'.	* STORE A PERIOD
3471 f58d a7 c0              	STA	,U+	* IN THE BUFFER
3472 f58f 5d                 	TSTB	CHECK DECIMAL POINT FLAG
3473 f590 27 04              	BEQ	LBE4B	BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
3474 f592 86 30              	LDA	#'0	* STORE A ZERO
3475 f594 a7 c0              	STA	,U+	* IN THE BUFFER
3476                         
3477                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
3478 f596 8e f6 10           LBE4B	LDX	#LBEC5	POINT X TO FP POWER OF 10 MANTISSA
3479 f599 c6 80              	LDB	#0+$80	INITIALIZE DIGIT COUNTER TO 0+$80
3480                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
3481                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
3482                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
3483                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
3484 f59b 96 53              LBE50	LDA	FPA0+3	* ADD MANTISSA LS
3485 f59d ab 03              	ADDA	3,X	* BYTE OF FPA0
3486 f59f 97 53              	STA	FPA0+3	* AND (X)
3487 f5a1 96 52              	LDA	FPA0+2	= ADD MANTISSA
3488 f5a3 a9 02              	ADCA	2,X	= NUMBER 3 BYTE OF
3489 f5a5 97 52              	STA	FPA0+2	= FPA0 AND (X)
3490 f5a7 96 51              	LDA	FPA0+1	* ADD MANTISSA
3491 f5a9 a9 01              	ADCA	1,X	* NUMBER 2 BYTE OF
3492 f5ab 97 51              	STA	FPA0+1	* FPA0 AND (X)
3493 f5ad 96 50              	LDA	FPA0	= ADD MANTISSA
3494 f5af a9 84              	ADCA	,X	= MS BYTE OF
3495 f5b1 97 50              	STA	FPA0	= FPA0 AND (X)
3496 f5b3 5c                 	INCB		ADD ONE TO DIGIT COUNTER
3497 f5b4 56                 	RORB		ROTATE CARRY INTO BIT 7
3498 f5b5 59                 	ROLB		*SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
3499 f5b6 28 e3              	BVC	LBE50	*POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
3500 f5b8 24 03              	BCC	LBE72	BRANCH IF NEGATIVE MANTISSA
3501 f5ba c0 0b              	SUBB	#10+1	* TAKE THE 9�S COMPLEMENT IF
3502 f5bc 50                 	NEGB		* ADDING MANTISSA
3503 f5bd cb 2f              LBE72	ADDB	#'0-1	ADD ASCII OFFSET TO DIGIT
3504 f5bf 30 04              	LEAX	4,X	MOVE TO NEXT POWER OF 10 MANTISSA
3505 f5c1 1f 98              	TFR	B,A	SAVE DIGIT IN ACCA
3506 f5c3 84 7f              	ANDA	#$7F	MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
3507 f5c5 a7 c0              	STA	,U+	STORE DIGIT IN STRING BUFFER
3508 f5c7 0a 45              	DEC	V45	DECREMENT DECIMAL POINT FLAG
3509 f5c9 26 04              	BNE	LBE84	BRANCH IF NOT TIME FOR DECIMAL POINT
3510 f5cb 86 2e              	LDA	#'.	* STORE DECIMAL POINT IN
3511 f5cd a7 c0              	STA	,U+	* STRING BUFFER
3512 f5cf 53                 LBE84	COMB		TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
3513 f5d0 c4 80              	ANDB	#$80	MASK OFF ALL BUT ADD/SUBTRACT FLAG
3514 f5d2 8c f6 34           	CMPX	#LBEC5+36	COMPARE X TO END OF MANTISSA TABLE
3515 f5d5 26 c4              	BNE	LBE50	BRANCH IF NOT AT END OF TABLE
3516                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
3517 f5d7 a6 c2              LBE8C	LDA	,-U	GET THE LAST CHARACTER; MOVE POINTER BACK
3518 f5d9 81 30              	CMPA	#'0	WAS IT A ZERO?
3519 f5db 27 fa              	BEQ	LBE8C	IGNORE TRAILING ZEROS IF SO
3520 f5dd 81 2e              	CMPA	#'.	CHECK FOR DECIMAL POINT
3521 f5df 26 02              	BNE	LBE98	BRANCH IF NOT DECIMAL POINT
3522 f5e1 33 5f              	LEAU	-1,U	STEP OVER THE DECIMAL POINT
3523 f5e3 86 2b              LBE98	LDA	#'+	ASCII PLUS SIGN
3524 f5e5 d6 47              	LDB	V47	GET SCIENTIFIC NOTATION EXPONENT
3525 f5e7 27 1c              	BEQ	LBEBA	BRANCH IF NOT SCIENTIFIC NOTATION
3526 f5e9 2a 03              	BPL	LBEA3	BRANCH IF POSITIVE EXPONENT
3527 f5eb 86 2d              	LDA	#'-	ASCII MINUS SIGN
3528 f5ed 50                 	NEGB		NEGATE EXPONENT IF NEGATIVE
3529 f5ee a7 42              LBEA3	STA	2,U	STORE EXPONENT SIGN IN STRING
3530 f5f0 86 45              	LDA	#'E	* GET ASCII 'E' (SCIENTIFIC NOTATION
3531 f5f2 a7 41              	STA	1,U	* FLAG) AND SAVE IT IN THE STRING
3532 f5f4 86 2f              	LDA	#'0-1	INITIALIZE ACCA TO ASCII ZERO
3533                         
3534                         
3535 f5f6 4c                 LBEAB	INCA		ADD ONE TO 10'S DIGIT OF EXPONENT
3536 f5f7 c0 0a              	SUBB	#10	SUBTRACT 10 FROM ACCB
3537 f5f9 24 fb              	BCC	LBEAB	ADD 1 TO 10'S DIGIT IF NO CARRY
3538 f5fb cb 3a              	ADDB	#'9+1	CONVERT UNITS DIGIT TO ASCII
3539 f5fd ed 43              	STD	3,U	SAVE EXPONENT IN STRING
3540 f5ff 6f 45              	CLR	5,U	CLEAR LAST BYTE (TERMINATOR)
3541 f601 20 04              	BRA	LBEBC	GO RESET POINTER
3542 f603 a7 c4              LBEB8	STA	,U	STORE LAST CHARACTER
3543 f605 6f 41              LBEBA	CLR	1,U	CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
3544                         *	PRINT SUBROUTINES)
3545 f607 8e 01 f1           LBEBC	LDX	#STRBUF+3	RESET POINTER TO START OF BUFFER
3546 f60a 39                 	RTS
3547                         *
3548 f60b 80 00 00 00 00     LBEC0	FCB	$80,$00,$00,$00,$00 FLOATING POINT .5
3549                         *
3550                         *** TABLE OF UNNORMALIZED POWERS OF 10
3551 f610 fa 0a 1f 00        LBEC5	FCB	$FA,$0A,$1F,$00 -100000000
3552 f614 00 98 96 80        LBEC9	FCB	$00,$98,$96,$80 10000000
3553 f618 ff f0 bd c0        LBECD	FCB	$FF,$F0,$BD,$C0 -1000000
3554 f61c 00 01 86 a0        LBED1	FCB	$00,$01,$86,$A0 100000
3555 f620 ff ff d8 f0        LBED5	FCB	$FF,$FF,$D8,$F0 -10000
3556 f624 00 00 03 e8        LBED9	FCB	$00,$00,$03,$E8 1000
3557 f628 ff ff ff 9c        LBEDD	FCB	$FF,$FF,$FF,$9C -100
3558 f62c 00 00 00 0a        LBEE1	FCB	$00,$00,$00,$0A 10
3559 f630 ff ff ff ff        LBEE5	FCB	$FF,$FF,$FF,$FF -1
3560                         *
3561                         *
3562 f634 96 4f              LBEE9	LDA	FP0EXP	GET EXPONENT OF FPA0
3563 f636 27 02              	BEQ	LBEEF	BRANCH IF FPA0 = 0
3564 f638 03 54              	COM	FP0SGN	TOGGLE MANTISSA SIGN OF FPA0
3565 f63a 39                 LBEEF	RTS
3566                         * EXPAND A POLYNOMIAL OF THE FORM
3567                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
3568                         * AND THE X REGISTER POINTS TO A TABLE OF
3569                         * COEFFICIENTS A,B,C,D....
3570 f63b 9f 64              LBEF0	STX	COEFPT	SAVE COEFFICIENT TABLE POINTER
3571 f63d bd f3 7a           	JSR	LBC2F	MOVE FPA0 TO FPA3
3572 f640 8d 05              	BSR	LBEFC	MULTIPLY FPA3 BY FPA0
3573 f642 8d 08              	BSR	LBF01	EXPAND POLYNOMIAL
3574 f644 8e 00 40           	LDX	#V40	POINT X TO FPA3
3575 f647 7e f2 15           LBEFC	JMP	LBACA	MULTIPLY (X) BY FPA0
3576                         
3577                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
3578                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
3579                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
3580                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
3581                         * OF PACKED FLOATING POINT NUMBERS. THE
3582                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
3583                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0�YN)
3584 f64a 9f 64              LBEFF	STX	COEFPT	SAVE COEFFICIENT TABLE POINTER
3585 f64c bd f3 75           LBF01	JSR	LBC2A	MOVE FPA0 TO FPA4
3586 f64f 9e 64              	LDX	COEFPT	GET THE COEFFICIENT POINTER
3587 f651 e6 80              	LDB	,X+	GET THE TOP OF COEFFICIENT TABLE TO
3588 f653 d7 55              	STB	COEFCT	* USE AND STORE IT IN TEMPORARY COUNTER
3589 f655 9f 64              	STX	COEFPT	SAVE NEW COEFFICIENT POINTER
3590 f657 8d ee              LBF0C	BSR	LBEFC	MULTIPLY (X) BY FPA0
3591 f659 9e 64              	LDX	COEFPT	*GET COEFFICIENT POINTER
3592 f65b 30 05              	LEAX	5,X	*MOVE TO NEXT FP NUMBER
3593 f65d 9f 64              	STX	COEFPT	*SAVE NEW COEFFICIENT POINTER
3594 f65f bd f1 0d           	JSR	LB9C2	ADD (X) AND FPA0
3595 f662 8e 00 45           	LDX	#V45	POINT (X) TO FPA4
3596 f665 0a 55              	DEC	COEFCT	DECREMENT TEMP COUNTER
3597 f667 26 ee              	BNE	LBF0C	BRANCH IF MORE COEFFICIENTS LEFT
3598 f669 39                 	RTS
3599                         
3600                         * RND
3601 f66a bd f3 b8           RND	JSR	LBC6D	TEST FPA0
3602 f66d 2b 1f              	BMI	LBF45	BRANCH IF FPA0 = NEGATIVE
3603 f66f 27 15              	BEQ	LBF3B	BRANCH IF FPA0 = 0
3604 f671 8d 10              	BSR	LBF38	CONVERT FPA0 TO AN INTEGER
3605 f673 bd f3 7a           	JSR	LBC2F	PACK FPA0 TO FPA3
3606 f676 8d 0e              	BSR	LBF3B	GET A RANDOM NUMBER: FPA0 < 1.0
3607 f678 8e 00 40           	LDX	#V40	POINT (X) TO FPA3
3608 f67b 8d ca              	BSR	LBEFC	MULTIPLY (X) BY FPA0
3609 f67d 8e f2 10           	LDX	#LBAC5	POINT (X) TO FP VALUE OF 1.0
3610 f680 bd f1 0d           	JSR	LB9C2	ADD 1.0 TO FPA0
3611 f683 7e f4 39           LBF38	JMP	INT	CONVERT FPA0 TO AN INTEGER
3612                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
3613 f686 9e b1              LBF3B	LDX	RVSEED+1	* MOVE VARIABLE
3614 f688 9f 50              	STX	FPA0	* RANDOM NUMBER
3615 f68a 9e b3              	LDX	RVSEED+3	* SEED TO
3616 f68c 9f 52              	STX	FPA0+2	* FPA0
3617 f68e be f6 bb           LBF45	LDX	RSEED	= MOVE FIXED
3618 f691 9f 5d              	STX	FPA1	= RANDOM NUMBER
3619 f693 be f6 bd           	LDX	RSEED+2	= SEED TO
3620 f696 9f 5f              	STX	FPA1+2	= MANTISSA OF FPA0
3621 f698 bd f2 1b           	JSR	LBAD0	MULTIPLY FPA0 X FPA1
3622 f69b dc 8a              	LDD	VAD	GET THE TWO LOWEST ORDER PRODUCT BYTES
3623 f69d c3 65 8b           	ADDD	#$658B	ADD A CONSTANT
3624 f6a0 dd b3              	STD	RVSEED+3	SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
3625 f6a2 dd 52              	STD	FPA0+2	SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
3626 f6a4 dc 88              	LDD	VAB	GET 2 MORE LOW ORDER PRODUCT BYTES
3627 f6a6 c9 b0              	ADCB	#$B0	ADD A CONSTANT
3628 f6a8 89 05              	ADCA	#5	ADD A CONSTANT
3629 f6aa dd b1              	STD	RVSEED+1	SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
3630 f6ac dd 50              	STD	FPA0	SAVE NEW HIGH ORDER FPA0 MANTISSA
3631 f6ae 0f 54              	CLR	FP0SGN	FORCE FPA0 MANTISSA = POSITIVE
3632 f6b0 86 80              	LDA	#$80	* SET FPA0 BIASED EXPONENT
3633 f6b2 97 4f              	STA	FP0EXP	* TO 0 1 < FPA0 < 0
3634 f6b4 96 15              	LDA	FPA2+2	GET A BYTE FROM FPA2 (MORE RANDOMNESS)
3635 f6b6 97 63              	STA	FPSBYT	SAVE AS SUB BYTE
3636 f6b8 7e f1 67           	JMP	LBA1C	NORMALIZE FPA0
3637                         *
3638 f6bb 40 e6              RSEED	FDB	$40E6	*CONSTANT RANDOM NUMBER GENERATOR SEED
3639 f6bd 4d ab              	FDB	$4DAB	*
3640                         
3641                         * SIN
3642                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
3643                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
3644                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
3645                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
3646                         
3647                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
3648                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
3649 f6bf bd f3 aa           SIN	JSR	LBC5F	COPY FPA0 TO FPA1
3650 f6c2 8e f7 04           	LDX	#LBFBD	POINT (X) TO 2*PI
3651 f6c5 d6 61              	LDB	FP1SGN	*GET MANTISSA SIGN OF FPA1
3652 f6c7 bd f2 d4           	JSR	LBB89	*AND DIVIDE FPA0 BY 2*PI
3653 f6ca bd f3 aa           	JSR	LBC5F	COPY FPA0 TO FPA1
3654 f6cd 8d b4              	BSR	LBF38	CONVERT FPA0 TO AN INTEGER
3655 f6cf 0f 62              	CLR	RESSGN	SET RESULT SIGN = POSITIVE
3656 f6d1 96 5c              	LDA	FP1EXP	*GET EXPONENT OF FPA1
3657 f6d3 d6 4f              	LDB	FP0EXP	*GET EXPONENT OF FPA0
3658 f6d5 bd f1 07           	JSR	LB9BC	*SUBTRACT FPA0 FROM FPA1
3659                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
3660 f6d8 8e f7 09           	LDX	#LBFC2	POINT X TO FP (.25)
3661 f6db bd f1 04           	JSR	LB9B9	SUBTRACT FPA0 FROM .25 (PI/2)
3662 f6de 96 54              	LDA	FP0SGN	GET MANTISSA SIGN OF FPA0
3663 f6e0 34 02              	PSHS	A	SAVE IT ON STACK
3664 f6e2 2a 09              	BPL	LBFA6	BRANCH IF MANTISSA POSITIVE
3665 f6e4 bd f0 ff           	JSR	LB9B4	ADD .5 (PI) TO FPA0
3666 f6e7 96 54              	LDA	FP0SGN	GET SIGN OF FPA0
3667 f6e9 2b 05              	BMI	LBFA9	BRANCH IF NEGATIVE
3668 f6eb 03 0a              	COM	RELFLG	COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
3669 f6ed bd f6 34           LBFA6	JSR	LBEE9	TOGGLE MANTISSA SIGN OF FPA0
3670 f6f0 8e f7 09           LBFA9	LDX	#LBFC2	POINT X TO FP (.25)
3671 f6f3 bd f1 0d           	JSR	LB9C2	ADD .25 (PI/2) TO FPA0
3672 f6f6 35 02              	PULS	A	GET OLD MANTISSA SIGN
3673 f6f8 4d                 	TSTA		* BRANCH IF OLD
3674 f6f9 2a 03              	BPL	LBFB7	* SIGN WAS POSITIVE
3675 f6fb bd f6 34           	JSR	LBEE9	TOGGLE MANTISSA SIGN
3676 f6fe 8e f7 0e           LBFB7	LDX	#LBFC7	POINT X TO TABLE OF COEFFICIENTS
3677 f701 7e f6 3b           	JMP	LBEF0	GO CALCULATE POLYNOMIAL VALUE
3678                         
3679 f704 83 49 0f da a2     LBFBD	FCB	$83,$49,$0F,$DA,$A2 6.28318531 (2*PI)
3680 f709 7f 00 00 00 00     LBFC2	FCB	$7F,$00,$00,$00,$00 .25
3681                         
3682                         
3683 f70e 05                 LBFC7	FCB	6-1	SIX COEFFICIENTS
3684 f70f 84 e6 1a 2d 1b     LBFC8	FCB	$84,$E6,$1A,$2D,$1B * -((2*PI)**11)/11!
3685 f714 86 28 07 fb f8     LBFCD	FCB	$86,$28,$07,$FB,$F8 * ((2*PI)**9)/9!
3686 f719 87 99 68 89 01     LBFD2	FCB	$87,$99,$68,$89,$01 * -((2*PI)**7)/7!
3687 f71e 87 23 35 df e1     LBFD7	FCB	$87,$23,$35,$DF,$E1 * ((2*PI)**5)/5!
3688 f723 86 a5 5d e7 28     LBFDC	FCB	$86,$A5,$5D,$E7,$28 * -((2*PI)**3)/3!
3689 f728 83 49 0f da a2     LBFE1	FCB	$83,$49,$0F,$DA,$A2 *
3690                         
3691 f72d a1 54 46 8f 13     	FCB	$A1,$54,$46,$8F,$13 UNUSED GARBAGE BYTES
3692 f732 8f 52 43 89 cd     	FCB	$8F,$52,$43,$89,$CD UNUSED GARBAGE BYTES
3693                         * EXTENDED BASIC
3694                         
3695                         * COS
3696                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
3697 f737 8e f7 6a           COS	LDX	#L83AB	POINT X TO FP CONSTANT (P1/2)
3698 f73a bd f1 0d           	JSR	LB9C2	ADD FPA0 TO (X)
3699 f73d 7e f6 bf           L837E	JMP	SIN	JUMP TO SIN ROUTINE
3700                         
3701                         * TAN
3702                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
3703 f740 bd f3 7a           TAN	JSR	LBC2F	PACK FPA0 AND MOVE IT TO FPA3
3704 f743 0f 0a              	CLR	RELFLG	RESET QUADRANT FLAG
3705 f745 8d f6              	BSR	L837E	CALCULATE SIN OF ARGUMENT
3706 f747 8e 00 4a           	LDX	#V4A	POINT X TO FPA5
3707 f74a bd f3 80           	JSR	LBC35	PACK FPA0 AND MOVE IT TO FPA5
3708 f74d 8e 00 40           	LDX	#V40	POINT X TO FPA3
3709 f750 bd f3 5f           	JSR	LBC14	MOVE FPA3 TO FPA0
3710 f753 0f 54              	CLR	FP0SGN	FORCE FPA0 MANTISSA TO BE POSITIVE
3711 f755 96 0a              	LDA	RELFLG	GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
3712 f757 8d 0c              	BSR	L83A6	CALCULATE VALUE OF COS(FPA0)
3713 f759 0d 4f              	TST	FP0EXP	CHECK EXPONENT OF FPA0
3714 f75b 10 27 fa 7e        	LBEQ	LBA92	'OV' ERROR IF COS(X)=0
3715 f75f 8e 00 4a           	LDX	#V4A	POINT X TO FPA5
3716 f762 7e f2 da           L83A3	JMP	LBB8F	DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
3717 f765 34 02              L83A6	PSHS	A	SAVE SIGN FLAG ON STACK
3718 f767 7e f6 ed           	JMP	LBFA6	EXPAND POLYNOMIAL
3719                         
3720 f76a 81 49 0f da a2     L83AB	FCB	$81,$49,$0F,$DA,$A2 1.57079633 (PI/2)
3721                         
3722                         * ATN
3723                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
3724                         * ARCTAN EXPRESSION. TWO	DIFFERENT FORMULI ARE USED
3725                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
3726                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
3727                         
3728                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
3729                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
3730                         
3731 f76f 96 54              ATN	LDA	FP0SGN	* GET THE SIGN OF THE MANTISSA AND
3732 f771 34 02              	PSHS	A	* SAVE IT ON THE STACK
3733 f773 2a 02              	BPL	L83B8	BRANCH IF POSITIVE MANTISSA
3734 f775 8d 24              	BSR	L83DC	CHANGE SIGN OF FPA0
3735 f777 96 4f              L83B8	LDA	FP0EXP	* GET EXPONENT OF FPA0 AND
3736 f779 34 02              	PSHS	A	* SAVE IT ON THE STACK
3737 f77b 81 81              	CMPA	#$81	IS FPAO < 1.0?
3738 f77d 25 05              	BLO	L83C5	YES
3739 f77f 8e f2 10           	LDX	#LBAC5	POINT X TO FP CONSTANT 1.0
3740 f782 8d de              	BSR	L83A3	GET RECIPROCAL OF FPA0
3741 f784 8e f7 9f           L83C5	LDX	#L83E0	POINT (X) TO TAYLOR SERIES COEFFICIENTS
3742 f787 bd f6 3b           	JSR	LBEF0	EXPAND POLYNOMIAL
3743 f78a 35 02              	PULS	A	GET EXPONENT OF ARGUMENT
3744 f78c 81 81              	CMPA	#$81	WAS ARGUMENT < 1.0?
3745 f78e 25 06              	BLO	L83D7	YES
3746 f790 8e f7 6a           	LDX	#L83AB	POINT (X) TO FP NUMBER (PI/2)
3747 f793 bd f1 04           	JSR	LB9B9	SUBTRACT FPA0 FROM (PI/2)
3748 f796 35 02              L83D7	PULS	A	* GET SIGN OF INITIAL ARGUMENT MANTISSA
3749 f798 4d                 	TSTA		* AND SET FLAGS ACCORDING TO IT
3750 f799 2a 03              	BPL	L83DF	RETURN IF ARGUMENT WAS POSITIVE
3751 f79b 7e f6 34           L83DC	JMP	LBEE9	CHANGE MANTISSA SIGN OF FPA0
3752 f79e 39                 L83DF	RTS
3753                         *
3754                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
3755 f79f 0b                 L83E0	FCB	$0B	TWELVE COEFFICIENTS
3756 f7a0 76 b3 83 bd d3     L83E1	FCB	$76,$B3,$83,$BD,$D3 -6.84793912E-04 1/23
3757 f7a5 79 1e f4 a6 f5     L83E6	FCB	$79,$1E,$F4,$A6,$F5 +4.85094216E-03 1/21
3758 f7aa 7b 83 fc b0 10     L83EB	FCB	$7B,$83,$FC,$B0,$10 -0.0161117018
3759 f7af 7c 0c 1f 67 ca     L83F0	FCB	$7C,$0C,$1F,$67,$CA 0.0342096381
3760 f7b4 7c de 53 cb c1     L83F5	FCB	$7C,$DE,$53,$CB,$C1 -0.0542791328
3761 f7b9 7d 14 64 70 4c     L83FA	FCB	$7D,$14,$64,$70,$4C 0.0724571965
3762 f7be 7d b7 ea 51 7a     L83FF	FCB	$7D,$B7,$EA,$51,$7A -0.0898023954
3763 f7c3 7d 63 30 88 7e     L8404	FCB	$7D,$63,$30,$88,$7E 0.110932413
3764 f7c8 7e 92 44 99 3a     L8409	FCB	$7E,$92,$44,$99,$3A -0.142839808
3765 f7cd 7e 4c cc 91 c7     L840E	FCB	$7E,$4C,$CC,$91,$C7 0.199999121
3766 f7d2 7f aa aa aa 13     L8413	FCB	$7F,$AA,$AA,$AA,$13 -0.333333316
3767 f7d7 81 00 00 00 00     L8418	FCB	$81,$00,$00,$00,$00 1
3768                         *
3769                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
3770                         *
3771 f7dc 03                 L841D	FCB	3	FOUR COEFFICIENTS
3772 f7dd 7f 5e 56 cb 79     L841E	FCB	$7F,$5E,$56,$CB,$79 0.434255942
3773 f7e2 80 13 9b 0b 64     L8423	FCB	$80,$13,$9B,$0B,$64 0.576584541
3774 f7e7 80 76 38 93 16     L8428	FCB	$80,$76,$38,$93,$16 0.961800759
3775 f7ec 82 38 aa 3b 20     L842D	FCB	$82,$38,$AA,$3B,$20 2.88539007
3776                         
3777 f7f1 80 35 04 f3 34     L8432	FCB	$80,$35,$04,$F3,$34 1/SQR(2)
3778                         
3779 f7f6 81 35 04 f3 34     L8437	FCB	$81,$35,$04,$F3,$34 SQR(2)
3780                         
3781 f7fb 80 80 00 00 00     L843C	FCB	$80,$80,$00,$00,$00 -0.5
3782                         
3783 f800 80 31 72 17 f8     L8441	FCB	$80,$31,$72,$17,$F8 LN(2)
3784                         *
3785                         * LOG - NATURAL LOGARITHM (LN)
3786                         
3787                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
3788                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
3789                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
3790                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
3791                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
3792                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
3793                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
3794 f805 bd f3 b8           LOG	JSR	LBC6D	CHECK STATUS OF FPA0
3795 f808 10 2f f3 c7        	LBLE	LB44A	'FC' ERROR IF NEGATIVE OR ZERO
3796 f80c 8e f7 f1           	LDX	#L8432	POINT (X) TO FP NUMBER (1/SQR(2))
3797 f80f 96 4f              	LDA	FP0EXP	*GET EXPONENT OF ARGUMENT
3798 f811 80 80              	SUBA	#$80	*SUBTRACT OFF THE BIAS AND
3799 f813 34 02              	PSHS	A	*SAVE IT ON THE STACK
3800 f815 86 80              	LDA	#$80
3801 f817 97 4f              	STA	FP0EXP
3802 f819 bd f1 0d           	JSR	LB9C2	ADD FPA0 TO (X)
3803 f81c 8e f7 f6           	LDX	#L8437	POINT X TO SQR(2)
3804 f81f bd f2 da           	JSR	LBB8F	DIVIDE SQR(2) BY FPA0
3805 f822 8e f2 10           	LDX	#LBAC5	POINT X TO FP VALUE OF 1.00
3806 f825 bd f1 04           	JSR	LB9B9	SUBTRACT FPA0 FROM (X)
3807                         *	NOW	FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
3808 f828 8e f7 dc           	LDX	#L841D	POINT X TO TABLE OF COEFFICIENTS
3809 f82b bd f6 3b           	JSR	LBEF0	EXPAND POLYNOMIAL
3810 f82e 8e f7 fb           	LDX	#L843C	POINT X TO FP VALUE OF (-.5)
3811 f831 bd f1 0d           	JSR	LB9C2	ADD FPA0 TO X
3812 f834 35 04              	PULS	B	GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
3813 f836 bd f4 e4           	JSR	LBD99	ADD ACCB TO FPA0
3814 f839 8e f8 00           	LDX	#L8441	POINT X TO LN(2)
3815 f83c 7e f2 15           	JMP	LBACA	MULTIPLY FPA0 * LN(2)
3816                         
3817                         * SQR
3818 f83f bd f3 aa           SQR	JSR	LBC5F	MOVE FPA0 TO FPA1
3819 f842 8e f6 0b           	LDX	#LBEC0	POINT (X) TO FP NUMBER (.5)
3820 f845 bd f3 5f           	JSR	LBC14	COPY A PACKED NUMBER FROM (X) TO FPA0
3821                         
3822                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
3823                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
3824                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
3825 f848 27 67              L8489	BEQ	EXP	DO A NATURAL EXPONENTIATION IF EXPONENT = 0
3826 f84a 4d                 	TSTA		*CHECK VALUE BEING EXPONENTIATED
3827 f84b 26 03              	BNE	L8491	*AND BRANCH IF IT IS <> 0
3828 f84d 7e f1 85           	JMP	LBA3A	FPA0=0 IF RAISING ZERO TO A POWER
3829 f850 8e 00 4a           L8491	LDX	#V4A	* PACK FPA0 AND SAVE
3830 f853 bd f3 80           	JSR	LBC35	* IT IN FPA5 (ARGUMENT'S EXPONENT)
3831 f856 5f                 	CLRB		ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
3832 f857 96 61              	LDA	FP1SGN	*CHECK THE SIGN OF ARGUMENT
3833 f859 2a 10              	BPL	L84AC	*BRANCH IF POSITIVE
3834 f85b bd f4 39           	JSR	INT	CONVERT EXPONENT INTO AN INTEGER
3835 f85e 8e 00 4a           	LDX	#V4A	POINT X TO FPA5 (ORIGINAL EXPONENT)
3836 f861 96 61              	LDA	FP1SGN	GET MANTISSA SIGN OF FPA1 (ARGUMENT)
3837 f863 bd f3 eb           	JSR	LBCA0	*COMPARE FPA0 TO (X) AND
3838 f866 26 03              	BNE	L84AC	*BRANCH IF NOT EQUAL
3839 f868 43                 	COMA		TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
3840 f869 d6 01              	LDB	CHARAC	GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
3841 f86b bd f3 97           L84AC	JSR	LBC4C	COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
3842 f86e 34 04              	PSHS	B	PUT RESULT SIGN FLAG ON THE STACK
3843 f870 bd f8 05           	JSR	LOG
3844 f873 8e 00 4a           	LDX	#V4A	POINT (X) TO FPA5
3845 f876 bd f2 15           	JSR	LBACA	MULTIPLY FPA0 BY FPA5
3846 f879 8d 36              	BSR	EXP	CALCULATE E**(FPA0)
3847 f87b 35 02              	PULS	A	* GET RESULT SIGN FLAG FROM THE STACK
3848 f87d 46                 	RORA		* AND BRANCH IF NEGATIVE
3849 f87e 10 25 fd b2        	LBCS	LBEE9	CHANGE SIGN OF FPA0 MANTISSA
3850 f882 39                 	RTS
3851                         
3852                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
3853 f883 81 38 aa 3b 29     L84C4	FCB	$81,$38,$AA,$3B,$29 1.44269504 ( CF )
3854                         *
3855                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
3856                         *
3857 f888 07                 L84C9	FCB	7	EIGHT COEFFICIENTS
3858 f889 71 34 58 3e 56     L84CA	FCB	$71,$34,$58,$3E,$56 2.14987637E-05: 1/(7!*(CF**7))
3859 f88e 74 16 7e b3 1b     L84CF	FCB	$74,$16,$7E,$B3,$1B 1.4352314E-04 : 1/(6!*(CF**6))
3860 f893 77 2f ee e3 85     L84D4	FCB	$77,$2F,$EE,$E3,$85 1.34226348E-03: 1/(5!*(CF**5))
3861 f898 7a 1d 84 1c 2a     L84D9	FCB	$7A,$1D,$84,$1C,$2A 9.61401701E-03: 1/(4!*(CF**4))
3862 f89d 7c 63 59 58 0a     L84DE	FCB	$7C,$63,$59,$58,$0A 0.0555051269
3863 f8a2 7e 75 fd e7 c6     L84E3	FCB	$7E,$75,$FD,$E7,$C6 0.240226385
3864 f8a7 80 31 72 18 10     L84E8	FCB	$80,$31,$72,$18,$10 0.693147186
3865 f8ac 81 00 00 00 00     L84ED	FCB	$81,$00,$00,$00,$00 1
3866                         *
3867                         * EXP ( E**X)
3868                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
3869                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
3870                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
3871                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
3872                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
3873                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
3874                         
3875 f8b1 8e f8 83           EXP	LDX	#L84C4	POINT X TO THE CORRECTION FACTOR
3876 f8b4 bd f2 15           	JSR	LBACA	MULTIPLY FPA0 BY (X)
3877 f8b7 bd f3 7a           	JSR	LBC2F	PACK FPA0 AND STORE IT IN FPA3
3878 f8ba 96 4f              	LDA	FP0EXP	*GET EXPONENT OF FPA0 AND
3879 f8bc 81 88              	CMPA	#$88	*COMPARE TO THE MAXIMUM VALUE
3880 f8be 25 03              	BLO	L8504	BRANCH IF FPA0 < 128
3881 f8c0 7e f2 a7           L8501	JMP	LBB5C	SET FPA0 = 0 OR 'OV' ERROR
3882 f8c3 bd f4 39           L8504	JSR	INT	CONVERT FPA0 TO INTEGER
3883 f8c6 96 01              	LDA	CHARAC	GET LS BYTE OF INTEGER
3884 f8c8 8b 81              	ADDA	#$81	* WAS THE ARGUMENT =127, IF SO
3885 f8ca 27 f4              	BEQ	L8501	* THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
3886                         *	* REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
3887 f8cc 4a                 	DECA		DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
3888 f8cd 34 02              	PSHS	A	SAVE EXPONENT OF INTEGER PORTION ON STACK
3889 f8cf 8e 00 40           	LDX	#V40	POINT (X) TO FPA3
3890 f8d2 bd f1 04           	JSR	LB9B9	SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
3891 f8d5 8e f8 88           	LDX	#L84C9	POINT X TO COEFFICIENTS
3892 f8d8 bd f6 4a           	JSR	LBEFF	EVALUATE POLYNOMIAL FOR FRACTIONAL PART
3893 f8db 0f 62              	CLR	RESSGN	FORCE THE MANTISSA TO BE POSITIVE
3894 f8dd 35 02              	PULS	A	GET INTEGER EXPONENT FROM STACK
3895 f8df bd f2 93           	JSR	LBB48	* CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
3896                         *	* INTEGER AND FRACTIONAL PARTS
3897 f8e2 39                 	RTS
3898                         
3899                         * FIX
3900 f8e3 bd f3 b8           FIX	JSR	LBC6D	CHECK STATUS OF FPA0
3901 f8e6 2b 03              	BMI	L852C	BRANCH IF FPA0 = NEGATIVE
3902 f8e8 7e f4 39           L8529	JMP	INT	CONVERT FPA0 TO INTEGER
3903 f8eb 03 54              L852C	COM	FP0SGN	TOGGLE SIGN OF FPA0 MANTISSA
3904 f8ed 8d f9              	BSR	L8529	CONVERT FPA0 TO INTEGER
3905 f8ef 7e f6 34           	JMP	LBEE9	TOGGLE SIGN OF FPA0
3906                         
3907                         * EDIT
3908 f8f2 bd fd 20           EDIT	JSR	L89AE	GET LINE NUMBER FROM BASIC
3909 f8f5 32 62              	LEAS	$02,S PURGE RETURN ADDRESS OFF OF THE STACK
3910 f8f7 86 01              L8538	LDA	#$01	'LIST' FLAG
3911 f8f9 97 98              	STA	VD8	SET FLAG TO LIST LINE
3912 f8fb bd e4 a7           	JSR	LAD01	GO FIND THE LINE NUMBER IN PROGRAM
3913 f8fe 10 25 ed 82        	LBCS	LAED2 ERROR #7 'UNDEFINED LINE #'
3914 f902 bd ef 40           	JSR	LB7C2	GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
3915 f905 1f 20              	TFR	Y,D	PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
3916 f907 83 00 f5           	SUBD	#LINBUF+2 SUBTRACT OUT THE START OF LINE
3917 f90a d7 97              	STB	VD7	SAVE LENGTH OF LINE
3918 f90c dc 2b              L854D	LDD	BINVAL	GET THE HEX VALUE OF LINE NUMBER
3919 f90e bd f5 17           	JSR	LBDCC	LIST THE LINE NUMBER ON THE SCREEN
3920 f911 bd f0 f7           	JSR	LB9AC	PRINT A SPACE
3921 f914 8e 00 f4           	LDX	#LINBUF+1	POINT X TO BUFFER
3922 f917 d6 98              	LDB	VD8	* CHECK TO SEE IF LINE IS TO BE
3923 f919 26 25              	BNE	L8581	* LISTED TO SCREEN - BRANCH IF IT IS
3924 f91b 5f                 L855C	CLRB		RESET DIGIT ACCUMULATOR - DEFAULT VALUE
3925 f91c bd fa 46           L855D	JSR	L8687	GET KEY STROKE
3926 f91f bd ff 78           	JSR	L90AA	SET CARRY IF NOT NUMERIC
3927 f922 25 0b              	BLO	L8570	BRANCH IF NOT NUMERIC
3928 f924 80 30              	SUBA	#'0' MASK OFF ASCII
3929 f926 34 02              	PSHS	A SAVE IT ON STACK
3930 f928 86 0a              	LDA	#10	NUMBER BEING CONVERTED IS BASE 10
3931 f92a 3d                 	MUL	MULTIPLY ACCUMULATED VALUE BY BASE (10)
3932 f92b eb e0              	ADDB	,S+ ADD DIGIT TO ACCUMULATED VALUE
3933 f92d 20 ed              	BRA	L855D	CHECK FOR ANOTHER DIGIT
3934 f92f c0 01              L8570	SUBB	#$01 * REPEAT PARAMETER IN ACCB; IF IT
3935 f931 c9 01              	ADCB	#$01 *IS 0, THEN MAKE IT �1� 
3936 f933 81 41              	CMPA	#'A' ABORT?
3937 f935 26 05              	BNE	L857D	NO
3938 f937 bd f0 a7           	JSR	LB958	PRINT CARRIAGE RETURN TO SCREEN
3939 f93a 20 bb              	BRA	L8538	RESTART EDIT PROCESS - CANCEL ALL CHANGES
3940 f93c 81 4c              L857D	CMPA	#'L' LIST?
3941 f93e 26 0b              	BNE	L858C	NO
3942 f940 8d 31              L8581	BSR	L85B4	LIST THE LINE
3943 f942 0f 98              	CLR	VD8	RESET THE LIST FLAG TO �NO LIST� 
3944 f944 bd f0 a7           	JSR	LB958	PRINT CARRIAGE RETURN
3945 f947 20 c3              	BRA	L854D	GO INTERPRET ANOTHER EDIT COMMAND
3946 f949 32 62              L858A	LEAS	$02,S PURGE RETURN ADDRESS OFF OF THE STACK
3947 f94b 81 0d              L858C	CMPA	#CR ENTER KEY?
3948 f94d 26 0d              	BNE	L859D	NO
3949 f94f 8d 22              	BSR	L85B4	ECHO THE LINE TO THE SCREEN
3950 f951 bd f0 a7           L8592	JSR	LB958	PRINT CARRIAGE RETURN
3951 f954 8e 00 f4           	LDX	#LINBUF+1	* RESET BASIC�S INPUT POINTER
3952 f957 9f 83              	STX	CHARAD	* TO THE LINE INPUT BUFFER
3953 f959 7e e4 50           	JMP	LACA8	GO PUT LINE BACK IN PROGRAM
3954 f95c 81 45              L859D	CMPA	#'E' EXIT?
3955 f95e 27 f1              	BEQ	L8592	YES - SAME AS ENTER EXCEPT NO ECHO
3956 f960 81 51              	CMPA	#'Q' QUIT?
3957 f962 26 06              	BNE	L85AB	NO
3958 f964 bd f0 a7           	JSR	LB958	PRINT CARRIAGE RETURN TO SCREEN
3959 f967 7e e4 27           	JMP	LAC73	GO TO COMMAND LEVEL - MAKE NO CHANGES
3960 f96a 8d 02              L85AB	BSR	L85AF	INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
3961 f96c 20 ad              	BRA	L855C	GO INTERPRET ANOTHER EDIT COMMAND
3962 f96e 81 20              L85AF	CMPA	#SPACE SPACE BAR?
3963 f970 26 10              	BNE	L85C3	NO
3964 f972 8c                 L85B3	FCB	SKP2	SKIP TWO BYTES
3965                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
3966                         *
3967 f973 c6 f9              L85B4	LDB	#LBUFMX-1	250 BYTES MAX IN BUFFER
3968 f975 a6 84              L85B6	LDA	,X	GET A CHARACTER FROM BUFFER
3969 f977 27 08              	BEQ	L85C2	EXIT IF IT'S A 0
3970 f979 bd e0 14           	JSR	PUTCHR	SEND CHAR TO CONSOLE OUT
3971 f97c 30 01              	LEAX	$01,X MOVE POINTER UP ONE
3972 f97e 5a                 	DECB	DECREMENT CHARACTER COUNTER
3973 f97f 26 f4              	BNE	L85B6	LOOP IF NOT DONE
3974 f981 39                 L85C2	RTS
3975 f982 81 44              L85C3	CMPA	#'D' DELETE?
3976 f984 26 48              	BNE	L860F	NO
3977 f986 6d 84              L85C7	TST	,X	* CHECK FOR END OF LINE
3978 f988 27 f7              	BEQ	L85C2	* AND BRANCH IF SO
3979 f98a 8d 04              	BSR	L85D1	REMOVE A CHARACTER
3980 f98c 5a                 	DECB	DECREMENT REPEAT PARAMETER
3981 f98d 26 f7              	BNE	L85C7	BRANCH IF NOT DONE
3982 f98f 39                 	RTS
3983                         * REMOVE ONE CHARACTER FROM BUFFER
3984 f990 0a 97              L85D1	DEC	VD7	DECREMENT LENGTH OF BUFFER
3985 f992 31 1f              	LEAY	$-01,X POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
3986 f994 31 21              L85D5	LEAY	$01,Y INCREMENT TEMPORARY BUFFER POINTER
3987 f996 a6 21              	LDA	$01,Y	GET NEXT CHARACTER
3988 f998 a7 a4              	STA	,Y	PUT IT IN CURRENT POSITION
3989 f99a 26 f8              	BNE	L85D5	BRANCH IF NOT END OF LINE
3990 f99c 39                 	RTS
3991 f99d 81 49              L85DE	CMPA	#'I' INSERT?
3992 f99f 27 13              	BEQ	L85F5	YES
3993 f9a1 81 58              	CMPA	#'X' EXTEND?
3994 f9a3 27 0d              	BEQ	L85F3	YES
3995 f9a5 81 48              	CMPA	#'H' HACK?
3996 f9a7 26 5c              	BNE	L8646	NO
3997 f9a9 6f 84              	CLR	,X	TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
3998 f9ab 1f 10              	TFR	X,D	PUT CURRENT BUFFER POINTER IN ACCD
3999 f9ad 83 00 f5           	SUBD	#LINBUF+2 SUBTRACT INITIAL POINTER POSITION
4000 f9b0 d7 97              	STB	VD7	SAVE NEW BUFFER LENGTH
4001 f9b2 8d bf              L85F3	BSR	L85B4	DISPLAY THE LINE ON THE SCREEN
4002 f9b4 bd fa 46           L85F5	JSR	L8687	GET A KEYSTROKE
4003 f9b7 81 0d              	CMPA	#CR ENTER KEY?
4004 f9b9 27 8e              	BEQ	L858A	YES - INTERPRET ANOTHER COMMAND - PRINT LINE
4005 f9bb 81 1b              	CMPA	#ESC ESCAPE?
4006 f9bd 27 25              	BEQ	L8625	YES - RETURN TO COMMAND LEVEL - DON�T PRINT LINE
4007 f9bf 81 08              	CMPA	#BS BACK SPACE?
4008 f9c1 26 22              	BNE	L8626	NO
4009 f9c3 8c 00 f4           	CMPX	#LINBUF+1 COMPARE POINTER TO START OF BUFFER
4010 f9c6 27 ec              	BEQ	L85F5	DO NOT ALLOW BS IF AT START
4011 f9c8 8d 45              	BSR	L8650	MOVE POINTER BACK ONE, BS TO SCREEN
4012 f9ca 8d c4              	BSR	L85D1	REMOVE ONE CHARACTER FROM BUFFER
4013 f9cc 20 e6              	BRA	L85F5	GET INSERT SUB COMMAND
4014 f9ce 81 43              L860F	CMPA	#'C' CHANGE?
4015 f9d0 26 cb              	BNE	L85DE	NO
4016 f9d2 6d 84              L8613	TST	,X	CHECK CURRENT BUFFER CHARACTER
4017 f9d4 27 0e              	BEQ	L8625	BRANCH IF END OF LINE
4018 f9d6 bd fa 46           	JSR	L8687	GET A KEYSTROKE
4019 f9d9 25 02              	BLO	L861E	BRANCH IF LEGITIMATE KEY
4020 f9db 20 f5              	BRA	L8613	TRY AGAIN IF ILLEGAL KEY
4021 f9dd a7 80              L861E	STA	,X+	INSERT NEW CHARACTER INTO BUFFER
4022 f9df 8d 37              	BSR	L8659	SEND NEW CHARACTER TO SCREEN
4023 f9e1 5a                 	DECB	DECREMENT REPEAT PARAMETER
4024 f9e2 26 ee              	BNE	L8613	BRANCH IF NOT DONE
4025 f9e4 39                 L8625	RTS
4026 f9e5 d6 97              L8626	LDB	VD7	GET LENGTH OF LINE
4027 f9e7 c1 f9              	CMPB	#LBUFMX-1 COMPARE TO MAXIMUM LENGTH
4028 f9e9 26 02              	BNE	L862E	BRANCH IF NOT AT MAXIMUM
4029 f9eb 20 c7              	BRA	L85F5	IGNORE INPUT IF LINE AT MAXIMUM LENGTH
4030 f9ed 34 10              L862E	PSHS	X SAVE CURRENT BUFFER POINTER
4031 f9ef 6d 80              L8630	TST	,X+	* SCAN THE LINE UNTIL END OF
4032 f9f1 26 fc              	BNE	L8630	* LINE (0) IS FOUND
4033 f9f3 e6 82              L8634	LDB	,-X	DECR TEMP LINE POINTER AND GET A CHARACTER
4034 f9f5 e7 01              	STB	$01,X	PUT CHARACTER BACK DOWN ONE SPOT
4035 f9f7 ac e4              	CMPX	,S HAVE WE REACHED STARTING POINT?
4036 f9f9 26 f8              	BNE	L8634	NO - KEEP GOING
4037 f9fb 32 62              	LEAS	$02,S PURGE BUFFER POINTER FROM STACK
4038 f9fd a7 80              	STA	,X+	INSERT NEW CHARACTER INTO THE LINE
4039 f9ff 8d 17              	BSR	L8659	SEND A CHARACTER TO CONSOLE OUT
4040 fa01 0c 97              	INC	VD7	ADD ONE TO BUFFER LENGTH
4041 fa03 20 af              	BRA	L85F5	GET INSERT SUB COMMAND
4042 fa05 81 08              L8646	CMPA	#BS BACKSPACE?
4043 fa07 26 12              	BNE	L865C	NO
4044 fa09 8d 04              L864A	BSR	L8650	MOVE POINTER BACK 1, SEND BS TO SCREEN
4045 fa0b 5a                 	DECB	DECREMENT REPEAT PARAMETER
4046 fa0c 26 fb              	BNE	L864A	LOOP UNTIL DONE
4047 fa0e 39                 	RTS
4048 fa0f 8c 00 f4           L8650	CMPX	#LINBUF+1 COMPARE POINTER TO START OF BUFFER
4049 fa12 27 d0              	BEQ	L8625	DO NOT ALLOW BS IF AT START
4050 fa14 30 1f              	LEAX	$-01,X MOVE POINTER BACK ONE
4051 fa16 86 08              	LDA	#BS	BACK SPACE
4052 fa18 7e e0 14           L8659	JMP	PUTCHR	SEND TO CONSOLE OUT
4053 fa1b 81 4b              L865C	CMPA	#'K' KILL?
4054 fa1d 27 05              	BEQ	L8665	YES
4055 fa1f 80 53              	SUBA	#'S' SEARCH?
4056 fa21 27 01              	BEQ	L8665	YES
4057 fa23 39                 	RTS
4058 fa24 34 02              L8665	PSHS	A SAVE KILL/SEARCH FLAG ON STACK
4059 fa26 8d 1e              	BSR	L8687	* GET A KEYSTROKE (TARGET CHARACTER)
4060 fa28 34 02              	PSHS	A * AND SAVE IT ON STACK
4061 fa2a a6 84              L866B	LDA	,X	GET CURRENT BUFFER CHARACTER
4062 fa2c 27 16              	BEQ	L8685	AND RETURN IF END OF LINE
4063 fa2e 6d 61              	TST	$01,S	CHECK KILL/SEARCH FLAG
4064 fa30 26 06              	BNE	L8679	BRANCH IF KILL
4065 fa32 8d e4              	BSR	L8659	SEND A CHARACTER TO CONSOLE OUT
4066 fa34 30 01              	LEAX	$01,X INCREMENT BUFFER POINTER
4067 fa36 20 03              	BRA	L867C	CHECK NEXT INPUT CHARACTER
4068 fa38 bd f9 90           L8679	JSR	L85D1	REMOVE ONE CHARACTER FROM BUFFER
4069 fa3b a6 84              L867C	LDA	,X	GET CURRENT INPUT CHARACTER
4070 fa3d a1 e4              	CMPA	,S COMPARE TO TARGET CHARACTER
4071 fa3f 26 e9              	BNE	L866B	BRANCH IF NO MATCH
4072 fa41 5a                 	DECB	DECREMENT REPEAT PARAMETER
4073 fa42 26 e6              	BNE	L866B	BRANCH IF NOT DONE
4074 fa44 35 a0              L8685	PULS	Y,PC THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
4075                         *
4076                         * GET A KEYSTRKE
4077 fa46 bd e0 00           L8687	JSR	LA171	CALL CONSOLE IN : DEV NBR=SCREEN
4078 fa49 81 7f              	CMPA	#$7F GRAPHIC CHARACTER?
4079 fa4b 24 f9              	BCC	L8687	YES - GET ANOTHER CHAR
4080 fa4d 81 5f              	CMPA	#$5F SHIFT UP ARROW (QUIT INSERT)
4081 fa4f 26 02              	BNE	L8694	NO
4082 fa51 86 1b              	LDA	#ESC	REPLACE W/ESCAPE CODE
4083 fa53 81 0d              L8694	CMPA	#CR ENTER KEY
4084 fa55 27 0e              	BEQ	L86A6	YES
4085 fa57 81 1b              	CMPA	#ESC ESCAPE?
4086 fa59 27 0a              	BEQ	L86A6	YES
4087 fa5b 81 08              	CMPA	#BS BACKSPACE?
4088 fa5d 27 06              	BEQ	L86A6	YES
4089 fa5f 81 20              	CMPA	#SPACE SPACE
4090 fa61 25 e3              	BLO	L8687	GET ANOTHER CHAR IF CONTROL CHAR
4091 fa63 1a 01              	ORCC	#$01 SET CARRY
4092 fa65 39                 L86A6	RTS
4093                         
4094                         * TRON
4095 fa66 86                 TRON	FCB	SKP1LD	SKIP ONE BYTE AND LDA #$4F
4096                         
4097                         * TROFF
4098 fa67 4f                 TROFF	CLRA		TROFF FLAG
4099 fa68 97 8c              	STA	TRCFLG	TRON/TROFF FLAG:0=TROFF, <> 0=TRON
4100 fa6a 39                 	RTS
4101                         
4102                         * POS
4103                         
4104 fa6b 86 00              POS	LDA	#0	GET DEVICE NUMBER
4105 fa6d d6 79              	LDB	LPTPOS	GET PRINT POSITION
4106 fa6f 1d                 LA5E8	SEX		CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
4107 fa70 7e ec 7d           	JMP	GIVABF	CONVERT ACCD TO FLOATING POINT
4108                         
4109                         
4110                         * VARPTR
4111 fa73 bd e9 f8           VARPT	JSR	LB26A	SYNTAX CHECK FOR '('
4112 fa76 dc 1f              	LDD	ARYEND	GET ADDR OF END OF ARRAYS
4113 fa78 34 06              	PSHS	B,A	SAVE IT ON STACK
4114 fa7a bd ea e0           	JSR	LB357	GET VARIABLE DESCRIPTOR
4115 fa7d bd e9 f5           	JSR	LB267	SYNTAX CHECK FOR �)� 
4116 fa80 35 06              	PULS	A,B	GET END OF ARRAYS ADDR BACK
4117 fa82 1e 10              	EXG	X,D	SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
4118 fa84 9c 1f              	CMPX	ARYEND	COMPARE TO NEW END OF ARRAYS
4119 fa86 26 51              	BNE	L8724	'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
4120 fa88 7e ec 7d           	JMP	GIVABF	CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
4121                         
4122                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
4123 fa8b 9d 7c              L86D6	JSR	GETNCH	GET INPUT CHAR FROM BASIC
4124 fa8d bd e9 f8           	JSR	LB26A	SYNTAX CHECK FOR �(� 
4125 fa90 bd ea e0           	JSR	LB357	* GET VARIABLE DESCRIPTOR ADDRESS AND
4126 fa93 34 10              	PSHS	X	* SAVE IT ON THE STACK
4127 fa95 ec 02              	LDD	$02,X	POINT ACCD TO START OF OLDSTRING
4128 fa97 10 93 21           	CMPD	FRETOP	COMPARE TO START OF CLEARED SPACE
4129 fa9a 23 04              	BLS	L86EB	BRANCH IF <=
4130 fa9c 93 27              	SUBD	MEMSIZ	SUBTRACT OUT TOP OF CLEARED SPACE
4131 fa9e 23 12              	BLS	L86FD	BRANCH IF STRING IN STRING SPACE
4132 faa0 e6 84              L86EB	LDB	,X	GET LENGTH OF OLDSTRING
4133 faa2 bd ec f6           	JSR	LB56D	RESERVE ACCB BYTES IN STRING SPACE
4134 faa5 34 10              	PSHS	X	SAVE RESERVED SPACE STRING ADDRESS ON STACK
4135 faa7 ae 62              	LDX	$02,S	POINT X TO OLDSTRING DESCRIPTOR
4136 faa9 bd ed cc           	JSR	LB643	MOVE OLDSTRING INTO STRING SPACE
4137 faac 35 50              	PULS	X,U	* GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
4138 faae af 42              	STX	$02,U	* ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
4139 fab0 34 40              	PSHS	U	SAVE OLDSTRING DESCRIPTOR ADDRESS
4140 fab2 bd ee c1           L86FD	JSR	LB738	SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4141 fab5 34 04              	PSHS	B	SAVE POSITION PARAMETER ON STACK
4142 fab7 5d                 	TSTB	* CHECK POSITION PARAMETER AND BRANCH
4143 fab8 27 1f              	BEQ	L8724	* IF START OF STRING
4144 faba c6 ff              	LDB	#$FF	DEFAULT REPLACEMENT LENGTH = $FF
4145 fabc 81 29              	CMPA	#')'	* CHECK FOR END OF MID$ STATEMENT AND
4146 fabe 27 03              	BEQ	L870E	* BRANCH IF AT END OF STATEMENT
4147 fac0 bd ee c1           	JSR	LB738	SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4148 fac3 34 04              L870E	PSHS	B	SAVE LENGTH PARAMETER ON STACK
4149 fac5 bd e9 f5           	JSR	LB267	SYNTAX CHECK FOR �)� 
4150 fac8 c6 ae              	LDB	#TOK_EQUALS	TOKEN FOR =
4151 faca bd e9 fd           	JSR	LB26F	SYNTAX CHECK FOR �=� 
4152 facd 8d 2e              	BSR	L8748	EVALUATE REPLACEMENT STRING
4153 facf 1f 13              	TFR	X,U	SAVE REPLACEMENT STRING ADDRESS IN U
4154 fad1 ae 62              	LDX	$02,S	POINT X TO OLOSTRING DESCRIPTOR ADDRESS
4155 fad3 a6 84              	LDA	,X	GET LENGTH OF OLDSTRING
4156 fad5 a0 61              	SUBA	$01,S	SUBTRACT POSITION PARAMETER
4157 fad7 24 03              	BCC	L8727	INSERT REPLACEMENT STRING INTO OLDSTRING
4158 fad9 7e eb d3           L8724	JMP	LB44A	'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
4159 fadc 4c                 L8727	INCA		* NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
4160                         *		 * (INCLUSIVE) OF THE POSITION PARAMETER
4161 fadd a1 e4              	CMPA	,S
4162 fadf 24 02              	BCC	L872E	BRANCH IF NEW STRING WILL FIT IN OLDSTRING
4163 fae1 a7 e4              	STA	,S	IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
4164 fae3 a6 61              L872E	LDA	$01,S	GET POSITION PARAMETER
4165 fae5 1e 89              	EXG	A,B	ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
4166 fae7 ae 02              	LDX	$02,X	POINT X TO OLDSTRING ADDRESS
4167 fae9 5a                 	DECB		* BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
4168                         *	* WANTS IT TO START AT ZERO
4169 faea 3a                 	ABX		POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
4170 faeb 4d                 	TSTA		* IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
4171 faec 27 0d              	BEQ	L8746	* THEN RETURN
4172 faee a1 e4              	CMPA	,S
4173 faf0 23 02              	BLS	L873F	ADJUSTED LENGTH PARAMETER, THEN BRANCH
4174 faf2 a6 e4              	LDA	,S	OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
4175 faf4 1f 89              L873F	TFR	A,B	SAVE NUMBER OF BYTES TO MOVE IN ACCB
4176 faf6 1e 31              	EXG	U,X	SWAP SOURCE AND DESTINATION POINTERS
4177 faf8 bd e1 b3           	JSR	LA59A	MOVE (B) BYTES FROM (X) TO (U)
4178 fafb 35 96              L8746	PULS	A,B,X,PC
4179 fafd bd e8 e4           L8748	JSR	LB156	EVALUATE EXPRESSION
4180 fb00 7e ed dd           	JMP	LB654	*'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
4181                         *			*TO STRING, ACCB = LENGTH
4182                         
4183                         * STRING
4184 fb03 bd e9 f8           STRING	JSR	LB26A	SYNTAX CHECK FOR �(� 
4185 fb06 bd ee 94           	JSR	LB70B	EVALUATE EXPRESSION; ERROR IF > 255
4186 fb09 34 04              	PSHS	B	SAVE LENGTH OF STRING
4187 fb0b bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
4188 fb0e bd e8 e4           	JSR	LB156	EVALUATE EXPRESSION
4189 fb11 bd e9 f5           	JSR	LB267	SYNTAX CHECK FOR �)� 
4190 fb14 96 06              	LDA	VALTYP	GET VARIABLE TYPE
4191 fb16 26 05              	BNE	L8768	BRANCH IF STRING
4192 fb18 bd ee 97           	JSR	LB70E	CONVERT FPA0 INTO AN INTEGER IN ACCB
4193 fb1b 20 03              	BRA	L876B	SAVE THE STRING IN STRING SPACE
4194 fb1d bd ee 2d           L8768	JSR	LB6A4	GET FIRST BYTE OF STRING
4195 fb20 34 04              L876B	PSHS	B	SAVE FIRST BYTE OF EXPRESSION
4196 fb22 e6 61              	LDB	$01,S	GET LENGTH OF STRING
4197 fb24 bd ec 98           	JSR	LB50F	RESERVE ACCB BYTES IN STRING SPACE
4198 fb27 35 06              	PULS	A,B	GET LENGTH OF STRING AND CHARACTER
4199 fb29 27 05              	BEQ	L877B	BRANCH IF NULL STRING
4200 fb2b a7 80              L8776	STA	,X+	SAVE A CHARACTER IN STRING SPACE
4201 fb2d 5a                 	DECB		DECREMENT LENGTH
4202 fb2e 26 fb              	BNE	L8776	BRANCH IF NOT DONE
4203 fb30 7e ee 24           L877B	JMP	LB69B	PUT STRING DESCRIPTOR ONTO STRING STACK
4204                         
4205                         * INSTR
4206 fb33 bd e9 f8           INSTR	JSR	LB26A	SYNTAX CHECK FOR �(� 
4207 fb36 bd e8 e4           	JSR	LB156	EVALUATE EXPRESSION
4208 fb39 c6 01              	LDB	#$01	DEFAULT POSITION = 1 (SEARCH START)
4209 fb3b 34 04              	PSHS	B	SAVE START
4210 fb3d 96 06              	LDA	VALTYP	GET VARIABLE TYPE
4211 fb3f 26 10              	BNE	L879C	BRANCH IF STRING
4212 fb41 bd ee 97           	JSR	LB70E	CONVERT FPA0 TO INTEGER IN ACCB
4213 fb44 e7 e4              	STB	,S	SAVE START SEARCH VALUE
4214 fb46 27 91              	BEQ	L8724	BRANCH IF START SEARCH AT ZERO
4215 fb48 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
4216 fb4b bd e8 e4           	JSR	LB156	EVALUATE EXPRESSION - SEARCH STRING
4217 fb4e bd e8 d4           	JSR	LB146	'TM' ERROR IF NUMERIC
4218 fb51 9e 52              L879C	LDX	FPA0+2	SEARCH STRING DESCRIPTOR ADDRESS
4219 fb53 34 10              	PSHS	X	SAVE ON THE STACK
4220 fb55 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
4221 fb58 bd fa fd           	JSR	L8748	EVALUATE TARGET STRING EXPRESSION
4222 fb5b 34 14              	PSHS	X,B	SAVE ADDRESS AND LENGTH ON STACK
4223 fb5d bd e9 f5           	JSR	LB267	SYNTAX CHECK FOR ')'
4224 fb60 ae 63              	LDX	$03,S	* LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
4225 fb62 bd ed e2           	JSR	LB659	* AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
4226 fb65 34 04              	PSHS	B	SAVE LENGTH ON STACK
4227                         *
4228                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
4229                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
4230                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
4231 fb67 e1 66              	CMPB	$06,S	COMPARE LENGTH OF SEARCH STRING TO START
4232 fb69 25 23              	BLO	L87D9	POSITION; RETURN 0 IF LENGTH < START
4233 fb6b a6 61              	LDA	$01,S	GET LENGTH OF TARGET STRING
4234 fb6d 27 1c              	BEQ	L87D6	BRANCH IF TARGET STRING = NULL
4235 fb6f e6 66              	LDB	$06,S	GET START POSITION
4236 fb71 5a                 	DECB		MOVE BACK ONE
4237 fb72 3a                 	ABX	POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
4238 fb73 31 84              L87BE	LEAY	,X	POINT Y TO SEARCH POSITION
4239 fb75 ee 62              	LDU	$02,S	POINT U TO START OF TARGET
4240 fb77 e6 61              	LDB	$01,S	LOAD ACCB WITH LENGTH OF TARGET
4241 fb79 a6 e4              	LDA	,S	LOAD ACCA WITH LENGTH OF SEARCH
4242 fb7b a0 66              	SUBA	$06,S	SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
4243 fb7d 4c                 	INCA		ADD ONE
4244 fb7e a1 61              	CMPA	$01,S	COMPARE TO TARGET LENGTH
4245 fb80 25 0c              	BLO	L87D9	RETURN 0 IF TARGET LENGTH > WHAT�S LEFT OF SEARCH STRING
4246 fb82 a6 80              L87CD	LDA	,X+	GET A CHARACTER FROM SEARCH STRING
4247 fb84 a1 c0              	CMPA	,U+	COMPARE IT TO TARGET STRING
4248 fb86 26 0c              	BNE	L87DF	BRANCH IF NO MATCH
4249 fb88 5a                 	DECB		DECREMENT TARGET LENGTH
4250 fb89 26 f7              	BNE	L87CD	CHECK ANOTHER CHARACTER
4251 fb8b e6 66              L87D6	LDB	$06,S	GET MATCH POSITION
4252 fb8d 21                 L87D8	FCB	SKP1	SKIP NEXT BYTE
4253 fb8e 5f                 L87D9	CLRB		MATCH ADDRESS = 0
4254 fb8f 32 67              	LEAS	$07,S	CLEAN UP THE STACK
4255 fb91 7e ec 7c           	JMP	LB4F3	CONVERT ACCB TO FP NUMBER
4256 fb94 6c 66              L87DF	INC	$06,S	INCREMENT SEARCH POSITION
4257 fb96 30 21              	LEAX	$01,Y	MOVE X TO NEXT SEARCH POSITION
4258 fb98 20 d9              	BRA	L87BE	KEEP LOOKING FOR A MATCH
4259                         
4260                         * EXTENDED BASIC RVEC19 HOOK CODE
4261 fb9a 81 26              XVEC19	CMPA	#'&'	*
4262 fb9c 26 5c              	BNE	L8845	* RETURN IF NOT HEX OR OCTAL VARIABLE
4263 fb9e 32 62              	LEAS	$02,S	PURGE RETURN ADDRESS FROM STACK
4264                         * PROCESS A VARIABLE PRECEEDED BY A �&� (&H,&O)
4265 fba0 0f 52              L87EB	CLR	FPA0+2	* CLEAR BOTTOM TWO
4266 fba2 0f 53              	CLR	FPA0+3	* BYTES OF FPA0
4267 fba4 8e 00 52           	LDX	#FPA0+2	BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
4268 fba7 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
4269 fba9 81 4f              	CMPA	#'O'
4270 fbab 27 12              	BEQ	L880A	YES
4271 fbad 81 48              	CMPA	#'H'
4272 fbaf 27 23              	BEQ	L881F	YES
4273 fbb1 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
4274 fbb3 20 0c              	BRA	L880C	DEFAULT TO OCTAL (&O)
4275 fbb5 81 38              L8800	CMPA	#'8'
4276 fbb7 10 22 ee 4a        	LBHI	LB277
4277 fbbb c6 03              	LDB	#$03	BASE 8 MULTIPLIER
4278 fbbd 8d 2a              	BSR	L8834	ADD DIGIT TO TEMPORARY ACCUMULATOR
4279                         * EVALUATE AN &O VARIABLE
4280 fbbf 9d 7c              L880A	JSR	GETNCH	GET A CHARACTER FROM BASIC
4281 fbc1 25 f2              L880C	BLO	L8800	BRANCH IF NUMERIC
4282 fbc3 0f 50              L880E	CLR	FPA0	* CLEAR 2 HIGH ORDER
4283 fbc5 0f 51              	CLR	FPA0+1	* BYTES OF FPA0
4284 fbc7 0f 06              	CLR	VALTYP	SET VARXABLE TYPE TO NUMERIC
4285 fbc9 0f 63              	CLR	FPSBYT	ZERO OUT SUB BYTE OF FPA0
4286 fbcb 0f 54              	CLR	FP0SGN	ZERO OUT MANTISSA SIGN OF FPA0
4287 fbcd c6 a0              	LDB	#$A0	* SET EXPONENT OF FPA0
4288 fbcf d7 4f              	STB	FP0EXP	*
4289 fbd1 7e f1 67           	JMP	LBA1C	GO NORMALIZE FPA0
4290                         * EVALUATE AN &H VARIABLE
4291 fbd4 9d 7c              L881F	JSR	GETNCH	GET A CHARACTER FROM BASIC
4292 fbd6 25 0b              	BLO	L882E	BRANCH IF NUMERIC
4293 fbd8 bd eb 2b           	JSR	LB3A2	SET CARRY IF NOT ALPHA
4294 fbdb 25 e6              	BLO	L880E	BRANCH IF NOT ALPHA OR NUMERIC
4295 fbdd 81 47              	CMPA	#'G'	CHECK FOR LETTERS A-F
4296 fbdf 24 e2              	BCC	L880E	BRANCH IF >= G (ILLEGAL HEX LETTER)
4297 fbe1 80 07              	SUBA	#7	SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
4298 fbe3 c6 04              L882E	LDB	#$04	BASE 16 DIGIT MULTIPLIER = 2**4
4299 fbe5 8d 02              	BSR	L8834	ADD DIGIT TO TEMPORARY ACCUMULATOR
4300 fbe7 20 eb              	BRA	L881F	KEEP EVALUATING VARIABLE
4301 fbe9 68 01              L8834	ASL	$01,X	* MULTIPLY TEMPORARY
4302 fbeb 69 84              	ROL	,X	* ACCUMULATOR BY TWO
4303 fbed 10 25 f5 ec        	LBCS	LBA92	'OV' OVERFLOW ERROR
4304 fbf1 5a                 	DECB		DECREMENT SHIFT COUNTER
4305 fbf2 26 f5              	BNE	L8834	MULTIPLY TEMPORARY ACCUMULATOR AGAIN
4306 fbf4 80 30              	SUBA	#'0'	MASK OFF ASCII
4307 fbf6 ab 01              	ADDA	$01,X	* ADD DIGIT TO TEMPORARY
4308 fbf8 a7 01              	STA	$01,X	* ACCUMULATOR AND SAVE IT
4309 fbfa 39                 L8845	RTS
4310                         
4311 fbfb 35 40              XVEC15	PULS	U	PULL RETURN ADDRESS AND SAVE IN U REGISTER
4312 fbfd 0f 06              	CLR	VALTYP	SET VARIABLE TYPE TO NUMERIC
4313 fbff 9e 83              	LDX	CHARAD	CURRENT INPUT POINTER TO X
4314 fc01 9d 7c              	JSR	GETNCH	GET CHARACTER FROM BASIC
4315 fc03 81 26              	CMPA	#'&'	HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
4316 fc05 27 99              	BEQ	L87EB	PROCESS A '&' VARIABLE
4317 fc07 81 b0              	CMPA	#TOK_FN	TOKEN FOR FN
4318 fc09 27 5e              	BEQ	L88B4	PROCESS FN CALL
4319 fc0b 81 ff              	CMPA	#$FF	CHECK FOR SECONDARY TOKEN
4320 fc0d 26 08              	BNE	L8862	NOT SECONDARY
4321 fc0f 9d 7c              	JSR	GETNCH	GET CHARACTER FROM BASIC
4322 fc11 81 83              	CMPA	#TOK_USR	TOKEN FOR USR
4323 fc13 10 27 00 ab        	LBEQ	L892C	PROCESS USR CALL
4324 fc17 9f 83              L8862	STX	CHARAD	RESTORE BASIC�S INPUT POINTER
4325 fc19 6e c4              	JMP	,U	RETURN TO CALLING ROUTINE
4326 fc1b 9e 68              L8866	LDX	CURLIN	GET CURRENT LINE NUMBER
4327 fc1d 30 01              	LEAX	$01,X	IN DIRECT MODE?
4328 fc1f 26 d9              	BNE	L8845	RETURN IF NOT IN DIRECT MODE
4329 fc21 c6 16              	LDB	#2*11	'ILLEGAL DIRECT STATEMENT' ERROR
4330 fc23 7e e4 08           L886E	JMP	LAC46	PROCESS ERROR
4331                         
4332 fc26 ae 9f 00 83        DEF	LDX	[CHARAD]	GET TWO INPUT CHARS
4333 fc2a 8c ff 83           	CMPX	#TOK_FF_USR	TOKEN FOR USR
4334 fc2d 10 27 00 74        	LBEQ	L890F	BRANCH IF DEF USR
4335 fc31 8d 23              	BSR	L88A1	GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
4336 fc33 8d e6              	BSR	L8866	DON'T ALLOW DEF FN IF IN DIRECT MODE
4337 fc35 bd e9 f8           	JSR	LB26A	SYNTAX CHECK FOR '('
4338 fc38 c6 80              	LDB	#$80	* GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
4339 fc3a d7 08              	STB	ARYDIS	* AND SAVE IT IN THE ARRAY DISABLE FLAG
4340 fc3c bd ea e0           	JSR	LB357	GET VARIABLE DESCRIPTOR
4341 fc3f 8d 25              	BSR	L88B1	'TM' ERROR IF STRING
4342 fc41 bd e9 f5           	JSR	LB267	SYNTAX CHECK FOR ')'
4343 fc44 c6 ae              	LDB	#TOK_EQUALS	TOKEN FOR '='
4344 fc46 bd e9 fd           	JSR	LB26F	DO A SYNTAX CHECK FOR =
4345 fc49 9e 4b              	LDX	V4B	GET THE ADDRESS OF THE FN NAME DESCRIPTOR
4346 fc4b dc 83              	LDD	CHARAD	* GET THE CURRENT INPUT POINTER ADDRESS AND
4347 fc4d ed 84              	STD	,X	* SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
4348 fc4f dc 39              	LDD	VARPTR	= GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
4349 fc51 ed 02              	STD	$02,X	= VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
4350 fc53 7e e6 92           	JMP	DATA	MOVE INPUT POINTER TO END OF LINE OR SUBLINE
4351 fc56 c6 b0              L88A1	LDB	#TOK_FN	TOKEN FOR FN
4352 fc58 bd e9 fd           	JSR	LB26F	DO A SYNTAX CHECK FOR FN
4353 fc5b c6 80              	LDB	#$80	* GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
4354 fc5d d7 08              	STB	ARYDIS	* AND SAVE IT IN ARRAY VARIABLE FLAG
4355 fc5f 8a 80              	ORA	#$80	SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
4356 fc61 bd ea e5           	JSR	LB35C	* GET THE DESCRIPTOR ADDRESS OF THIS
4357 fc64 9f 4b              	STX	V4B	* VARIABLE AND SAVE IT IN V4B
4358 fc66 7e e8 d1           L88B1	JMP	LB143	'TM' ERROR IF STRING VARIABLE
4359                         * EVALUATE AN FN CALL
4360 fc69 8d eb              L88B4	BSR	L88A1	* GET THE DESCRIPTOR OF THE FN NAME
4361 fc6b 34 10              	PSHS	X	* VARIABLE AND SAVE IT ON THE STACK
4362 fc6d bd e9 f0           	JSR	LB262	SYNTAX CHECK FOR '(' & EVALUATE EXPR
4363 fc70 8d f4              	BSR	L88B1	'TM' ERROR IF STRING VARIABLE
4364 fc72 35 40              	PULS	U	POINT U TO FN NAME DESCRIPTOR
4365 fc74 c6 32              	LDB	#2*25	'UNDEFINED FUNCTION CALL' ERROR
4366 fc76 ae 42              	LDX	$02,U	POINT X TO ARGUMENT VARIABLE DESCRIPTOR
4367 fc78 27 a9              	BEQ	L886E	BRANCH TO ERROR HANDLER
4368 fc7a 10 9e 83           	LDY	CHARAD	SAVE CURRENT INPUT POINTER IN Y
4369 fc7d ee c4              	LDU	,U	* POINT U TO START OF FN FORMULA AND
4370 fc7f df 83              	STU	CHARAD	* SAVE IT IN INPUT POINTER
4371 fc81 a6 04              	LDA	$04,X	= GET FP VALUE OF
4372 fc83 34 02              	PSHS	A	= ARGUMENT VARIABLE, CURRENT INPUT
4373 fc85 ec 84              	LDD	,X	= POINTER, AND ADDRESS OF START
4374 fc87 ee 02              	LDU	$02,X	= OF FN FORMULA AND SAVE
4375 fc89 34 76              	PSHS	U,Y,X,B,A	= THEM ON THE STACK
4376 fc8b bd f3 80           	JSR	LBC35	PACK FPA0 AND SAVE IT IN (X)
4377 fc8e bd e8 cf           L88D9	JSR	LB141	EVALUATE FN EXPRESSION
4378 fc91 35 76              	PULS	A,B,X,Y,U	RESTORE REGISTERS
4379 fc93 ed 84              	STD	,X	* GET THE FP
4380 fc95 ef 02              	STU	$02,X	* VALUE OF THE ARGUMENT
4381 fc97 35 02              	PULS	A	* VARIABLE OFF OF THE
4382 fc99 a7 04              	STA	$04,X	* STACK AND RE-SAVE IT
4383 fc9b 9d 82              	JSR	GETCCH	GET FINAL CHARACTER OF THE FN FORMULA
4384 fc9d 10 26 ed 64        	LBNE	LB277	'SYNTAX' ERROR IF NOT END OF LINE
4385 fca1 10 9f 83           	STY	CHARAD	RESTORE INPUT POINTER
4386 fca4 39                 L88EF	RTS
4387                         
4388                         * DEF USR
4389 fca5 9d 7c              L890F	JSR	GETNCH	SKIP PAST SECOND BYTE OF DEF USR TOKEN
4390 fca7 8d 09              	BSR	L891C	GET FN NUMBER
4391 fca9 34 10              	PSHS	X	SAVE FN EXEC ADDRESS STORAGE LOC
4392 fcab 8d 2d              	BSR	L8944	CALCULATE EXEC ADDRESS
4393 fcad 35 40              	PULS	U	GET FN EXEC ADDRESS STORAGE LOC
4394 fcaf af c4              	STX	,U	SAVE EXEC ADDRESS
4395 fcb1 39                 	RTS
4396 fcb2 5f                 L891C	CLRB		DEFAULT TO USR0 IF NO ARGUMENT
4397 fcb3 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
4398 fcb5 24 06              	BCC	L8927	BRANCH IF NOT NUMERIC
4399 fcb7 80 30              	SUBA	#'0'	MASK OFF ASCII
4400 fcb9 1f 89              	TFR	A,B	SAVE USR NUMBER IN ACCB
4401 fcbb 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
4402 fcbd 9e 8d              L8927	LDX	USRADR	GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
4403 fcbf 58                 	ASLB		X2 - 2 BYTES/USR ADDRESS
4404 fcc0 3a                 	ABX		ADD OFFSET TO START ADDRESS OF STORAGE LOCs
4405 fcc1 39                 	RTS
4406                         * PROCESS A USR CALL
4407 fcc2 8d ee              L892C	BSR	L891C	GET STORAGE LOC OF EXEC ADDRESS FOR USR N
4408 fcc4 ae 84              	LDX	,X	* GET EXEC ADDRESS AND
4409 fcc6 34 10              	PSHS	X	* PUSH IT ONTO STACK
4410 fcc8 bd e9 f0           	JSR	LB262	SYNTAX CHECK FOR '(' & EVALUATE EXPR
4411 fccb 8e 00 4f           	LDX	#FP0EXP	POINT X TO FPA0
4412 fcce 96 06              	LDA	VALTYP	GET VARIABLE TYPE
4413 fcd0 27 07              	BEQ	L8943	BRANCH IF NUMERIC, STRING IF <> 0
4414 fcd2 bd ed e0           	JSR	LB657	GET LENGTH & ADDRESS OF STRING VARIABLE
4415 fcd5 9e 52              	LDX	FPA0+2	GET POINTER TO STRING DESCRIPTOR
4416 fcd7 96 06              	LDA	VALTYP	GET VARIABLE TYPE
4417 fcd9 39                 L8943	RTS		JUMP TO USR ROUTINE (PSHS X ABOVE)
4418 fcda c6 ae              L8944	LDB	#TOK_EQUALS	TOKEN FOR '='
4419 fcdc bd e9 fd           	JSR	LB26F	DO A SYNTAX CHECK FOR =
4420 fcdf 7e ee c6           	JMP	LB73D	EVALUATE EXPRESSION, RETURN VALUE IN X
4421                         * DEL
4422 fce2 10 27 ee ed        DEL	LBEQ	LB44A	'FC' ERROR IF NO ARGUMENT
4423 fce6 bd e7 19           	JSR	LAF67	CONVERT A DECIMAL BASiC NUMBER TO BINARY
4424 fce9 bd e4 a7           	JSR	LAD01	FIND RAM ADDRESS OF START OF A BASIC LINE
4425 fcec 9f 93              	STX	VD3	SAVE RAM ADDRESS OF STARTING LINE NUMBER
4426 fcee 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
4427 fcf0 27 10              	BEQ	L8990	BRANCH IF END OF LINE
4428 fcf2 81 a7              	CMPA	#TOK_MINUS	TOKEN FOR '-'
4429 fcf4 26 3b              	BNE	L89BF	TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY �-� 
4430 fcf6 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
4431 fcf8 27 04              	BEQ	L898C	IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
4432 fcfa 8d 24              	BSR	L89AE	* CONVERT ENDING LINE NUMBER TO BINARY
4433 fcfc 20 04              	BRA	L8990	* AND SAVE IT IN BINVAL
4434 fcfe 86 ff              L898C	LDA	#$FF	= USE $FFXX AS DEFAULT ENDING
4435 fd00 97 2b              	STA	BINVAL	= LINE NUMBER - SAVE IT IN BINVAL
4436 fd02 de 93              L8990	LDU	VD3	POINT U TO STARTING LINE NUMBER ADDRESS
4437 fd04 8c                 L8992	FCB	SKP2	SKIP TWO BYTES
4438 fd05 ee c4              L8993	LDU	,U	POINT U TO START OF NEXT LINE
4439 fd07 ec c4              	LDD	,U	CHECK FOR END OF PROGRAM
4440 fd09 27 06              	BEQ	L899F	BRANCH IF END OF PROGRAM
4441 fd0b ec 42              	LDD	$02,U	LOAD ACCD WITH THIS LINE�S NUMBER
4442 fd0d 93 2b              	SUBD	BINVAL	SUBTRACT ENDING LINE NUMBER ADDRESS
4443 fd0f 23 f4              	BLS	L8993	BRANCH IF = < ENDING LINE NUMBER
4444 fd11 9e 93              L899F	LDX	VD3	GET STARTING LINE NUMBER
4445 fd13 8d 15              	BSR	L89B8	MOVE (U) TO (X) UNTIL END OF PROGRAM
4446 fd15 bd e4 c7           	JSR	LAD21	RESET BASIC�S INPUT POINTER AND ERASE VARIABLES
4447 fd18 9e 93              	LDX	VD3	GET STARTING LINE NUMBER ADDRESS
4448 fd1a bd e4 97           	JSR	LACF1	RECOMPUTE START OF NEXT LINE ADDRESSES
4449 fd1d 7e e4 27           	JMP	LAC73	JUMP TO BASIC'S MAIN COMMAND LOOP
4450 fd20 bd e7 19           L89AE	JSR	LAF67	GO GET LINE NUMBER CONVERTED TO BINARY
4451 fd23 7e e1 bc           	JMP	LA5C7	MAKE SURE THERE'S NO MORE ON THIS LINE
4452 fd26 a6 c0              L89B4	LDA	,U+	GET A BYTE FROM (U)
4453 fd28 a7 80              	STA	,X+	MOVE THE BYTE TO (X)
4454 fd2a 11 93 1b           L89B8	CMPU	VARTAB	COMPARE TO END OF BASIC
4455 fd2d 26 f7              	BNE	L89B4	BRANCH IF NOT AT END
4456 fd2f 9f 1b              	STX	VARTAB	SAVE (X) AS NEW END OF BASIC
4457 fd31 39                 L89BF	RTS
4458                         
4459 fd32 bd fc 1b           L89C0	JSR	L8866	'BS' ERROR IF IN DIRECT MODE
4460 fd35 9d 7c              	JSR	GETNCH	GET A CHAR FROM BASIC
4461 fd37 81 22              L89D2	CMPA	#'"'	CHECK FOR PROMPT STRING
4462 fd39 26 0b              	BNE	L89E1	BRANCH IF NO PROMPT STRING
4463 fd3b bd e9 d2           	JSR	LB244	STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
4464 fd3e c6 3b              	LDB	#';'	*
4465 fd40 bd e9 fd           	JSR	LB26F	* DO A SYNTAX CHECK FOR;
4466 fd43 bd f0 ea           	JSR	LB99F	REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
4467 fd46 32 7e              L89E1	LEAS	$-02,S	RESERVE TWO STORAGE SLOTS ON STACK
4468 fd48 bd e7 ce           	JSR	LB035	INPUT A LINE FROM CURRENT INPUT DEVICE
4469 fd4b 32 62              	LEAS	$02,S	CLEAN UP THE STACK
4470 fd4d bd ea e0           	JSR	LB357	SEARCH FOR A VARIABLE
4471 fd50 9f 3b              	STX	VARDES	SAVE POINTER TO VARIABLE DESCRIPTOR
4472 fd52 bd e8 d4           	JSR	LB146	'TM' ERROR IF VARIABLE TYPE = NUMERIC
4473 fd55 8e 00 f3           	LDX	#LINBUF	POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
4474 fd58 4f                 	CLRA		TERMINATOR CHARACTER 0 (END OF LINE)
4475 fd59 bd ec a5           	JSR	LB51A	PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
4476 fd5c 7e e7 56           	JMP	LAFA4	REMOVE DESCRIPTOR FROM STRING STACK
4477 fd5f bd e7 19           L89FC	JSR	LAF67	STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
4478 fd62 9e 2b              	LDX	BINVAL	GET BINARY VALUE
4479 fd64 39                 	RTS
4480 fd65 9e 91              L8A02	LDX	VD1	GET CURRENT OLD NUMBER BEING RENUMBERED
4481 fd67 9f 2b              L8A04	STX	BINVAL	SAVE THE LINE NUMBER BEING SEARCHED FOR
4482 fd69 7e e4 a7           	JMP	LAD01	GO FIND THE LINE NUMBER IN BASIC PROGRAM
4483                         
4484                         * RENUM
4485 fd6c bd e4 cc           RENUM	JSR	LAD26	ERASE VARIABLES
4486 fd6f cc 00 0a           	LDD	#10	DEFAULT LINE NUMBER INTERVAL
4487 fd72 dd 95              	STD	VD5	SAVE DEFAULT RENUMBER START LINE NUMBER
4488 fd74 dd 8f              	STD	VCF	SAVE DEFAULT INTERVAL
4489 fd76 5f                 	CLRB		NOW ACCD = 0
4490 fd77 dd 91              	STD	VD1	DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
4491 fd79 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
4492 fd7b 24 06              	BCC	L8A20	BRANCH IF NOT NUMERIC
4493 fd7d 8d e0              	BSR	L89FC	CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4494 fd7f 9f 95              	STX	VD5	SAVE LINE NUMBER WHERE RENUMBERING STARTS
4495 fd81 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
4496 fd83 27 1b              L8A20	BEQ	L8A3D	BRANCH IF END OF LINE
4497 fd85 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
4498 fd88 24 06              	BCC	L8A2D	BRANCH IF NEXT CHARACTER NOT NUMERIC
4499 fd8a 8d d3              	BSR	L89FC	CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4500 fd8c 9f 91              	STX	VD1	SAVE NEW RENUMBER LINE
4501 fd8e 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
4502 fd90 27 0e              L8A2D	BEQ	L8A3D	BRANCH IF END OF LINE
4503 fd92 bd e9 fb           	JSR	LB26D	SYNTAX CHECK FOR COMMA
4504 fd95 24 06              	BCC	L8A3A	BRANCH IF NEXT CHARACTER NOT NUMERIC
4505 fd97 8d c6              	BSR	L89FC	CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4506 fd99 9f 8f              	STX	VCF	SAVE NEW INTERVAL
4507 fd9b 27 49              	BEQ	L8A83	'FC' ERROR
4508 fd9d bd e1 bc           L8A3A	JSR	LA5C7	CHECK FOR MORE CHARACTERS ON LINE - �SYNTAX� ERROR IF ANY
4509 fda0 8d c3              L8A3D	BSR	L8A02	GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
4510 fda2 9f 93              	STX	VD3	SAVE ADDRESS
4511 fda4 9e 95              	LDX	VD5	GET NEXT RENUMBERED LINE NUMBER TO USE
4512 fda6 8d bf              	BSR	L8A04	FIND THE LINE NUMBER IN THE BASIC PROGRAM
4513 fda8 9c 93              	CMPX	VD3	COMPARE TO ADDRESS OF OLD LINE NUMBER
4514 fdaa 25 3a              	BLO	L8A83	'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
4515 fdac 8d 1c              	BSR	L8A67	MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
4516 fdae bd fe 40           	JSR	L8ADD	CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
4517 fdb1 bd e4 95           	JSR	LACEF	RECALCULATE NEXT LINE RAM ADDRESSES
4518 fdb4 8d af              	BSR	L8A02	GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
4519 fdb6 9f 93              	STX	VD3	SAVE IT
4520 fdb8 8d 3a              	BSR	L8A91	MAKE SURE LINE NUMBERS EXIST
4521 fdba 8d 0f              	BSR	L8A68	INSERT NEW LINE NUMBERS IN LINE HEADERS
4522 fdbc 8d 36              	BSR	L8A91	INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
4523 fdbe bd fe db           	JSR	L8B7B	CONVERT PACKED BINARY LINE NUMBERS TO ASCII
4524 fdc1 bd e4 cc           	JSR	LAD26	ERASE VARIABLES
4525 fdc4 bd e4 95           	JSR	LACEF	RECALCULATE NEXT LINE RAM ADDRESS
4526 fdc7 7e e4 27           	JMP	LAC73	GO BACK TO BASIC�S MAIN LOOP
4527 fdca 86                 L8A67	FCB	SKP1LD	SKIP ONE BYTE - LDA #$4F
4528 fdcb 4f                 L8A68	CLRA		NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
4529 fdcc 97 98              	STA	VD8	SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
4530 fdce 9e 93              	LDX	VD3	GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
4531 fdd0 dc 95              	LDD	VD5	GET THE CURRENT RENUMBERED LINE NUMBER
4532 fdd2 8d 15              	BSR	L8A86	RETURN IF END OF PROGRAM
4533 fdd4 0d 98              L8A71	TST	VD8	CHECK NEW LINE NUMBER FLAG
4534 fdd6 26 02              	BNE	L8A77	BRANCH IF NOT INSERTING NEW LINE NUMBERS
4535 fdd8 ed 02              	STD	$02,X	STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
4536 fdda ae 84              L8A77	LDX	,X	POINT X TO THE NEXT LINE IN BASIC
4537 fddc 8d 0b              	BSR	L8A86	RETURN IF END OF PROGRAM
4538 fdde d3 8f              	ADDD	VCF	ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
4539 fde0 25 04              	BLO	L8A83	'FC' ERROR IF LINE NUMBER > $FFFF
4540 fde2 81 fa              	CMPA	#MAXLIN	LARGEST LINE NUMBER = $F9FF
4541 fde4 25 ee              	BLO	L8A71	BRANCH IF LEGAL LINE NUMBER
4542 fde6 7e eb d3           L8A83	JMP	LB44A	'FC' ERROR IF LINE NUMBER MS BYTE > $F9
4543                         * TEST THE TWO BYTES POINTED TO BY (X).
4544                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
4545                         * PROGRAM) RETURN IS PULLED OFF STACK AND
4546                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
4547 fde9 34 06              L8A86	PSHS	B,A	SAVE ACCD
4548 fdeb ec 84              	LDD	,X	TEST THE 2 BYTES POINTED TO BY X
4549 fded 35 06              	PULS	A,B	RESTORE ACCD
4550 fdef 26 02              	BNE	L8A90	BRANCH IF NOT END OF PROGRAM
4551 fdf1 32 62              	LEAS	$02,S	PURGE RETURN ADDRESS FROM STACK
4552 fdf3 39                 L8A90	RTS
4553 fdf4 9e 19              L8A91	LDX	TXTTAB	GET START OF BASIC PROGRAM
4554 fdf6 30 1f              	LEAX	$-01,X	MOVE POINTER BACK ONE
4555 fdf8 30 01              L8A95	LEAX	$01,X	MOVE POINTER UP ONE
4556 fdfa 8d ed              	BSR	L8A86	RETURN IF END OF PROGRAM
4557 fdfc 30 03              L8A99	LEAX	$03,X	SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
4558 fdfe 30 01              L8A9B	LEAX	$01,X	MOVE POINTER TO NEXT CHARACTER
4559 fe00 a6 84              	LDA	,X	CHECK CURRENT CHARACTER
4560 fe02 27 f4              	BEQ	L8A95	BRANCH IF END OF LINE
4561 fe04 9f 0f              	STX	TEMPTR	SAVE CURRENT POINTER
4562 fe06 4a                 	DECA		=
4563 fe07 27 0c              	BEQ	L8AB2	=BRANCH IF START OF PACKED NUMERIC LINE
4564 fe09 4a                 	DECA		*
4565 fe0a 27 2a              	BEQ	L8AD3	*BRANCH IF LINE NUMBER EXISTS
4566 fe0c 4a                 	DECA		=
4567 fe0d 26 ef              	BNE	L8A9B	=MOVE TO NEXT CHARACTER IF > 3
4568 fe0f 86 03              L8AAC	LDA	#$03	* SET 1ST BYTE = 3 TO INDICATE LINE
4569 fe11 a7 80              	STA	,X+	* NUMBER DOESN�T CURRENTLY EXIST
4570 fe13 20 e7              	BRA	L8A99	GO GET ANOTHER CHARACTER
4571 fe15 ec 01              L8AB2	LDD	$01,X	GET MS BYTE OF LINE NUMBER
4572 fe17 6a 02              	DEC	$02,X	DECREMENT ZERO CHECK BYTE
4573 fe19 27 01              	BEQ	L8AB9	BRANCH IF MS BYTE <> 0
4574 fe1b 4f                 	CLRA		CLEAR MS BYTE
4575 fe1c e6 03              L8AB9	LDB	$03,X	GET LS BYTE OF LINE NUMBER
4576 fe1e 6a 04              	DEC	$04,X	DECREMENT ZERO CHECK FLAG
4577 fe20 27 01              	BEQ	L8AC0	BRANCH IF IS BYTE <> 0
4578 fe22 5f                 	CLRB		CLEAR LS BYTE
4579 fe23 ed 01              L8AC0	STD	$01,X	SAVE BINARY LINE NUMBER
4580 fe25 dd 2b              	STD	BINVAL	SAVE TRIAL LINE NUMBER
4581 fe27 bd e4 a7           	JSR	LAD01	FIND RAM ADDRESS OF A BASIC LINE NUMBER
4582 fe2a 9e 0f              L8AC7	LDX	TEMPTR	GET BACK POINTER TO START OF PACKED LINE NUMBER
4583 fe2c 25 e1              	BLO	L8AAC	BRANCH IF NO LINE NUMBER MATCH FOUND
4584 fe2e dc 47              	LDD	V47	GET START ADDRESS OF LINE NUMBER
4585 fe30 6c 80              	INC	,X+	* SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
4586                         *	* EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
4587                         
4588 fe32 ed 84              	STD	,X	SAVE RAM ADDRESS OF CORRECT LINE NUMBER
4589 fe34 20 c6              	BRA	L8A99	GO GET ANOTHER CHARACTER
4590 fe36 6f 84              L8AD3	CLR	,X	CLEAR CARRY FLAG AND 1ST BYTE
4591 fe38 ae 01              	LDX	$01,X	POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
4592 fe3a ae 02              	LDX	$02,X	PUT CORRECT LINE NUMBER INTO (X)
4593 fe3c 9f 47              	STX	V47	SAVE IT TEMPORARILY
4594 fe3e 20 ea              	BRA	L8AC7	GO INSERT IT INTO BASIC LINE
4595 fe40 9e 19              L8ADD	LDX	TXTTAB	GET BEGINNING OF BASIC PROGRAM
4596 fe42 20 04              	BRA	L8AE5
4597 fe44 9e 83              L8AE1	LDX	CHARAD	*GET CURRENT INPUT POINTER
4598 fe46 30 01              	LEAX	$01,X	*AND BUMP IT ONE
4599 fe48 8d 9f              L8AE5	BSR	L8A86	RETURN IF END OF PROGRAM
4600 fe4a 30 02              	LEAX	$02,X	SKIP PAST NEXT LINE ADDRESS
4601 fe4c 30 01              L8AE9	LEAX	$01,X	ADVANCE POINTER BY ONE
4602 fe4e 9f 83              L8AEB	STX	CHARAD	SAVE NEW BASIC INPUT POINTER
4603 fe50 9d 7c              L8AED	JSR	GETNCH	GET NEXT CHARACTER FROM BASIC
4604 fe52 4d                 L8AEF	TSTA		CHECK THE CHARACTER
4605 fe53 27 ef              	BEQ	L8AE1	BRANCH IF END OF LINE
4606 fe55 2a f9              	BPL	L8AED	BRANCH IF NOT A TOKEN
4607 fe57 9e 83              	LDX	CHARAD	GET CURRENT INPUT POINTER
4608 fe59 81 ff              	CMPA	#$FF	IS THIS A SECONDARY TOKEN?
4609 fe5b 27 ef              	BEQ	L8AE9	YES - IGNORE IT
4610 fe5d 81 a2              	CMPA	#TOK_THEN	TOKEN FOR THEN?
4611 fe5f 27 12              	BEQ	L8B13	YES
4612 fe61 81 84              	CMPA	#TOK_ELSE	TOKEN FOR ELSE?
4613 fe63 27 0e              	BEQ	L8B13	YES
4614 fe65 81 81              	CMPA	#TOK_GO	TOKEN FOR GO?
4615 fe67 26 e7              	BNE	L8AED	NO
4616 fe69 9d 7c              	JSR	GETNCH	GET A CHARACTER FROM BASIC
4617 fe6b 81 a0              	CMPA	#TOK_TO	TOKEN FOR TO?
4618 fe6d 27 04              	BEQ	L8B13	YES
4619 fe6f 81 a1              	CMPA	#TOK_SUB	TOKEN FOR SUB?
4620 fe71 26 db              	BNE	L8AEB	NO
4621 fe73 9d 7c              L8B13	JSR	GETNCH	GET A CHARACTER FROM BASIC
4622 fe75 25 04              	BLO	L8B1B	BRANCH IF NUMERIC
4623 fe77 9d 82              L8B17	JSR	GETCCH	GET CURRENT BASIC INPUT CHARRACTER
4624 fe79 20 d7              	BRA	L8AEF	KEEP CHECKING THE LINE
4625 fe7b 9e 83              L8B1B	LDX	CHARAD	GET CURRENT INPUT ADDRESS
4626 fe7d 34 10              	PSHS	X	SAVE IT ON THE STACK
4627 fe7f bd e7 19           	JSR	LAF67	CONVERT DECIMAL BASIC NUMBER TO BINARY
4628 fe82 9e 83              	LDX	CHARAD	GET CURRENT INPUT POINTER
4629 fe84 a6 82              L8B24	LDA	,-X	GET PREVIOUS INPUT CHARACTER
4630 fe86 bd ff 78           	JSR	L90AA	CLEAR CARRY IF NUMERIC INPUT VALUE
4631 fe89 25 f9              	BLO	L8B24	BRANCH IF NON-NUMERIC
4632 fe8b 30 01              	LEAX	$01,X	MOVE POINTER UP ONE
4633 fe8d 1f 10              	TFR	X,D	NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
4634 fe8f e0 61              	SUBB	$01,S	SUBTRACT PRE-NUMERIC POINTER LS BYTE
4635 fe91 c0 05              	SUBB	#$05	MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
4636                         *
4637 fe93 27 20              	BEQ	L8B55	BRANCH IF EXACTLY 5
4638 fe95 25 0a              	BLO	L8B41	BRANCH IF < 5
4639 fe97 33 84              	LEAU	,X	TRANSFER X TO U
4640 fe99 50                 	NEGB		NEGATE B
4641 fe9a 30 85              	LEAX	B,X	MOVE X BACK B BYTES
4642 fe9c bd fd 2a           	JSR	L89B8	*MOVE BYTES FROM (U) TO (X) UNTIL
4643                         *	*U	= END OF BASIC; (I) = NEW END OF BASIC
4644 fe9f 20 14              	BRA	L8B55
4645                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
4646 fea1 9f 47              L8B41	STX	V47	SAVE END OF NUMERIC VALUE
4647 fea3 9e 1b              	LDX	VARTAB	GET END OF BASIC PROGRAM
4648 fea5 9f 43              	STX	V43	SAVE IT
4649 fea7 50                 	NEGB		NEGATE B
4650 fea8 30 85              	LEAX	B,X	ADD IT TO END OF NUMERIC POiNTER
4651 feaa 9f 41              	STX	V41	SAVE POINTER
4652 feac 9f 1b              	STX	VARTAB	STORE END OF BASIC PROGRAM
4653 feae bd e3 e0           	JSR	LAC1E	ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
4654 feb1 9e 45              	LDX	V45	* GET AND SAVE THE
4655 feb3 9f 83              	STX	CHARAD	* NEW CURRENT INPUT POINTER
4656 feb5 35 10              L8B55	PULS	X	RESTORE POINTER TO START OF NUMERIC VALUE
4657 feb7 86 01              	LDA	#$01	NEW LINE NUMBER FLAG
4658 feb9 a7 84              	STA	,X	* SAVE NEW LINE FLAG
4659 febb a7 02              	STA	$02,X	*
4660 febd a7 04              	STA	$04,X	*
4661 febf d6 2b              	LDB	BINVAL	GET MS BYTE OF BINARY LINE NUMBER
4662 fec1 26 04              	BNE	L8B67	BRANCH IF IT IS NOT ZERO
4663 fec3 c6 01              	LDB	#$01	SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
4664                         *	THINK IT IS THE END OF A LINE
4665 fec5 6c 02              	INC	$02,X	IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
4666 fec7 e7 01              L8B67	STB	$01,X	SAVE MS BYTE OF BINARY LINE NUMBER
4667 fec9 d6 2c              	LDB	BINVAL+1	GET IS BYTE OF BINARY LINE NUMBER
4668 fecb 26 04              	BNE	L8B71	BRANCH IF NOT A ZERO BYTE
4669 fecd c6 01              	LDB	#$01	SAVE A 1 IF BYTE IS A 0
4670 fecf 6c 04              	INC	$04,X	IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
4671 fed1 e7 03              L8B71	STB	$03,X	SAVE LS BYTE OF BINARY LINE NUMBER
4672 fed3 9d 82              	JSR	GETCCH	GET CURRENT INPUT CHARACTER
4673 fed5 81 2c              	CMPA	#','	IS IT A COMMA?
4674 fed7 27 9a              	BEQ	L8B13	YES - PROCESS ANOTHER NUMERIC VALUE
4675 fed9 20 9c              	BRA	L8B17	NO - GO GET AND PROCESS AN INPUT CHARACTER
4676 fedb 9e 19              L8B7B	LDX	TXTTAB	POINT X TO START OF BASIC PROGRAM
4677 fedd 30 1f              	LEAX	$-01,X	MOVE POINTER BACK ONE
4678 fedf 30 01              L8B7F	LEAX	$01,X	MOVE POINTER UP ONE
4679 fee1 ec 02              	LDD	$02,X	GET ADDRESS OF NEXT LINE
4680 fee3 dd 68              	STD	CURLIN	SAVE IT IN CURLIN
4681 fee5 bd fd e9           	JSR	L8A86	RETURN IF END OF PROGRAM
4682 fee8 30 03              	LEAX	$03,X	SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
4683 feea 30 01              L8B8A	LEAX	$01,X	MOVE POINTER UP ONE
4684 feec a6 84              L8B8C	LDA	,X	GET CURRENT CHARACTER
4685 feee 27 ef              	BEQ	L8B7F	BRANCH IF END OF LINE
4686 fef0 4a                 	DECA		INPUT CHARACTER = 1? - VALID LINE NUMBER
4687 fef1 27 1b              	BEQ	L8BAE	YES
4688 fef3 80 02              	SUBA	#$02	INPUT CHARACTER 3? - UL LINE NUMBER
4689 fef5 26 f3              	BNE	L8B8A	NO
4690 fef7 34 10              	PSHS	X	SAVE CURRENT POSITION OF INPUT POINTER
4691 fef9 8e ff 38           	LDX	#L8BD9-1	POINT X TO 'UL' MESSAGE
4692 fefc bd f0 e7           	JSR	LB99C	PRINT STRING TO THE SCREEN
4693 feff ae e4              	LDX	,S	GET INPUT POINTER
4694 ff01 ec 01              	LDD	$01,X	GET THE UNDEFINED LINE NUMBER
4695 ff03 bd f5 17           	JSR	LBDCC	CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
4696 ff06 bd f5 10           	JSR	LBDC5	PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
4697 ff09 bd f0 a7           	JSR	LB958	SEND A CR TO CONSOLE OUT
4698 ff0c 35 10              	PULS	X	GET INPUT POINTER BACK
4699 ff0e 34 10              L8BAE	PSHS	X	SAVE CURRENT POSITION OF INPUT POINTER
4700 ff10 ec 01              	LDD	$01,X	LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
4701 ff12 dd 52              	STD	FPA0+2	SAVE IN BOTTOM 2 BYTES OF FPA0
4702 ff14 bd fb c3           	JSR	L880E	ADJUST REST OF FPA0 AS AN INTEGER
4703 ff17 bd f5 24           	JSR	LBDD9	CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
4704 ff1a 35 40              	PULS	U	LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
4705 ff1c c6 05              	LDB	#$05	EACH EXPANDED LINE NUMBER USES 5 BYTES
4706 ff1e 30 01              L8BBE	LEAX	$01,X	MOVE POINTER FORWARD ONE
4707 ff20 a6 84              	LDA	,X	GET AN ASCII BYTE
4708 ff22 27 05              	BEQ	L8BC9	BRANCH IF END OF NUMBER
4709 ff24 5a                 	DECB		DECREMENT BYTE COUNTER
4710 ff25 a7 c0              	STA	,U+	STORE ASCII NUMBER IN BASIC LINE
4711 ff27 20 f5              	BRA	L8BBE	CHECK FOR ANOTHER DIGIT
4712 ff29 30 c4              L8BC9	LEAX	,U	TRANSFER NEW LINE POINTER TO (X)
4713 ff2b 5d                 	TSTB	DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
4714 ff2c 27 be              	BEQ	L8B8C	YES - GO GET ANOTHER INPUT CHARACTER
4715 ff2e 31 c4              	LEAY	,U	SAVE NEW LINE POINTER IN Y
4716 ff30 33 c5              	LEAU	B,U	POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
4717 ff32 bd fd 2a           	JSR	L89B8	MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
4718 ff35 30 a4              	LEAX	,Y	LOAD (X) WITH NEW LINE POINTER
4719 ff37 20 b3              	BRA	L8B8C	GO GET ANOTHER INPUT CHARACTER
4720                         
4721 ff39 55 4c 20           L8BD9	FCC	"UL "	UNKNOWN LINE NUMBER MESSAGE
4722 ff3c 00                 	FCB	0
4723                         
4724                         
4725 ff3d bd ee c9           HEXDOL	JSR	LB740	CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
4726 ff40 8e 01 f0           	LDX	#STRBUF+2	POINT TO TEMPORARY BUFFER
4727 ff43 c6 04              	LDB	#$04	CONVERT 4 NIBBLES
4728 ff45 34 04              L8BE5	PSHS	B	SAVE NIBBLE COUNTER
4729 ff47 5f                 	CLRB		CLEAR CARRY FLAG
4730 ff48 86 04              	LDA	#$04	4 SHIFTS
4731 ff4a 08 53              L8BEA	ASL	FPA0+3	* SHIFT BOTTOM TWO BYTES OF
4732 ff4c 09 52              	ROL	FPA0+2	* FPA0 LEFT ONE BIT (X2)
4733 ff4e 59                 	ROLB		IF OVERFLOW, ACCB <> 0
4734 ff4f 4a                 	DECA		* DECREMENT SHIFT COUNTER AND
4735 ff50 26 f8              	BNE	L8BEA	* BRANCH IF NOT DONE
4736 ff52 5d                 	TSTB	CHECK	FOR OVERFLOW
4737 ff53 26 0a              	BNE	L8BFF	BRANCH IF OVERFLOW
4738 ff55 a6 e4              	LDA	,S	* GET NIBBLE COUNTER,
4739 ff57 4a                 	DECA		* DECREMENT IT AND
4740 ff58 27 05              	BEQ	L8BFF	* BRANCH IF DONE
4741 ff5a 8c 01 f0           	CMPX	#STRBUF+2	DO NOT DO A CONVERSION UNTIL A NON-ZERO
4742 ff5d 27 0c              	BEQ	L8C0B	BYTE IS FOUND - LEADING ZERO SUPPRESSION
4743 ff5f cb 30              L8BFF	ADDB	#'0'	ADD IN ASCII ZERO
4744 ff61 c1 39              	CMPB	#'9'	COMPARE TO ASCII 9
4745 ff63 23 02              	BLS	L8C07	BRANCH IF < 9
4746 ff65 cb 07              	ADDB	#7	ADD ASCII OFFSET IF HEX LETTER
4747 ff67 e7 80              L8C07	STB	,X+	STORE HEX VALUE AND ADVANCE POINTER
4748 ff69 6f 84              	CLR	,X	CLEAR NEXT BYTE - END OF STRING FLAG
4749 ff6b 35 04              L8C0B	PULS	B	* GET NIBBLE COUNTER,
4750 ff6d 5a                 	DECB		* DECREMENT IT AND
4751 ff6e 26 d5              	BNE	L8BE5	* BRANCH IF NOT DONE
4752 ff70 32 62              	LEAS	$02,S	PURGE RETURN ADDRESS OFF OF STACK
4753 ff72 8e 01 ef           	LDX	#STRBUF+1	RESET POINTER
4754 ff75 7e ec a1           	JMP	LB518	SAVE STRING ON STRING STACK
4755                         
4756                         
4757                         * CLEAR CARRY IF NUMERIC
4758 ff78 81 30              L90AA	CMPA	#'0'	ASCII ZERO
4759 ff7a 25 04              	BLO	L90B2	RETURN IF ACCA < ASCII 0
4760 ff7c 80 3a              	SUBA	#$3A	*	#'9'+1
4761 ff7e 80 c6              	SUBA	#$C6	* #-('9'+1)	CARRY CLEAR IF NUMERIC
4762 ff80 39                 L90B2	RTS
4763                         
4764                         
4765                         * LINE
4766 ff81 81 89              LINE	CMPA	#TOK_INPUT	'INPUT' TOKEN
4767 ff83 10 27 fd ab        	LBEQ	L89C0	GO DO 'LINE INPUT' COMMAND
4768 ff87 7e ea 05           	JMP	LB277	'SYNTAX ERROR' IF NOT "LINE INPUT"
4769                         
4770                         
4771                         * END OF EXTENDED BASIC
4772                         * INTERRUPT VECTORS
4773 fff0                    	ORG	$FFF0
4774 fff0 00 00              LBFF0	FDB	$0000	RESERVED
4775 fff2 00 9b              LBFF2	FDB	SW3VEC	SWI3
4776 fff4 00 9e              LBFF4	FDB	SW2VEC	SWI2
4777 fff6 00 aa              LBFF6	FDB	FRQVEC	FIRQ
4778 fff8 00 a7              LBFF8	FDB	IRQVEC	IRQ
4779 fffa 00 a1              LBFFA	FDB	SWIVEC	SWI
4780 fffc 00 a4              LBFFC	FDB	NMIVEC	NMI
4781 fffe e0 46              LBFFE	FDB	RESVEC	RESET
